package internalTests

import htsjdk.variant._;
import htsjdk.variant.variantcontext._;
import htsjdk.variant.vcf._;
import java.io.File;
//import scala.collection.JavaConversions._
import java.io._;
import internalUtils.commandLineUI._;
import internalUtils.Reporter._;

//import scala.collection.JavaConversions._
import scala.collection.JavaConverters._

import internalUtils.optionHolder._;
import internalUtils.Reporter._;
import internalUtils.stdUtils._;
import internalUtils.genomicAnnoUtils._;
import internalUtils.GtfTool._;
import internalUtils.commandLineUI._;
import internalUtils.fileUtils._;
import internalUtils.TXUtil._;
import internalUtils.TXUtil

import internalUtils.VcfTool._;

import internalUtils.VcfTool;

import htsjdk.variant._;
import htsjdk.variant.variantcontext._;
import htsjdk.variant.vcf._;

import internalUtils.genomicUtils._;
import internalUtils.commonSeqUtils._;

import jigwig.BigWigFile;

import SVcfTagFunctions._;
import SVcfWalkerUtils._;

//import com.timgroup.iterata.ParIterator.Implicits._;

object SVcfMapFunctions {

  
  
  
  
    val SNVVARIANT_BASESWAP_LIST = Seq( (("A","C"),("T","G")),
                            (("A","T"),("T","A")),
                            (("A","G"),("T","C")),
                            (("C","A"),("G","T")),
                            (("C","T"),("G","A")),
                            (("C","G"),("G","C"))
                          );

     val DEFAULT_VCF_CODES = VCFAnnoCodes();

     val COMMON_PARAMS : Map[String,ParamStr] = Seq[ParamStr](
           ParamStr(id = "genomeFA",synon=Seq(),ty="String",valueString="genome.fasta.gz",desc="The genome fasta file containing the reference genome. This will be used by various functions that require genomic information. Note that some functions that call the GATK library will also require that the fasta be indexed. Note: Chromosome names must match.",req=true),
           ParamStr(id = "groupFile",synon=Seq(),ty="String",valueString="group.file.txt",desc="A tab-delimited file containing sample ID's and a list of group IDs for each sample. See the --groupFile parameter of walkVcf.",req=false),
           ParamStr(id = "superGroupList",synon=Seq(),ty="String",valueString="superGroups",desc="See the --superGroupList parameter of walkVcf.",req=false,hidden=true)
                 ).map{ ps => {
                   (ps.id,ps)
                 }}.toMap
  
     val DEFAULT_MAP_PARAMS : Seq[ParamStr] = Seq[ParamStr](
           ParamStr(id = "mapType",synon=Seq(),ty="String",valueString="s",desc="The function to run.",req=true,initParam = false, hidden=true),
           ParamStr(id = "mapID",synon=Seq(),ty="String",valueString="id",desc="The ID to use for this operation. This ID will also be used in the output tag IDs generated by this operation.",req=true,initParam = false, hidden=true),
           ParamStr(id = "tagPrefix",synon=Seq(),ty="String",valueString="s",desc="",req=true,initParam = false, hidden=true)//,
     )
     
     
     val MAPFUNCTIONS_GROUPS = Seq("General-Purpose Tools",
                                   "Formatting/Conversion",
                                   "Variant Formatting/Conversion",
                                   "File/Database Annotation",
                                   "Genotype Processing",
                                   "General-Purpose Tools",
                                   "Concordance Caller",
                                   "Filtering",
                                   "Genomic Locus Annotation",
                                   "Data/Table Extraction",
                                   "File Formatting/Conversion",
                                   "Misc","",
                                   "DEPRECATED")

     
     val MAP_FUNCTIONS_SEQ  : Seq[(String,ParamStrSet)] = Seq(
       ParamStrSet("tagVariantsExpression" , desc = "This function takes a variant expression and creates a new INFO field that is 1 if and only if that expression returns TRUE, and 0 otherwise.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "expr",synon=Seq(),ty="String",valueString="expr",desc="The variant expression, which is a true/false expression using the variant expression syntax.",req=true),
           ParamStr(id = "desc",synon=Seq(),ty="String",valueString="...",desc="A description, to go in the info field description.",req=false,defaultValue = Some("No desc provided"))
         )), category = "DEPRECATED", hidden = true, deprecated = true
       ),
       ParamStrSet("tagVariantsFunction" ,  desc = "This is a set of functions that all take one or more input parameters and outputs one new INFO field.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "func",synon=Seq(),ty="String",valueString="func",desc="",req=true),
           ParamStr(id = "desc",synon=Seq(),ty="String",valueString="",desc="",req=false,defaultValue = Some("No desc provided")),
           ParamStr(id = "digits",synon=Seq(),ty="Integer",valueString="x",desc="",req=false, hidden=true),
           ParamStr(id = "params",synon=Seq(),ty="String",valueString="p1,p2,...",desc="",req=false)
         )), category = "DEPRECATED", hidden = true, deprecated = true
       ),
       //TAGTITLE:bufferLen:filedesc:bedfile.bed,TAGTITLE2:bufferLen:filedesc2:bedfile2.bed.gz,...
       //       //  class AddFunctionTag(func : String, newTag : String, paramTags : Seq[String], digits : Option[Int] = None, desc : Option[String] = None ) extends internalUtils.VcfTool.SVcfWalker { 
       ParamStrSet("addInfo" ,  desc = "This is a set of functions that all take one or more input parameters and outputs one new INFO field. "+
                                          "The syntax is: --fcn \"addInfo|newTagName|fcn(param1,param2,...)\". Optionally you can add \"|desc=tag description\". "+
                                          "There are numerous addInfo functions. For more information, go to the section on addInfo Functions below, or use the help command: "+
                                          "varmyknife help addInfo",
           synon = Seq("addInfoTag"),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "func",synon=Seq(),ty="String",valueString="func",desc="",req=true,initParam = true),
           ParamStr(id = "desc",synon=Seq(),ty="String",valueString="",desc="The description in the header line for the new INFO field.",req=false,defaultValue = Some("No desc provided")),
           //ParamStr(id = "digits",synon=Seq(),ty="Integer",valueString="x",desc="For floating point values, the number of digits to include after the decimal",req=false),
           ParamStr(id = "params",synon=Seq(),ty="String",valueString="p1,p2,...",desc="Input parameters.",req=false,hidden=true)
         )), category = "General-Purpose Tools",
         exampleCode = Seq[Seq[String]](
           Seq[String](
             "Make a new INFO field which is the maximum from several allele frequencies (which are already in the file) "+
             "Then make a 0/1 INFO field that is 1 if the max AF is less than 0.01. "+
             "Note the CONST:0 term, which allows you to include constant values in these functions. "+
             "In this case it makes it so that if the AF is missing in all three populations, the maxAF "+
             "will be 0 rather than missing.\n",
             "   varmyknife walkVcf \\\n"+
             "          --fcn \"addInfo|maxAF|MAX(CEU_AF,AFR_AF,JPT_AF,CONST:0)|\\\n"+
             "                          desc=The max allele frequency from CEU_AF, AFR_AF, or JPT_AF (or zero if all are missing).\"\\\n"+
             "          --fcn \"addInfo|isRare|EXPR(INFO.lt:maxAF:0.01)|\\\n"+
             "                          desc=Indicates whether the variant maxAF is less than 0.01.\"\\\n"+
             "          infile.vcf.gz outfile.vcf.gz\n"),
           Seq[String](
             "   varmyknife walkVcf \\\n"+
             "          --fcn \"addInfo|CarryCt|SUM(hetCount,homAltCount)|\\\n"+
             "                          desc=The sum of the info tags: hetCount and homAltCount.\"\\\n"+
             "          infile.vcf.gz outfile.vcf.gz\n")
         )
       ),
       ParamStrSet("tally" ,  desc = "This is a set of functions that takes various counts and totals across the whole VCF.", 
           synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "func",synon=Seq(),ty="String",valueString="func",desc="",req=true,initParam = true),
           ParamStr(id = "params",synon=Seq(),ty="String",valueString="p1,p2,...",desc="Input parameters.",req=false,hidden=true)
         )), category = "Data/Table Extraction"
       ),
       
       ParamStrSet("tagBedFile" ,  desc = "This function takes a BED file (which can be gzipped if desired) and creates a new INFO field based on whether the variant locus overlaps with a "+
                                          "genomic region in the BED file. The new field can be either an integer that is equal to 1 if there is overlap and 0 otherwise (which is the default behavior) "+
                                          "Or, alternatively, it can copy in the title field from the bed file. NOTE: this function only uses the first 3 to 5 fields of the BED file, it does not "+
                                          "implement the optional fields 10-12 which can specify intron/exon blocks.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "file",synon=Seq(),ty="String",valueString="mybed.bed.gz",desc="",req=true),
           ParamStr(id = "desc",synon=Seq(),ty="String",valueString="",desc="The description for the new INFO line.",req=false,defaultValue = Some("No desc provided")),
           ParamStr(id = "buffer",synon=Seq(),ty="Integer",valueString="x",desc="The additional buffer to add around each BED element.",req=false, defaultValue=Some("0")),
           ParamStr(id = "style",synon=Seq(),ty="String",valueString="Either +, -, or LABEL",desc="This determines the type of INFO tag. For +, the new tag will be a dichotomous 0/1 numeric variable that will equal 1 if and only if the variant intersects with one or more BED lines (including buffer, noted above). For - the opposite is true. For LABEL, the new tag will be a String variable with the title of the element(s) that intersect with the variant, comma delimited. Note that for LABEL style the BED file must have a 4th column.",req=false,defaultValue=Some("+"))
         )), category = "File/Database Annotation",
       ),
       ParamStrSet("convertSampleNames" ,  desc = "This function converts the sample IDs of the VCF file according to a decoder file that you supply. "+
                                                  "Your decoder should be a tab-delimited text file with at least 2 columns. One column should specify the FROM sample names "+
                                                  "as they currently appear in the VCF, and one should specify the new sample names you want them converted TO. "+
                                                  "You must specify which of these columns is which using either the columnNames or columnIdx parameters. "+
                                                  ""+
                                                  ""+
                                                  ""+
                                                  "", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "file",synon=Seq(),ty="String",valueString="myChromDecoder.txt",desc="A tab delimited file with the from/to chromosome names.",req=true),
           ParamStr(id = "columnNames",synon=Seq(),ty="String",valueString="fromCol,toCol",desc="The column titles for the old chrom names and the new chrom names, in that order. If this parameter is used, the decoder file must have a title line.",req=false),
           ParamStr(id = "columnIdx",synon=Seq(),ty="Integer",valueString="fromColNum,toColNum",desc="The column number of the current chromosome names then the new chromosome names, in that order. Column indices start counting from 0. If you use this parameter to set the columns, and if the file has a title line, then you should use skipFirstRow or else it will be read in as if it were a chromosome.",req=false),
           ParamStr(id = "skipFirstRow",synon=Seq(),ty="Flag",valueString="",desc="If this parameter is set, then this tool will skip the first line on the decoder file. This is useful if you are specifying the columns using column numbers but the file also has a title line.",req=false)
         )), category = "File Formatting/Conversion"
       ),
       ParamStrSet("convertChromNames" ,  desc = "This function takes a file and translates chromosome names into a different format. "+
                                                 "This is most often used to convert between the chr1,chr2,... "+
                                                  "format and the 1,2,... format.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "file",synon=Seq(),ty="String",valueString="myChromDecoder.txt",desc="A tab delimited file with the from/to chromosome names.",req=true),
           ParamStr(id = "columnNames",synon=Seq(),ty="String",valueString="fromCol,toCol",desc="The column titles for the old chrom names and the new chrom names, "+
                                                  "in that order. If this parameter is used, the decoder file must have a title line.",req=false),
           ParamStr(id = "columnIdx",synon=Seq(),ty="Integer",valueString="fromColNum,toColNum",desc="The column number of the current chromosome names "+
                                                  "then the new chromosome names, in that order. Column indices start counting from 0. If you use this parameter to set the columns, and if the file has a title line, then you should use skipFirstRow or else it will be read in as if it were a chromosome.",req=false),
           ParamStr(id = "skipFirstRow",synon=Seq(),ty="Flag",valueString="",desc="If this parameter is set, then this tool will skip "+
                                                  "the first line on the decoder file. This is useful if you are specifying the columns using column numbers but the file also has a title line.",req=false)
         )), category = "File Formatting/Conversion"
       ),
       ParamStrSet("sampleReorder" ,  desc = "This function allows you to reorder the sample columns in your VCF. Set ONE of the parameters below to specify the desired ordering.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "sampleOrdering",synon=Seq(),ty="String",valueString="samp1,samp2,...",desc="A simple list of all the samples, in the desired order.",req=false),
           ParamStr(id = "sampleOrderingFile",synon=Seq(),ty="String",valueString="orderingFile.txt",desc="A file containing one sampleID per line. "+
                                                  "The samples will be reordered to match the order found in the file.",req=true),
           ParamStr(id = "alphabetical",synon=Seq(),ty="Flag",valueString="",desc="If this flag is set, then the samples will be reordered alphabetically.",req=false)
         )), category = "File Formatting/Conversion"
       ),
       /*
        * 
        *     } else if(mapType == "sampleReorder"){
               val sampleOrd = (params.get("sampleOrdering") match {
                 case Some(s) => Some(s);
                 case None => params.get("sampleOrderingFile")
               }).map{ s => s.split(",").toList }.getOrElse(List[String]());
               Some( new ReorderSamples(sampleOrdering = sampleOrd, sort = params.isSet("alphabetical")) )
        * 
       */
       
       
       //unPhaseAndSortGenotypes
       ParamStrSet("unPhaseAndSortGenotypes" ,  desc = "This function removes phasing and sorts genotypes (so that heterozygotes are always listed as 0/1 and never 1/0).", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "inputGT",synon=Seq(),ty="String",valueString="GT",desc="The input/output genotype FORMAT field.",req=false),
           COMMON_PARAMS("groupFile"),COMMON_PARAMS("superGroupList")
         )), category = "Genotype Processing"
       ),
       
       ParamStrSet("genotypeFilter" ,  desc = "This function filters a genotype field based on a given genotype expression. The new filtered genotype can replace the GT field or can be set to a different field, so multiple filtering strategies can be included in a single VCF.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "expr",synon=Seq(),ty="String",valueString="expr",desc="A Genotype Expression, using the genotype expression syntax.",req=true),
           ParamStr(id = "desc",synon=Seq(),ty="String",valueString="",desc="A description, to go in the new FORMAT fields.",req=false),
           ParamStr(id = "filterTag",synon=Seq(),ty="String",valueString="tagID",desc="The name of a new FORMAT field, which will be a flag equal to 1 if and only if the genotype passes the filter.",req=false),
           ParamStr(id = "outputGT",synon=Seq(),ty="String",valueString="filtered_GT",desc="The output genotype FORMAT field. If this is the same as the "+
                                                  "input genotype field then the genotype field will be overwritten.",req=false),
           ParamStr(id = "inputGT",synon=Seq(),ty="String",valueString="GT",desc="The input genotype FORMAT field.",req=false),
           ParamStr(id = "inputGtNewName",synon=Seq(),ty="",valueString="prefilt_GT",desc="If this parameter is set, the input genotype field will be copied "+
                                                  "to a new tag with this name before filtering. This can be useful if overwriting the input genotype field.",req=false),
           COMMON_PARAMS("groupFile"),COMMON_PARAMS("superGroupList")
         )), category = "Genotype Processing"
       ),
       ParamStrSet("sampleCounts" ,  desc = "This function generates counts and frequencies for alt alleles, alt genotypes, missing genotypes, "+
                                                  "ref genotypes, and so on. Note that there are several calc- flags. If none of these are included, then this function does nothing.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           COMMON_PARAMS("groupFile"),COMMON_PARAMS("superGroupList"),
           ParamStr(id = "inputGT",synon=Seq(),ty="String",valueString="GT",desc="The input genotype FORMAT field.",req=false),
           ParamStr(id = "noCountsCalc",synon=Seq(),ty="Flag",valueString="",desc="",req=false),
           ParamStr(id = "noFreqCalc",synon=Seq(),ty="Flag",valueString="",desc="",req=false),
           ParamStr(id = "noMissCalc",synon=Seq(),ty="Flag",valueString="",desc="",req=false),
           ParamStr(id = "noAlleCalc",synon=Seq(),ty="Flag",valueString="",desc="",req=false),
           ParamStr(id = "noHetHomCalc",synon=Seq(),ty="Flag",valueString="",desc="",req=false),
           ParamStr(id = "noMultiHetCalc",synon=Seq(),ty="Flag",valueString="",desc="",req=false)
         )), category = "General-Purpose Tools"
       ),
       ParamStrSet("sampleLists" ,  desc = "This function generates sample list fields which contain comma-delimited lists of samples that are het or hom-alt.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "inputGT",synon=Seq(),ty="String",valueString="GT",desc="The input genotype FORMAT field.",req=false),
           ParamStr(id = "samplePrintLimit",synon=Seq(),ty="String",valueString="",desc="",req=false),
           COMMON_PARAMS("groupFile"),COMMON_PARAMS("superGroupList"),
           ParamStr(id = "expr",synon=Seq(),ty="String",valueString="expr",desc="The variant expression, which is a "+
                                                  "true/false expression using the variant expression syntax.",req=false,defaultValue=None)

           )), category = "General-Purpose Tools"
       ),
       ParamStrSet("depthStats" ,  desc = "This function calculates various statistics on total read depth and hetAB.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "inputGT",synon=Seq(),ty="String",valueString="GT",desc="The input genotype FORMAT field.",req=false),
           ParamStr(id = "inputAD",synon=Seq(),ty="String",valueString="",desc="",req=false),
           ParamStr(id = "inputDP",synon=Seq(),ty="String",valueString="",desc="",req=false),
           ParamStr(id = "restrictToGroup",synon=Seq(),ty="String",valueString="",desc="",req=false),
           COMMON_PARAMS("groupFile"),COMMON_PARAMS("superGroupList")
           //restrictToGroup
           )), category = "General-Purpose Tools"
       ),
       ParamStrSet("calcStats" ,  desc = "This function combines the functions sampleCounts, sampleLists, and depthStats, performing all three.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           COMMON_PARAMS("groupFile"),COMMON_PARAMS("superGroupList"),
           ParamStr(id = "inputGT",synon=Seq(),ty="String",valueString="GT",desc="The input genotype FORMAT field.",req=false),
           
           ParamStr(id = "inputAD",synon=Seq(),ty="String",valueString="",desc="",req=false),
           ParamStr(id = "inputDP",synon=Seq(),ty="",valueString="",desc="",req=false),
           
           ParamStr(id = "noCountsCalc",synon=Seq(),ty="Flag",valueString="",desc="",req=false),
           ParamStr(id = "noFreqCalc",synon=Seq(),ty="Flag",valueString="",desc="",req=false),
           ParamStr(id = "noMissCalc",synon=Seq(),ty="Flag",valueString="",desc="",req=false),
           ParamStr(id = "noAlleCalc",synon=Seq(),ty="Flag",valueString="",desc="",req=false),
           ParamStr(id = "noHetHomCalc",synon=Seq(),ty="Flag",valueString="",desc="",req=false),
           ParamStr(id = "noMultiHetCalc",synon=Seq(),ty="Flag",valueString="",desc="",req=false),
           
           ParamStr(id = "samplePrintLimit",synon=Seq(),ty="String",valueString="",desc="",req=false),

           ParamStr(id = "noDepthStats",synon=Seq(),ty="Flag",valueString="",desc="",req=false),
           ParamStr(id = "noSampleLists",synon=Seq(),ty="Flag",valueString="",desc="",req=false),
           ParamStr(id = "noSampleCounts",synon=Seq(),ty="Flag",valueString="",desc="",req=false),
           
           ParamStr(id = "expr",synon=Seq(),ty="String",valueString="expr",desc="The variant expression, "+
                                                  "which is a true/false expression using the variant expression syntax.",req=false,defaultValue=None)
         )), category = "General-Purpose Tools"
       ),
       ParamStrSet("filterTags" ,  desc = "This function can be used to remove unwanted INFO or FORMAT fields, "+
                                                  "or remove unwanted samples. This can substantially reduce file sizes.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "FORMAT.keep",synon=Seq(),ty="String",valueString="expr",desc="",req=false),
           ParamStr(id = "FORMAT.drop",synon=Seq(),ty="String",valueString="",desc="",req=false),
           ParamStr(id = "INFO.keep",synon=Seq(),ty="String",valueString="",desc="",req=false),
           ParamStr(id = "INFO.drop",synon=Seq(),ty="String",valueString="",desc="",req=false),
           ParamStr(id = "SAMPLES.keep",synon=Seq(),ty="String",valueString="",desc="",req=false),
           ParamStr(id = "SAMPLES.drop",synon=Seq(),ty="String",valueString="",desc="",req=false)
         )), category = "File Formatting/Conversion"
       ),
       
       // UNIMPLEMENTED:
       /*
        * 
        * Seq[SVcfWalker](new StdVcfConverter(thirdAlleleChar = thirdAlleleChar))
        * UNIMPLEMENTED FUNCTIONS: TODO!
        */
       ParamStrSet("keepVariants" ,  desc = "This function drops variants based on a given true/false expression.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "expr",synon=Seq(),ty="String",valueString="expr",desc="",req=false)
         )), category = "Filtering"
       ),
       ParamStrSet("extractRegion" ,  desc = "This function extracts a single region from the VCF. NOTE: the VCF MUST BE SORTED!", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "region",synon=Seq(),ty="String",valueString="chr1:1000-2000",desc="The genomic region to extract.",req=true,initParam = true),
           ParamStr(id = "windowSize",synon=Seq(),ty="Int",valueString="0",desc="The size of the window around the genomic region to extract.",req=false,initParam = true)
         )), category = "Filtering"
       ),
       ParamStrSet("snpSiftAnno" ,  desc = "This function runs a SnpSift anno command", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "cmd",synon=Seq(),ty="String",valueString="cmd",desc="A valid SnpSift command",req=false)
         )), category = "File/Database Annotation"
       ),
       ParamStrSet("snpSiftDbnsfp" ,  desc = "This function runs the SnpSift dbnsfp command", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "cmd",synon=Seq(),ty="String",valueString="cmd",desc="A valid SnpSift command",req=false)
         )), category = "File/Database Annotation"
       ),
       ParamStrSet("snpEff" ,  desc = "This function runs SnpEff by calling the SnpEff library internally. It uses SnpEff version 4.3t.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "cmd",synon=Seq(),ty="String",valueString="cmd",desc="A valid SnpSift command.",req=false)
         )), category = "File/Database Annotation",
         exampleCode = Seq[Seq[String]](
             Seq[String](
             "varmyknife walkVcf \n"+
             "          --fcn \"snpEff|mySnpEffRun_1|cmd=GRCh37.75 -noout -c snpEff.config -v -noStats -lof -motif -nextprot\" \n"+
             "          infile.vcf.gz outfile.vcf.gz\n")
         )
       ),
       ParamStrSet("snpEffExtract" ,  desc = "", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "annTag",synon=Seq(),ty="String",valueString="tag",desc="A valid ANN formatted field, usually generated by SNPeff.",req=false,defaultValue=Some("ANN")),
              ParamStr(id = "bioTypeKeepList",synon=Seq(),ty="String",valueString="t1,t2,...",desc="A comma delimited list of the transcript biotypes that you want to keep. All other biotypes will be ignored.",req=false),
              ParamStr(id = "effectKeepList",synon=Seq(),ty="String",valueString="t1,t2,...",desc="A comma delimited list of the effect types that you want to keep. All other EFFECT values will be ignored.",req=false),
              ParamStr(id = "warningDropList",synon=Seq(),ty="String",valueString="t1,t2,...",desc="A comma delimited list of warnings. Any entries that include a listed warning will be ignored.",req=false),
              //ParamStr(id = "keepIdx",synon=Seq(),ty="String",valueString="t1,t2,...",desc="",req=false),
              ParamStr(id = "geneListName",synon=Seq(),ty="String",valueString="myGeneListName",desc="",req=false),
              ParamStr(id = "geneList",synon=Seq(),ty="String",valueString="t1,t2,...",desc="",req=false),
              
              ParamStr(id = "severityList",synon=Seq(),ty="String",valueString="...",desc="Must be a list of severity levels, listed as some combination of effectseverity types delimited with slashes. "+
                                 "Legal types are: HIGH, MODERATE, LOW, and MODIFIER, which are standard SnpEFF effect types, and also: "+
                                 "NS (HIGH and MODERATE), NonNS (LOW and MODIFIER), and ANY (any type).",
                                 req=false, defaultValue = Some("HIGH/MODERATE/LOW")),
              ParamStr(id = "extractFields",synon=Seq(),ty="String",valueString="...",desc="This is a complex multi-part field that allows flexible extraction of "+
                    "information from SnpEff ANN tags. This field must be in the colon-delimited format tagInfix:ANN_idx:description:severityList[:noCollapse]. "+
                    "severityList must be in the same format as the severityList parameter above, but can override the default if desired. "+
                    "ANN_idx must be a slash-delimited list of field indices counting from zero in the ANN tag. "+
                    "The standard ANN field indices are: "+ Seq("allele","effect","impact","geneName","geneID","txType","txID","txBiotype","rank","HGVS.c","HGVS.p","cDNAposition","cdsPosition","proteinPosition","distToFeature","warnings","errors").zipWithIndex.map{ case (a,i) => i+":"+a  }.mkString(",")+" "+
                    "If multiple fields are selected then the output fields will have the format first:second:third:etc. "+
                    "For example, to create two new fields containing a list of all genes for which the current variant has HIGH and MODERATE impact respectively, use the format: "+
                    "myNewField:4:my description:HIGH/MODERATE. " +
                    "This will generate two new fields: myNewField_HIGH and myNewField_MODERATE. Note that if this function as a whole has a mapID set, then "+
                    "both field names will be prefixed by that overall ID."
                    ,req=false),
              //(tagPrefix+svexOutTag+"_",svexIdx,svexFullDesc,svexSevSet, noCollapse)
             ParamStr(id = "geneNameIdx",synon=Seq(),ty="String",valueString="t1,t2,...",desc="",req=false,defaultValue = Some("4") ),
             ParamStr(id = "biotypeIdx",synon=Seq(),ty="String",valueString="t1,t2,...",desc="",req=false,defaultValue = Some("7") ),
             ParamStr(id = "warnIdx",synon=Seq(),ty="String",valueString="t1,t2,...",desc="",req=false,defaultValue = Some("15") )
              //TODO: figure out how to include snpEffVarExtracts!
         )), category = "File/Database Annotation"
       ),
       /*
                           new SnpEffInfoExtract(tagID = params("annTag"),
                                         tagPrefix = params("tagPrefix"),
                                         snpEffBiotypeKeepList = params.get("bioTypeKeepList").map{ _.split(",").toList },
                                         snpEffEffectKeepList  = params.get("effectKeepList").map{ _.split(",").toList },
                                         snpEffWarningDropList = params.get("warningDropList").map{ _.split(",").toList },
                                         //snpEffKeepIdx         = params.get("keepIdx").map{ _.split(",").toList },
                                         geneListTagInfix      = params.getOrElse("geneListName","onList_"),
                                         geneList              = params.get("geneList").map{ _.split(",").toList },
                                         
                                         snpEffFields    = params.get("extractFields").map{ x => x.split(",") },
                                         severityListSet = Some(params("severityList")),
                                         
                                         snpEffGeneNameIdx   = Some(string2int(params("geneNameIdx"))),
                                         snpEffBiotypeIdx    = (string2int(params("biotypeIdx"))),
                                         snpEffWarnIdx       = (string2int(params("warnIdx")))
        */
       
       
       ParamStrSet("snpEffExtractField" ,  desc = "", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "tagPrefix",synon=Seq(),ty="String",valueString="tag",desc="",req=true),
              ParamStr(id = "outputTagPrefix",synon=Seq(),ty="String",valueString="t1,t2,...",desc="",req=false),
              ParamStr(id = "columns",synon=Seq(),ty="String",valueString="t1,t2,...",desc="",req=false),
              ParamStr(id = "desc",synon=Seq(),ty="String",valueString="...",desc="",req=false),
              ParamStr(id = "collapseUniques",synon=Seq(),ty="Flag",valueString="t1,t2,...",desc="",req=false),
              ParamStr(id = "tagSet",synon=Seq(),ty="String",valueString="HIGH,MODERATE,LOW,NS,ANY",desc="",req=false)
         )), category = "File/Database Annotation", hidden = true
       ),
       ParamStrSet("homopolymerRunStats" ,  desc = "This tool adds several new INFO tags that indicate whether the variant is near a homopolymer run, and if so, whether it extends or truncates that run.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "runSize",synon=Seq(),ty="String",valueString="k",desc="The number of repeated bases required to count as a homopolymer run",req=true),
              COMMON_PARAMS("genomeFA")
         )), category = "Genomic Locus Annotation"
       ),
       ParamStrSet("addContextBases" ,  desc = "This function adds several new INFO fields which list the base pairs flanking the variant.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "windowSize",synon=Seq(),ty="String",valueString="k",desc="The number of bases to include in the context window",req=true),
              COMMON_PARAMS("genomeFA")
         )), category = "Genomic Locus Annotation"
       ),
       ParamStrSet("gcContext" ,  desc = "This function calculates the fraction of bases within k bases from the variant locus that are G or C. "+
                                         "This can be useful to identify high-GC areas where variant calling and sequencing may be less accurate.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "windowSize",synon=Seq(),ty="String",valueString="k",desc="The number of bases to include in the context window for determining local gc content.",req=true),
              ParamStr(id = "digits",synon=Seq(),ty="String",valueString="int",desc="Number of digits to round to.",req=false, defaultValue = Some("4")),
              COMMON_PARAMS("genomeFA")
         )), category = "Genomic Locus Annotation"
       ),
       ParamStrSet("addVariantIdx" ,  desc = "This function adds a new INFO column with a unique numeric value for each line. Optionally, you can add "+
                                             "a prefix to each ID.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "prefix",synon=Seq(),ty="String",valueString="prefix",desc="Prefix to prepend to the index field.",req=false)
         )),category = "General-Purpose Tools"
       ),//dropNullVariants
       ParamStrSet("addVariantPosInfo" ,  desc = "This function adds a new INFO field in the form: CHROM:START:REF>ALT. This can be useful for "+
                                                 "checking the effects of functions that alter the variant columns. "+
                                                 "For example, you can run this function before and after leftAlignAndTrim to see how "+
                                                 "a variant changes.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )),category = "General-Purpose Tools"
       ),//dropNullVariants
       ParamStrSet("dropNullVariants" ,  desc = "This function drops all lines with no alt alleles ('.' in the ALT column), or lines where the ALT allele is identical to the REF. "+
                                                "Note: you must split multiallelics first. See the 'splitMultiallelics' function.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )),category = "Filtering"
       ),
       ParamStrSet("dropSpanIndels" ,  desc = "This function drops Spanning indel lines ('*' alleles). Note: you must split multiallelics first!", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )),category = "Filtering"
       ),
       
       ParamStrSet("checkReferenceMatch" ,  desc = "This function compares the REF column to the genomic reference and makes sure that they actually match. "+
                                                   "If mismatches are found, a warning will be thrown. In addition, a new INFO field will be added to the VCF that will be a "+
                                                   "simple integer field that will equal 1 if and only if the REF matches the reference, and 0 otherwise.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              COMMON_PARAMS("genomeFA")
         )),category = "Genomic Locus Annotation"
       ),
       ParamStrSet("sanitize" ,  desc = "This function strips out additional optional fields in the INFO lines which are technically valid according to the VCF specification, but that will be rejected by certain applications including GATK.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              
         )),category = "File Formatting/Conversion"
       ),
       ParamStrSet("calcBurdenCounts" ,  desc = "This function generates the .", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "geneTag",synon=Seq(),ty="String",valueString="k",desc="This is the INFO tag that indicates the geneID. It can be a comma-delimited list.",req=true),
              //
              ParamStr(id = "snpEffAnnField",synon=Seq(),ty="String",valueString="k",desc="NOT IMPLEMENTED",req=false, hidden=true),
              ParamStr(id = "snpEffGeneField",synon=Seq(),ty="String",valueString="k",desc="NOT IMPLEMENTED",req=false, hidden=true),
              ParamStr(id = "snpEffVariantTypes",synon=Seq(),ty="String",valueString="k",desc="NOT IMPLEMENTED",req=false, hidden=true),
              //
              ParamStr(id = "expr",synon=Seq(),ty="String",valueString="k",desc="This is a true/false variant expression. Variants will only be counted towards a burden test if they pass this expression. This can be used to generate several burden count tables with different filtering strategies in a single run.",req=false),
              ParamStr(id = "sampleSet",synon=Seq(),ty="String",valueString="k",desc="This is a list of samples to include. Samples not on this list will be ignored.",req=false),
              ParamStr(id = "group",synon=Seq(),ty="String",valueString="k",desc="This is a sample group to include. Samples that are not in this sample group will be ignored. Note that this requires the groupFile variable to be set.",req=false),
              ParamStr(id = "inputGT",synon=Seq(),ty="String",valueString="k",desc="This is the FORMAT column to use as the genotype column.",req=false),
              
           COMMON_PARAMS("groupFile"),COMMON_PARAMS("superGroupList"),
           
           ParamStr(id = "countFileID",synon=Seq(),ty="String",valueString="k",desc="If multiple output count files are desired, you can specify which functions output to which count file using this parameter. Note that each file must be created using a --burdenCountsFile parameter, with the form fileID:/path/to/file.txt",req=false)

         )),category = "Data/Table Extraction"
       ),
       ParamStrSet("calcBurdenCountsByGroups" ,  desc = "", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "geneTag",synon=Seq(),ty="String",valueString="k",desc="This is the INFO tag that indicates the geneID. It can be a comma-delimited list.",req=true),
              ParamStr(id = "groups",synon=Seq(),ty="String",valueString="k",desc="This is a comma delimited list of sample groups, taken from the groupFile.",req=true),

              ParamStr(id = "snpEffAnnField",synon=Seq(),ty="String",valueString="k",desc="NOT IMPLEMENTED",req=false, hidden=true),
              ParamStr(id = "snpEffGeneField",synon=Seq(),ty="String",valueString="k",desc="NOT IMPLEMENTED",req=false, hidden=true),
              ParamStr(id = "snpEffVariantTypes",synon=Seq(),ty="String",valueString="k",desc="NOT IMPLEMENTED",req=false, hidden=true),
              //
              ParamStr(id = "expr",synon=Seq(),ty="String",valueString="k",desc="This is a true/false variant expression. Variants will only be counted towards a burden test if they pass this expression. This can be used to generate several burden count tables with different filtering strategies in a single run.",req=false),
              ParamStr(id = "sampleSet",synon=Seq(),ty="String",valueString="k",desc="This is a list of samples to include. Samples not on this list will be ignored.",req=false),
              ParamStr(id = "inputGT",synon=Seq(),ty="String",valueString="k",desc="This is the FORMAT column to use as the genotype column.",req=false),
              
           COMMON_PARAMS("groupFile"),COMMON_PARAMS("superGroupList"),
           
           ParamStr(id = "countFileID",synon=Seq(),ty="String",valueString="k",desc="If multiple output count files are desired, you can specify which functions output to which count file using this parameter. Note that each file must be created using a --burdenCountsFile parameter, with the form fileID:/path/to/file.txt",req=false)

         )),category = "Data/Table Extraction"
       ),
       
       ParamStrSet("calcBurdenMatrix" ,  desc = "....", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "geneTag",synon=Seq(),ty="String",valueString="k",desc="",req=true),
              ParamStr(id = "expr",synon=Seq(),ty="String",valueString="k",desc="",req=false),
              ParamStr(id = "sampleSet",synon=Seq(),ty="String",valueString="k",desc="",req=false),
              ParamStr(id = "group",synon=Seq(),ty="String",valueString="k",desc="",req=false),
              ParamStr(id = "inputGT",synon=Seq(),ty="String",valueString="k",desc="",req=false),
              
              ParamStr(id = "geneList",synon=Seq(),ty="String",valueString="k",desc="",req=false),
              ParamStr(id = "geneListFile",synon=Seq(),ty="String",valueString="k",desc="",req=false),
              ParamStr(id = "printFullGeneList",synon=Seq(),ty="flag",valueString="k",desc="",req=false),

              ParamStr(id = "pathwayList",synon=Seq(),ty="String",valueString="A:a,b,c,d;B:c,d,e,f;...",desc="",req=false),
              
             COMMON_PARAMS("groupFile"),COMMON_PARAMS("superGroupList"),
           
             ParamStr(id = "outfile",synon=Seq(),ty="String",valueString="k",desc="The output matrix file path.",req=true)

         )),category = "Data/Table Extraction"
       ),
       
       ParamStrSet("concordanceCaller" ,  desc = "....", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "callerNames",synon=Seq(),ty="String",valueString="k",
                                               desc="Comma delimited list of caller IDs, used in the callerSet INFO fields and the names of the output GT fields. "+
                                                    "By default, callers will simply be named C1,C2,..."+
                                                    "",req=false),
              ParamStr(id = "priority",synon=Seq(),ty="String",valueString="k",
                                               desc="Comma delimited list of caller IDs. "+
                                                    "The list of caller IDs in order of descending priority."+
                                                    "",req=false),
              ParamStr(id = "gtDecisionMethod",synon=Seq(),ty="String",valueString="k",
                                               desc="The merge rule for calculating ensemble-merged GT and AD tags. Valid options are priority, prioritySkipMissing, and majority_priorityOnTies. Default is simple priority."+
                                                    ""+
                                                    "",req=false),
                                                    //gtDecisionMethod
              ParamStr(id = "ignoreSampleIds",synon=Seq(),ty="flag",valueString="k",desc="If this flag is set, then sample IDs will be ignored and each VCF will be assumed to have the "+
                                                                                         "exact same samples in the exact same order. Use at your own risk.",req=false),
              ParamStr(id = "ignoreSampleOrder",synon=Seq(),ty="flag",valueString="k",desc="If this flag is set, then the sample IDs will be used to match up the "+
                                                                                           "different VCFs, and the samples may be in different orders in the different files.",req=false),
              //TODO:
              ParamStr(id = "mergeGenotypeField_ADstyle",synon=Seq(),ty="String",valueString="k",
                                               desc=""+
                                                    ""+
                                                    "",req=false,hidden=true),
              ParamStr(id = "mergeGenotypeField_simple",synon=Seq(),ty="String",valueString="k",
                                               desc=""+
                                                    ""+
                                                    "",req=false,hidden=true),
              ParamStr(id = "mergeGenotypeField_GTstyle",synon=Seq(),ty="String",valueString="k",
                                               desc=""+
                                                    ""+
                                                    "",req=false,hidden=true)

                                                    
                                                    
                                                    
         )),category = "Concordance Caller"
       ),
       /*
        * UNTESTED:
        */
       
       ParamStrSet("fixFirstBaseMismatch" ,  desc = "This utility will extend indels in which the first base is not a matching base. Certain variant processing tools "+
                                                    "may use blanks to mark indels or may not begin combination insertion-deletion variants with a matching base "+
                                                    "(this latter case is technically legal VCF, but some tools may throw errors). "+
                                                    ""+
                                                    "", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "windowSize",synon=Seq(),ty="Int",valueString="k",desc="Sets the size of the sliding window used. Problems may occur if you have variants longer than this window size. Default is 200bp.",req=false),
              COMMON_PARAMS("genomeFA")
         )), category = "Variant Formatting/Conversion"
       ),
      ParamStrSet("leftAlignAndTrim" ,  desc =      "This utility performs the exact same operations as GATK leftAlignAndTrim. It trims excess bases and shifts ambiguously-positioned indels to their leftmost possible position. "+
                                                    "This can assist in ensuring that variants are consistantly represented which is critical in matching indels between files. "+
                                                    "IMPORTANT: if there are multiallelic variants then they MUST be split apart before this step. You can use the splitMultiAllelics function to do this."+
                                                    ""+
                                                    "", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "windowSize",synon=Seq(),ty="Int",valueString="k",desc="Sets the size of the sliding window used. Problems may occur if you have variants longer than this window size. Default is 200bp.",req=false),
              COMMON_PARAMS("genomeFA")
         )), category = "Variant Formatting/Conversion"
       ),
      ParamStrSet("fixSwappedRefAlt" ,  desc = "This utility searches for cases where the REF and ALT bases are swapped.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              COMMON_PARAMS("genomeFA")
         )), category = "Variant Formatting/Conversion"
       ), 
      ParamStrSet("splitMultiAllelics" ,  desc = "This utility takes any multiallelic variables and splits them apart so that each line contains only one ALT allele. "+
                                                 "There are two options for how this will be carried out. The default creates several new FORMAT fields. "+
                                                 "TODO explain more! "+
                                                 ""+
                                                 "...Thus after the split the "+
                                                 "multiallelics will have an ALT field of the form A,* and the "+
                                                 "GT field and AD field will use this coding. Thus if a sample has one of the "+
                                                 "other alt alleles then ", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "useStarAlle",synon=Seq(),ty="Flag",valueString="",desc="If this flag is used, the asterisk allele will be used "+
                                                                                    "as a placeholder for all other alleles. See the explanation above."+
                                                                                    "",req=false),
              ParamStr(id = "treatOtherAsRef",synon=Seq(),ty="Flag",valueString="",desc=" "+
                                                                                    ""+
                                                                                    "",req=false),                                                                  

         )), category = "Variant Formatting/Conversion"
       ),
      ParamStrSet("rmDup" ,  desc = "This utility detects identical variant lines and deletes any excess beyond the first. NOTE: VCF FILE MUST BE SORTED!", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              
         )), category = "Filtering"
       ),
      ParamStrSet("markDup" ,  desc = "This map function will detect duplicate variant lines and add two new INFO fields: "+
                                                    "mapID_CT and mapID_IDX. The CT will indicate how many duplicates were found "+
                                                    "matching the current variant, and the IDX will number each duplicate with a unique identifier, counting from 0. All nonduplicates will "+
                                                    "be marked with CT=1 and IDX=0. VCF FILE MUST BE SORTED!", 
                                                    synon = Seq("mkDup"),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              
         )), category = "General-Purpose Tools"
       ),
       /*
        *             duplicateTag.toSeq.map{ dt => {
              new DuplicateStats(dt)
            }}, category = "Formatting/Conversion"
        */
       
      ParamStrSet("fixDotAltIndels" ,  desc = "...", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              COMMON_PARAMS("genomeFA")
         )), category = "Variant Formatting/Conversion"
       ),
      ParamStrSet("getLocusDepthFromWig" ,  desc = "This utility takes a .wig file (aka a wiggle file) and annotates each variant with the depth indicated in the wiggle file for the variant site.", 
           (DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "wigfile",synon=Seq(),ty="String",valueString="depthfile.wig.gz",desc="The input wiggle file.",req=false),
              ParamStr(id = "desc",synon=Seq(),ty="String",valueString="...",desc="The description for the new INFO field, to be included in the INFO line.",req=false)
         )), category = "File/Database Annotation"
       ),
       /*
        * 
        * Seq[SVcfWalker](new StdVcfConverter(thirdAlleleChar = thirdAlleleChar))
        * UNIMPLEMENTED FUNCTIONS: TODO!
        */
       ParamStrSet("convertToStdVcf" ,  desc = "Certain utilities (eg GATK) do not allow certain optional features of the VCFv4.2 format standard "+
                                                "(For example: additional tag-pairs in the INFO or FORMAT header lines). This function strips out this additional metadata."+
                                                "",
                  synon = Seq("convertToStandardVcf"),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )), category = "File Formatting/Conversion"
       ),
       
       ParamStrSet("addAltSequence" ,  desc = "",
                  synon = Seq("addAltSeq"),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "windowSize",synon=Seq(),ty="String",valueString="k",desc="The number of flanking bases to include on each side of the alt sequence.",req=false,defaultValue=Some("10")),
              COMMON_PARAMS("genomeFA")
         )), category = "Variant Formatting/Conversion"
       ),
       ParamStrSet("dropGenotypeData" ,  desc = "This utility drops the entire genotype table, including all columns from the FORMAT column on.",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )), category = "File Formatting/Conversion"
       ),
       ParamStrSet("addDummyGenotypeColumn" ,  desc = "This utility adds a new genotype column and FORMAT column, containing a simple GT field that is always 0/1. Some utilities will refuse to process files without genotype data or will ignore VCF lines with no alt genotypes.",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )), category = "File Formatting/Conversion"
       ),
       ParamStrSet("dropSymbolicAlleles" ,  desc = "This utility strips all symbolic alleles. See the VCF v4.2 specification for more information on what those are and what they are used for. Many older tools will return errors if fed symbolic alleles.",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )), category = "Filtering"
       ), //dropVariantsWithNs
       ParamStrSet("dropVariantsWithNs" ,  desc = "This utility drops variants if they contain Ns in either the REF or ALT columns.",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )), category = "Filtering"
       ),
       
       ParamStrSet("copyColumnToInfo" ,  desc = "This utility copies the contents of one of the VCF columns to a new INFO field.",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
               ParamStr(id = "columnID",synon=Seq(),ty="String",valueString="FILTER|ID|REF|ALT|etc",desc="",req=true)
         )), category = "File Formatting/Conversion"
       ),
       //,
      //ParamStrSet("dropVariantsWithNs" ,  desc = "Removes all variants with N's in the REF or ALT sequences. Some callers will produce variants like this, and some tools will crash if given such variants.", 
      //     (DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
      //   ))
      // )

       
       //TODO:
       //convertROAOtoAD
       
       
       
       
       
       //add more params to the ParamStrSet:
       //    hidden, deprecated, category, priority
       
       //Add more fcn:
       
       //makeFirstBaseMatch
       //fixSwappedRefAlt
       //leftAlignAndTrim
       //splitMultiAllelics
       //fixDotAltIndels
       //rmDup
       //ConcordanceCaller?
       //dropVariantsWithNs, 
       //wiggles
       
       //copyColumnToINFO, copyINFOtoGENO, copyGENOtoINFO
       //DONE - unPhaseAndSortGenotypes 

       
     ).map{ pss => {
       (pss.mapType,pss)
     }}
     
     val MAP_FUNCTIONS  : Map[String,ParamStrSet] = MAP_FUNCTIONS_SEQ.toMap
     
     val MAP_ID_MAP : Map[String,String] = MAP_FUNCTIONS.flatMap{ case (mapID,pss) => {
       pss.nameSet.map{ nn => {
         (nn,mapID)
       }}
     }}.toMap;
     
     /*
} else if(mapType == "homopolymerRunStats"){
               Some(HomopolymerRunStats(tagPrefix=params("tagPrefix"),genomeFa=params("genomeFA"), lenThreshold = params("runSize").toInt))
             } else if(mapType == "addContextBases"){
               Some(AddContextBases(tagPrefix=params("tagPrefix"),genomeFa=params("genomeFA"), len = params("windowSize").toInt))
             } else if(mapType == "gcContext"){
               Some(localGcInfoWalker(tagPrefix=params("tagPrefix"),windows=params("windowSize").split(",").toSeq.map{_.toInt},genomeFa=params("genomeFA"), roundDigits = params.get("digits").map{_.toInt}))
             
              Some(new calcBurdenCountsWalker(tagID=params("mapID"),
                  geneTag=params("geneTag"),
                  filterExpressionString=params.getOrElse("expr","TRUE"),
                  sampSubset=params.get("sampleSet").map{ x => x.split(",").toSet},
                  sampGroup=params.get("group"),
                  gtTag=params("inputGT"), 
                  out=burdenWriter.get, 
                  groupFile = params.get("groupFile"), 
                  groupList = None, 
                  superGroupList  = params.get("superGroupList")))



    def MAPFUNCTIONS_logicManualRaw : Seq[(Option[String],String)] = 
      Seq[(Option[String],String)](
                                  (Some("Variant Map Functions"),
                                        "Variant Map Functions are a set of tools that perform operations on a variant set "+
                                        "one variant at a time. Unlike other parameters and operations, map functions are performed in the order "+
                                        "that they appear in the command line, after all other operations have been carried out (excluding output ops)."+
                                        ""),
                                  (Some("BASIC SYNTAX:"),
                                        "--FCN functionName|ID|param1=p1|param2=p2|..."
                                  ),
                                  (Some(""),
                                        "")
                                  (None," "+
                                        " "+
                                        " "+
                                        " "
                                  )
      );
     
    def MAPFUNCTIONS_getManualString() : String = {
      indentTitle : Int = 4, indentBlock : Int = 8,
                              indentFirst:Int= 8
    }*/
   
     
   val MAPFUNCTIONS_USERMANUALBLOCKS : Seq[internalUtils.commandLineUI.UserManualBlock] = Seq[internalUtils.commandLineUI.UserManualBlock](
       internalUtils.commandLineUI.UserManualBlock(title=Some("VARIANT OPERATIONS"),
                                                   lines = Seq("","Variant Operations or Variant Map Functions are a set of sub-utilities that perform operations on a variant set "+
                                                               "one variant at a time. When more than one function is specified in a run, these functions are performed in the order "+
                                                               "that they appear in the command line, after all other operations have been carried out (excluding output ops)."+
                                                               "",
                                                               "Basic Syntax:",
                                                               "    --FCN functionName|ID|param1=p1|param2=p2|...",
                                                               "",
                                                               "functionName: one of the functions listed below.",
                                                               "ID: The ID for this particular operation run. "+
                                                               "This will be used in warning/error messages and in the "+
                                                               "header metadata. It is recommended that this ID be unique. "+
                                                               "In some functions this ID is used to determine the INFO field names.",
                                                               "param1,param2,...: Most functions take one or more parameters. Parameters are "+
                                                               "specified with the format: param=value, where param is the parameter ID listed in the "+
                                                               "documentation below."), level = 1, indentTitle = 0, indentBlock = 2, indentFirst = 2),
       internalUtils.commandLineUI.UserManualBlock(title=Some("Available Operations"),
                                                   lines = Seq(""), level = 2,indentTitle = 2, indentBlock = 2, indentFirst = 2)
   ) ++ MAP_FUNCTIONS_SEQ.filter{ case (fcnID,mf) => {
     ! mf.hidden
   }}.toSeq.sortBy{ case (fcnID,mf) => {
     MAPFUNCTIONS_GROUPS.indexOf( mf.category );
   }}.map{ case (fcnID,mf) => {
     (fcnID,mf.category,mf);
   }}.foldLeft( ("",Seq[internalUtils.commandLineUI.UserManualBlock]()) ){ case ((prevCat,soFar),(fcnID,currCat,mf)) => {
     val sf = if( soFar.length == 0 || prevCat != currCat ){
        soFar :+ internalUtils.commandLineUI.UserManualBlock(lines=Seq(),title=Some(currCat),level=5);
     } else {
       soFar
     }
      val fcnTitleLine =  internalUtils.commandLineUI.UserManualBlock(title=Some( fcnID ),subtitle = Some(mf.desc),
                                                   lines = Seq(), level = 3, indentTitle = 4, indentBlock = 12, indentFirst=4, 
                                                   mdCaret=true,mdBold=true)
      val examples = mf.exampleCode.zipWithIndex.flatMap{ case (exampleCodeSeq,idx) => {
        Seq[internalUtils.commandLineUI.UserManualBlock](
            internalUtils.commandLineUI.UserManualBlock(lines = Seq("###### Example "+(idx+1)+":"),
                mdIndentBlock = 0, mdIndentFirst = 0,
                hiddenInPlain = true)
        ) ++
        exampleCodeSeq.map{ exampleCodeString => {
            internalUtils.commandLineUI.UserManualBlock(lines = exampleCodeString.split("\n").map{x => x.trim()}.toSeq,
                mdIndentBlock = 8, mdIndentFirst = 4,
                hiddenInPlain = true)
        }} ++
        Seq[internalUtils.commandLineUI.UserManualBlock](
            internalUtils.commandLineUI.UserManualBlock(lines = Seq("###### End Example"),
                mdIndentBlock = 0, mdIndentFirst = 0,
                hiddenInPlain = true)
        )
      }}
      (currCat,sf ++ Seq(fcnTitleLine) ++ mf.pp.filter{ pp => ! pp.hidden }.map{ pp => {
        internalUtils.commandLineUI.UserManualBlock(lines = Seq(""+pp.id+": "+
                                                            pp.desc +"("+pp.ty+""+ { if(pp.req){
                                                              ", required)"
                                                            } else {
                                                              pp.defaultDesc.map{ dfd => {
                                                                ", default="+dfd+")"
                                                              }}.getOrElse(
                                                                 pp.defaultValue.map{ dfv => {
                                                                   ", default="+dfv+")"
                                                                 }}.getOrElse(")")
                                                              )
                                                            }}), indentTitle = 4, indentBlock = 12, indentFirst=8,mdCaret=true)
      }}.padTo(1,internalUtils.commandLineUI.UserManualBlock(lines = Seq("(This function takes no parameters)"), indentTitle = 4, indentBlock = 12, indentFirst=8,mdCaret=true))++
      examples)
    }}._2
   /*

     


   }}.flatMap{ case (fcnID,mf) => {
      val fcnTitleLine =  internalUtils.commandLineUI.UserManualBlock(title=Some( fcnID ),subtitle = Some(mf.desc),
                                                   lines = Seq(), level = 3, indentTitle = 4, indentBlock = 12, indentFirst=4, 
                                                   mdCaret=true,mdBold=true)
      val examples = mf.exampleCode.zipWithIndex.flatMap{ case (exampleCodeSeq,idx) => {
        Seq[internalUtils.commandLineUI.UserManualBlock](
            internalUtils.commandLineUI.UserManualBlock(lines = Seq("###### Example "+(idx+1)+":"),
                mdIndentBlock = 0, mdIndentFirst = 0,
                hiddenInPlain = true)
        ) ++
        exampleCodeSeq.map{ exampleCodeString => {
            internalUtils.commandLineUI.UserManualBlock(lines = exampleCodeString.split("\n").map{x => x.trim()}.toSeq,
                mdIndentBlock = 8, mdIndentFirst = 4,
                hiddenInPlain = true)
        }} ++
        Seq[internalUtils.commandLineUI.UserManualBlock](
            internalUtils.commandLineUI.UserManualBlock(lines = Seq("###### End Example"),
                mdIndentBlock = 0, mdIndentFirst = 0,
                hiddenInPlain = true)
        )
      }}
      Seq(fcnTitleLine) ++ mf.pp.filter{ pp => ! pp.hidden }.map{ pp => {
        internalUtils.commandLineUI.UserManualBlock(lines = Seq(""+pp.id+": "+
                                                            pp.desc +"("+pp.ty+""+ { if(pp.req){
                                                              ", required)"
                                                            } else {
                                                              pp.defaultDesc.map{ dfd => {
                                                                ", default="+dfd+")"
                                                              }}.getOrElse(
                                                                 pp.defaultValue.map{ dfv => {
                                                                   ", default="+dfv+")"
                                                                 }}.getOrElse(")")
                                                              )
                                                            }}), indentTitle = 4, indentBlock = 12, indentFirst=8,mdCaret=true)
      }}.padTo(1,internalUtils.commandLineUI.UserManualBlock(lines = Seq("(This function takes no parameters)"), indentTitle = 4, indentBlock = 12, indentFirst=8,mdCaret=true))++
      examples
   }}*/
     
   def MAPFUNCTIONS_getBlockStringManual : String = MAPFUNCTIONS_USERMANUALBLOCKS.filter{ umb => ! umb.hiddenInPlain }.map{ umb => {
     umb.getBlockString()
   }}.mkString("\n")+"\n";
   def MAPFUNCTIONS_getMarkdownStringManual : String = MAPFUNCTIONS_USERMANUALBLOCKS.map{ umb => {
     umb.getMarkdownString();
   }}.mkString("\n")+"\n";
   
      /*
       ***********************************************************************************************************************************************************************************************************************************************************************************************************
       ***********************************************************************************************************************************************************************************************************************************************************************************************************
       ***********************************************************************************************************************************************************************************************************************************************************************************************************
       ***********************************************************************************************************************************************************************************************************************************************************************************************************
       * 
       * 
       * 
       * 
       * 
       * 
       * 
       * 
       * 
       ***********************************************************************************************************************************************************************************************************************************************************************************************************
       ***********************************************************************************************************************************************************************************************************************************************************************************************************
       ***********************************************************************************************************************************************************************************************************************************************************************************************************
       ***********************************************************************************************************************************************************************************************************************************************************************************************************
       */
      
      def getSVcfMapFunction( variantMapFunction : List[String], 
                             chromList : Option[List[String]],
                             burdenWriterMap : Map[String,internalUtils.fileUtils.WriterUtil] ,
                             groupFile : Option[String],
                             superGroupList : Option[String],
                genomeFA : Option[String],
                calcStatGtTag : String

      ) : Seq[SVcfWalker] = {
          /*val burdenWriterMap = burdenCountsFile.map{ bcf => 
            val cc = bcf.split("[:]");
            if(cc.length == 2){
              (cc(0),openWriterSmart(cc(1)));
            } else if(cc.length > 2){
              error("Error: burdenCountsFile must be at most 2 elements seperated by a colon: fileID and filePath. Or just filepath");
              ("",openWriterSmart(""))
            } else {
              ("",openWriterSmart(bcf))
            }
            
          }.toMap;*/
            val (sampleToGroupMap,groupToSampleMap,groups) : (scala.collection.mutable.AnyRefMap[String,Set[String]],
                           scala.collection.mutable.AnyRefMap[String,Set[String]],
                           Vector[String]) = getGroups(groupFile, None, superGroupList);
            
           val ssseq = variantMapFunction.toSeq.map{ vmfString => {
              val fullcells = vmfString.split("(?<!\\\\)[|]",-1).map{ xx => xx.replaceAll("\\\\[|]","|") }.map{ s => s.trim() }
              
              //if(fullcells.length < 2){
              //  error("variantMapFunction must be composed of at least 2 |-delimited elements: the mapFunctionType and the walker ID. In most cases it will also require additional parameters. Found: [\""+fullcells.mkString("\"|\"")+"\"]");
              //}
              val rawMapType = fullcells.head;
              val mapType = MAP_ID_MAP(rawMapType);
              val mapID = fullcells.lift(1).getOrElse("")
              if(mapID.contains('=')){
                error("Error in mapFunction: second parameter must be the ID! Instead found: \""+mapID+"\"");
              }
              
              val sc = fullcells.drop(2)
              //if( ! MAP_FUNCTIONS.contains(mapType)){
              //  error("FCN \"+mapTYPE+\" NOT FOUND!");
              //}
                if( ! MAP_FUNCTIONS.contains(mapType)){
                  error("FCN \""+mapType+"\" NOT FOUND!");
                }
              val tagPrefix = if(mapID == "") "" else mapID + "_";
              val defaultFcnParams = Map[String,String](
                    ("filterTag",tagPrefix+"FILTER"),
                    ("inputGT",calcStatGtTag),
                    ("outputGT",tagPrefix+"FILTER_GT"),
                    ("inputGtNewName",tagPrefix+"PREFILTER_GT"),
                    ("desc","(no description provided)")
                ) ++ groupFile.toSeq.map{ gf => {
                  ("groupFile",gf)
                }}.toMap ++ superGroupList.toSeq.map{ sg => {
                  ("superGroupList",sg)
                }}.toMap ++ genomeFA.toSeq.map{ gfa => {
                  ("genomeFA",gfa)
                }}
              
                val ppss = ParsedParamStrSet(sc, MAP_FUNCTIONS(mapType))
                ppss.set("mapID",mapID);
                ppss.set("mapType",mapType);
                ppss.set("tagPrefix",tagPrefix);
                
                ppss.setDefaults(defaultFcnParams)
                (mapType, ppss)
           }}
      
           val svwseq : Seq[SVcfWalker] = ssseq.flatMap{ case (mapType,params) => {
             
             if(mapType == "tagVariantsExpression"){
                warning("Warning: This function is DEPRECATED! Use function \"addInfo\" instead!","DEPRECATED_FUNCTION_tagVariantsFunction",-1)
               Some( VcfExpressionTag(expr = params("expr"), tagID = params("mapID"), tagDesc = params("desc")) );
             } else if(mapType == "tagVariantsFunction"){
                warning("Warning: This function is DEPRECATED! Use function \"addInfo\" instead!","DEPRECATED_FUNCTION_tagVariantsFunction",-1)
                val paramTags = params.get("params").map{ pp => {
                  pp.split(",").toSeq;
                }}.getOrElse(Seq[String]())
                
                Some(new AddFuncTag(func=params("func"),newTag=params("mapID"),paramTags=paramTags,digits=params.get("digits").map{d => string2int(d)},desc=Some(params("desc"))));

             } else if(mapType == "addInfo"){
                val rawFunc = params("func").split("[(]").head;
                val paramTags = params("func").split("[(]",2).lift(1).map{ pp => {
                  if(pp.trim().last != ')'){
                    error("Error: hanging open paren in string: "+params("func"));
                  }
                  pp.init.split(",").toSeq.map{ _.trim() }
                }} match {
                  case Some(rp) => {
                    rp;
                  }
                  case None => {
                    params.get("params").map{ pp => {
                      pp.split(",").toSeq;
                    }}.getOrElse(Seq[String]())
                  }
                }
                Some(new AddFunctionTag(func=rawFunc,newTag=params("mapID"),paramTags=paramTags,digits=None,desc=Some(params("desc"))));
             } else if(mapType == "tally"){
                val rawFunc = params("func").split("[(]").head;
                val paramTags = params("func").split("[(]",2).lift(1).map{ pp => {
                  if(pp.trim().last != ')'){
                    error("Error: hanging open paren in string: "+params("func"));
                  }
                  pp.init.split(",").toSeq.map{ _.trim() }
                }} match {
                  case Some(rp) => {
                    rp;
                  }
                  case None => {
                    params.get("params").map{ pp => {
                      pp.split(",").toSeq;
                    }}.getOrElse(Seq[String]())
                  }
                }
                Some(new RunTally(func=rawFunc,newTag=params("mapID"),paramTags=paramTags));
                
                /*
                        ParamStrSet("tally" ,  desc = "This is a set of functions that takes various counts and totals across the whole VCF.", 
           synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "func",synon=Seq(),ty="String",valueString="func",desc="",req=true,initParam = true),
           ParamStr(id = "params",synon=Seq(),ty="String",valueString="p1,p2,...",desc="Input parameters.",req=false,hidden=true)
         )), category = "Variant Annotation"
       ),
                 */
                
             } else if(mapType == "genotypeFilter"){
                Some( FilterGenotypesByStat(
                   filter = params("expr"), 
                   filterTag = params("filterTag"),
                   gtTag = params("inputGT"),
                   rawGtTag = params("inputGtNewName"),
                   noRawGt = params.isSet("inputGtNewName"),
                   newGTTag = params("outputGT"),
                   groupFile = params.get("groupFile"), 
                   groupList = None, 
                   superGroupList  = params.get("superGroupList")
                ))
             } else if(mapType == "unPhaseAndSortGenotypes"){
                 Some( FilterTags(
                     unPhaseAndSortGenotypes = params.get("inputGT").map{s => s.split(",").toList }
                  ))
             } else if(mapType == "genotypeExpression"){
                error("variantMapFunction TYPE: \""+mapType+"\" is NOT YET IMPLEMENTED!");
                None
            // } else if(mapType == "keepVariantsExpression"){
            //    error("variantMapFunction TYPE: \""+mapType+"\" is NOT YET IMPLEMENTED!");
            //    None
             } else if(mapType == "sampleReorder"){
               val sampleOrd = (params.get("sampleOrdering") match {
                 case Some(s) => Some(s);
                 case None => params.get("sampleOrderingFile")
               }).map{ s => s.split(",").toList }.getOrElse(List[String]());
               Some( new ReorderSamples(sampleOrdering = sampleOrd, sort = params.isSet("alphabetical")) )
               //              Seq[SVcfWalker]( new ReorderSamples(sampleOrdering = inputSampleOrdering.getOrElse(List[String]()), sort = inputSampleOrderingAlphabetical) )
               //None
             } else if(mapType == "tagBedFile"){
               //AddTxBedFile(bedFile = bedFile, tag =t, bufferDist = string2int(bufferDist), desc =desc, chromList = chromList,style=style);
/*
 *            (DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "file",synon=Seq(),ty="String",valueString="mybed.bed.gz",desc="",req=true),
           ParamStr(id = "desc",synon=Seq(),ty="String",valueString="",desc="",req=false,defaultValue = Some("No desc provided")),
           ParamStr(id = "buffer",synon=Seq(),ty="Integer",valueString="x",desc="",req=false),
           ParamStr(id = "style",synon=Seq(),ty="String",valueString="Either +, -, or s",desc="",req=false)
 */
               Some( AddTxBedFile(
                   bedFile = params("file"),
                   tag = params("mapID"),
                   bufferDist = string2int(params("buffer")),
                   desc = params("desc"),
                   chromList = chromList,
                   style = params("style")
               ))
               
             } else if(mapType == "sampleCounts"){
                val vcfCodes : VCFAnnoCodes = VCFAnnoCodes(CT_INFIX = params("tagPrefix")+"_")
                Some( SAddGroupInfoAnno(groupFile = params.get("groupFile"),
                                                groupList = None,
                                                superGroupList  = params.get("superGroupList"), 
                                                chromList = chromList,
                                                noMultiAllelics = true,
                                                tagFilter = None,
                                                tagPreFiltGt = None,
                                                GTTag = params("inputGT"),
                                                vcfCodes = vcfCodes,
                                                addAlle = ! params.isSet("noAlleCalc"), addCounts = ! params.isSet("noCountsCalc"), addFreq = ! params.isSet("noFreqCalc"), addMiss = ! params.isSet("noMissCalc"),
                                                addHetHom = ! params.isSet("noHetHomCalc"), addMultiHet = ! params.isSet("noMultiHetCalc"),
                                                expr=params.get("expr")
                                                ))
             } else if(mapType == "sampleLists"){
                Some(AddAltSampLists(tagGT = params("inputGT"),
                             outputTagPrefix = params("mapID")+"_SAMPLIST_" ,
                             printLimit = params.get("samplePrintLimit").map{ string2int(_) },
                             groupFile = params.get("groupFile"), groupList = None, superGroupList = params.get("superGroupList"),
                             expr = params.get("expr")
                            ))
             } else if(mapType == "depthStats"){
                Some(AddStatDistributionTags(tagAD = params.get("inputAD"), 
                                            tagGT = params("inputGT"), 
                                            tagDP = params.get("inputDP"),
                                            tagSingleCallerAlles = None,
                                            outputTagPrefix= params("mapID")+"_",
                                            variantStatExpression = None,
                                            restrictToGroup = params.get("restrictToGroup"),
                                                groupFile = params.get("groupFile"),
                                                groupList = None,
                                                superGroupList  = params.get("superGroupList")
                ))
             } else if(mapType == "calcStats"){
               
               (if(params.isSet("noDepthStats")){
                 None
               } else {
                Some(AddStatDistributionTags(tagAD = params.get("inputAD"), 
                                            tagGT = params("inputGT"), 
                                            tagDP = params.get("inputDP"),
                                            tagSingleCallerAlles = None,
                                            outputTagPrefix= params("mapID")+"_",
                                            variantStatExpression = None
                ))
               }).toSeq ++
               (if(params.isSet("noSampleLists")){
                 None
               } else {
                Some(AddAltSampLists(tagGT = params("inputGT"),
                             outputTagPrefix = params("mapID")+"_SAMPLIST_" ,
                             printLimit = params.get("samplePrintLimit").map{ string2int(_) },
                             groupFile = params.get("groupFile"), groupList = None, superGroupList = params.get("superGroupList"),
                             expr = params.get("expr")
                            ))
               }).toSeq ++
               (if(params.isSet("noSampleCounts")){
                 None
               } else {
                val vcfCodes : VCFAnnoCodes = VCFAnnoCodes(CT_INFIX = params("mapID")+"_")
                Some( SAddGroupInfoAnno(groupFile = params.get("groupFile"),
                                                groupList = None,
                                                superGroupList  = params.get("superGroupList"), 
                                                chromList = chromList,
                                                noMultiAllelics = true,
                                                tagFilter = None,
                                                tagPreFiltGt = None,
                                                GTTag = params("inputGT"),
                                                vcfCodes = vcfCodes,
                                                addAlle = ! params.isSet("noAlleCalc"), addCounts = ! params.isSet("noCountsCalc"), addFreq = ! params.isSet("noFreqCalc"), addMiss = ! params.isSet("noMissCalc"),
                                                addHetHom = ! params.isSet("noHetHomCalc"), addMultiHet = ! params.isSet("noMultiHetCalc"),
                                                expr=params.get("expr")
                                                ))
               }).toSeq
               
             } else if(mapType == "filterTags"){
                 val keepGeno = params.get("FORMAT.keep").map{ _.split(",").toList }
                 val keepInfo = params.get("INFO.keep").map{ _.split(",").toList }
                 val keepSamp = params.get("SAMPLES.keep").map{ _.split(",").toList }
                 val dropGeno = params.get("FORMAT.drop").map{ _.split(",").toList }.toList.flatten
                 val dropInfo = params.get("INFO.drop").map{ _.split(",").toList }.toList.flatten
                 val dropSamp = params.get("SAMPLES.drop").map{ _.split(",").toList }.toList.flatten
                 Some( FilterTags(
                     keepGenotypeTags = keepGeno,
                     dropGenotypeTags = dropGeno,
                     keepInfoTags = keepInfo,
                     dropInfoTags = dropInfo,
                     dropAsteriskAlleles = false,
                     keepSamples = keepSamp,
                     dropSamples = dropSamp,
                     alphebetizeHeader = false,
                     renameInfoTags = None
                  ))
             } else if(mapType == "keepVariants"){
                Some(VcfExpressionFilter(filterExpr = params("expr")))
             } else if(mapType == "extractRegion"){
                Some(VcfExtractRegionFromSorted(region = params("region"), windowSize = params.get("windowSize").map{ string2int(_)}  ))
             } else if(mapType == "snpSiftAnno"){
                Some(SnpSiftAnnotater(params("mapID"),params("cmd")))
             } else if(mapType == "snpSiftDbnsfp"){
                Some(SnpSiftDbnsfp(params("mapID"),params("cmd")))
             } else if(mapType == "snpEff"){
                Some(SnpEffAnnotater(params("mapID"),params("cmd"),params("mapID")))
             } else if(mapType == "homopolymerRunStats"){
               Some(HomopolymerRunStats(tagPrefix=params("tagPrefix"),genomeFa=params("genomeFA"), lenThreshold = params("runSize").toInt))
             } else if(mapType == "addContextBases"){
               Some(AddContextBases(tagPrefix=params("tagPrefix"),genomeFa=params("genomeFA"), len = params("windowSize").toInt))
             } else if(mapType == "gcContext"){
               Some(localGcInfoWalker(tagPrefix=params("tagPrefix"),windows=params("windowSize").split(",").toSeq.map{_.toInt},genomeFa=params("genomeFA"), roundDigits = params.get("digits").map{_.toInt}))
             } else if(mapType == "convertChromNames"){
               //Seq[SVcfWalker](ChromosomeConverter(chromDecoder = icd, fromCol= inputChromDecoderFromCol, toCol = inputChromDecoderToCol))
               /*
                ChromosomeConverterAdv(chromDecoder : String, 
                 fromToColumnNames : Option[(String,String)] = None,
                 fromToIdx : Option[(String,String)] = None,
                 hasTitleColumn : Boolean = true,
                       quiet : Boolean = false)
                */
               Some(ChromosomeConverterAdv(chromDecoder = params("file"),
                                           fromToColumnNames = params.get("columnNames").map{ s => (s.split(",")(0),s.split(",")(1)) },
                                           fromToIdx = params.get("columnIdx").map{ s => (s.split(",")(0),s.split(",")(1)) },
                                           skipFirstRow = params.isSet("skipFirstRow")));
             } else if(mapType == "convertSampleNames"){
               Some(SampleRenameAdv(decoder = params("file"),
                                           fromToColumnNames = params.get("columnNames").map{ s => (s.split(",")(0),s.split(",")(1)) },
                                           fromToIdx = params.get("columnIdx").map{ s => (s.split(",")(0),s.split(",")(1)) },
                                           skipFirstRow = params.isSet("skipFirstRow")));
             } else if(mapType == "sanitize"){
               //error("NOT YET IMPLEMENTED!");
               //None;
               Some(new SanitizeVcf());
             
             } else if(mapType == "snpEffExtract"){
               /*
                  
  class SnpEffInfoExtract(tagID : String = "ANN", 
                          tagPrefix : String = "ANNEX_",
                          geneList : Option[List[String]] = None,
                          snpEffBiotypeKeepList : Option[List[String]] = None,
                          snpEffEffectKeepList : Option[List[String]] = None,
                          snpEffWarningDropList : Option[List[String]] = None,
                          snpEffKeepIdx : Option[List[String]] = None,
                          geneListName : Option[String] = None,
                          snpEffVarExtract : List[String] = List[String](),
                          snpEffInfoExtract : List[String] = List[String](),
                          geneListTagInfix : String = "onList_",
                          snpEffBiotypeIdx : Int = 7,
                          snpEffWarnIdx : Int = 15,
                          snpEffFieldLen : Int = 16,
                          snpEffFields : Option[List[String]] = None,
                          snpEffGeneNameIdx : Option[Int] = None,
                          severityListSet : Option[String] = None
                          ) 
                */
               
               
               
               Some(
                   new SnpEffInfoExtract(tagID = params("annTag"),
                                         tagPrefix = params("tagPrefix"),
                                         snpEffBiotypeKeepList = params.get("bioTypeKeepList").map{ _.split(",").toList },
                                         snpEffEffectKeepList  = params.get("effectKeepList").map{ _.split(",").toList },
                                         snpEffWarningDropList = params.get("warningDropList").map{ _.split(",").toList },
                                         //snpEffKeepIdx         = params.get("keepIdx").map{ _.split(",").toList },
                                         geneListTagInfix      = params.getOrElse("geneListName","onList_"),
                                         geneList              = params.get("geneList").map{ _.split(",").toList },
                                         
                                         snpEffVarExtract    = params.get("extractFields").map{ x => x.split(",").toList }.getOrElse(List()),
                                         severityListSet = Some(params("severityList")),
                                         
                                         snpEffGeneNameIdx   = Some(string2int(params("geneNameIdx"))),
                                         snpEffBiotypeIdx    = (string2int(params("biotypeIdx"))),
                                         snpEffWarnIdx       = (string2int(params("warnIdx")))
                                         
                       )
               )
             } else if(mapType == "snpEffExtractField"){
                //error("variantMapFunction TYPE: \""+mapType+"\" NOT YET IMPLEMENTED!");

                Some(
                   new SnpEffExtractElement(
                       tagPrefix = params("tagPrefix"),
                       tagPrefixOutput = params.get("outputTagPrefix"),
                       fieldInfix = params("mapID"),
                       columnIx = params("columns").split(",").map{_.toInt}.toList,
                       desc = params("desc"),
                       collapseUniques = params.isSet("collapseUniques"),
                       tagSet = params.getOrElse("tagSet","HIGH,MODERATE,LOW,NS,ANY").split(",").toSeq
                   )
                )
             } else if(mapType == "checkReferenceMatch"){
               //checkReferenceMatch
               Some(new internalUtils.GatkPublicCopy.CheckReferenceMatch(genomeFa = params("genomeFA"), infotag = params("mapID")));
             } else if(mapType == "addVariantIdx"){
                //val (tagString,idxPrefix) = (addVariantIdx.get.split(",").head, addVariantIdx.get.split(",").lift(1) )
                Seq[SVcfWalker](new AddVariantIdx(tag = params("mapID"),idxPrefix = params.get("prefix")))
             } else if(mapType == "addVariantPosInfo"){
                //val (tagString,idxPrefix) = (addVariantIdx.get.split(",").head, addVariantIdx.get.split(",").lift(1) )
                Seq[SVcfWalker](new AddVariantPosInfoWalker(params("mapID")))
             } else if(mapType == "calcBurdenMatrix"){
               //error("NOT YET IMPLEMENTED!")
               
              //ParamStr(id = "geneListFile",synon=Seq(),ty="String",valueString="k",desc="",req=false),
              //ParamStr(id = "printFullGeneList",synon=Seq(),ty="flag",valueString="k",desc="",req=false),
              val geneList  = params.get("geneList").map{ g => {
                Some( g.split("[,]").toSeq ++ params.get("geneListFile").map{ gf => {
                  getLinesSmartUnzip(gf).toSeq
                }}.getOrElse(Seq()) )
              }}.getOrElse(
                params.get("geneListFile").map{ gf => {
                  getLinesSmartUnzip(gf).toSeq
                }}
              )
               
              /*
               * sampleToGroupMap,groupToSampleMap,groups
               */
              val (a,b,c) = if( params.get("groupFile") == groupFile & params.get("superGroupList") == superGroupList ){
                (sampleToGroupMap,groupToSampleMap,groups)
              } else { 
                  getGroups(params.get("groupFile"), None, params.get("superGroupList"));
              }
              
              Some(new calcBurdenMatrixWalker(tagID=params("mapID"),
                  geneTag=params("geneTag"),
                  filterExpressionString=params.getOrElse("expr","TRUE"),
                  sampSubset=params.get("sampleSet").map{ x => x.split(",").toSet},
                  sampGroup=params.get("group"),
                  gtTag=params("inputGT"), 
                  outfile=params("outfile"), 
                   sampleToGroupMap=a,groupToSampleMap=b,groups=c,
                  geneList = geneList,
                  pathwayList = params.get("pathwayList").map{ g => g.split("[;]").toSeq }.getOrElse(Seq()),
                  printFullGeneList = params.isSet("printFullGeneList")
              ) )
               
               
               
                    /*  ParamStrSet("calcBurdenMatrix" ,  desc = "....", 
           (DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "geneTag",synon=Seq(),ty="String",valueString="k",desc="",req=true),
              ParamStr(id = "expr",synon=Seq(),ty="String",valueString="k",desc="",req=false),
              ParamStr(id = "sampleSet",synon=Seq(),ty="String",valueString="k",desc="",req=false),
              ParamStr(id = "group",synon=Seq(),ty="String",valueString="k",desc="",req=false),
              ParamStr(id = "inputGT",synon=Seq(),ty="String",valueString="k",desc="",req=false),
              
              ParamStr(id = "geneList",synon=Seq(),ty="String",valueString="k",desc="",req=true),
              ParamStr(id = "pathwayList",synon=Seq(),ty="String",valueString="A=a:b:c:d,B=c:d:e:f",desc="",req=true),
              
             COMMON_PARAMS("groupFile"),COMMON_PARAMS("superGroupList"),
           
             ParamStr(id = "countFileID",synon=Seq(),ty="String",valueString="k",desc="If multiple output count files are desired, you can specify which functions output to which count file using this parameter. Note that each file must be created using a --burdenCountsFile parameter, with the form fileID:/path/to/file.txt",req=false)
*/
               
             } else if(mapType == "calcBurdenCounts"){
               
              val writerID = params.getOrElse("countFileID","");
              if(! burdenWriterMap.contains(writerID)){
                error("Error: countfile not specified! You must specify a countfile using --burdenCountsMap ("+writerID+")");
              }
              val (a,b,c) = if( params.get("groupFile") == groupFile & params.get("superGroupList") == superGroupList ){
                (sampleToGroupMap,groupToSampleMap,groups)
              } else { 
                  getGroups(params.get("groupFile"), None, params.get("superGroupList"));
              }
              Some(new calcBurdenCountsWalker(tagID=params("mapID"),
                  geneTag=params("geneTag"),
                  filterExpressionString=params.getOrElse("expr","TRUE"),
                  sampSubset=params.get("sampleSet").map{ x => x.split(",").toSet},
                  sampGroup=params.get("group"),
                  gtTag=params("inputGT"), 
                  out=burdenWriterMap( writerID ), 
                  sampleToGroupMap=a,groupToSampleMap=b,groups=c))

                /*
                 * 
              val params = cbc.split(",");
              val tagID = params(0);
              val geneTag = params(1);
              val filterExpressionString = params.find( pp => pp.startsWith("keepVariantsExpression=")).map{pp => pp.drop( "keepVariantsExpression=".length )}.getOrElse("TRUE");
              val sampSubset = params.find( pp => pp.startsWith("samples=")).map{pp => pp.drop( "samples=".length ).split("[|]").toSet};
              val sampGroup  = params.find( pp => pp.startsWith("group=")).map{pp => pp.drop( "group=".length )}
              val gtTag = params.find( pp => pp.startsWith("gtTag=")).map{pp => pp.drop( "gtTag=".length )}.getOrElse("GT");
              new calcBurdenCountsWalker(tagID=tagID,geneTag=geneTag,filterExpressionString=filterExpressionString,sampSubset=sampSubset,sampGroup=sampGroup,gtTag=gtTag, out=burdenWriter.get, groupFile = groupFile, groupList = None, superGroupList  = superGroupList)
                */
             } else if(mapType == "calcBurdenCountsByGroups"){
               
              val writerID = params.getOrElse("countFileID","");
              if(! burdenWriterMap.contains(writerID)){
                error("Error: countfile not specified! You must specify a countfile using --burdenCountsMap ("+writerID+")");
              }
              val (a,b,c) = if( params.get("groupFile") == groupFile & params.get("superGroupList") == superGroupList ){
                (sampleToGroupMap,groupToSampleMap,groups)
              } else { 
                  getGroups(params.get("groupFile"), None, params.get("superGroupList"));
              }
              Some(new calcBurdenCountsSetWalker(tagID=params("mapID"),
                  geneTag=params("geneTag"),
                  filterExpressionString=params.getOrElse("expr","TRUE"),
                  sampGroups=params("groups").split(",").toSeq,
                  gtTag=params("inputGT"), 
                  out=burdenWriterMap( writerID ), 
                  sampleToGroupMap=a,groupToSampleMap=b,groups=c))
                  
             } else if(mapType == "fixFirstBaseMismatch"){
               // Some(HomopolymerRunStats(tagPrefix=params("tagPrefix"),genomeFa=params("genomeFA"), lenThreshold = params("runSize").toInt))
               Some(internalUtils.GatkPublicCopy.FixFirstBaseMismatch(genomeFa = params("genomeFA"),windowSize = string2int( params.getOrElse("windowSize","200"))));
               
             } else if(mapType == "leftAlignAndTrim"){
               Some( internalUtils.GatkPublicCopy.LeftAlignAndTrimWalker(genomeFa = params("genomeFA"),windowSize =  string2int( params.getOrElse("windowSize","200")) , useGatkLibCall = false) )
             } else if(mapType == "fixSwappedRefAlt"){
               Some(internalUtils.GatkPublicCopy.FixRefAltSwaps( genomeFa = params("genomeFA"), changeTag = Some("RefAltSwap"), warnTag  = Some("BadRefAlle")))
             } else if(mapType == "splitMultiAllelics"){
               if( params.isSet("useStarAlle") ){
                   Seq( SSplitMultiAllelics(vcfCodes = DEFAULT_VCF_CODES, clinVarVariants = false, splitSimple = false) )
               } else {
                 Seq(SSplitMultiAllelics2(vcfCodes = DEFAULT_VCF_CODES))
                 
                  /* Seq( SSplitMultiAllelics(vcfCodes = DEFAULT_VCF_CODES, clinVarVariants = false, splitSimple = false),
                        new StdVcfConverter(cleanHeaderLines = false, 
                           cleanInfoFields =false, 
                           cleanMetaData = false,
                           collapseStarAllele = true,
                           deleteUnannotatedFields  = false)
//                          thirdAlleleChar : Option[String] = None,
//                         multAlleInfoTag : Option[String] = None)
                    )*/
               }
             } else if(mapType == "rmDup"){
               Some(new RemoveDuplicateLinesWalker())
             } else if(mapType == "fixDotAltIndels"){
               Some( new internalUtils.GatkPublicCopy.FixDotAltVcfLines(genomeFa = params("genomeFA") ) )
             } else if(mapType == "dropNullVariants"){
               Some(SFilterNonVariantWalker())
             } else if(mapType == "dropSpanIndels"){
               Some(new DropSpanIndels())
             } else if(mapType == "getLocusDepthFromWig"){
               val wigfile = params("wigFile")
               if( ! (new File(wigfile)).exists() ){
                 error("ERROR: Wiggle file: "+wigfile+" does not exist!");
               }
               Some( new addWiggleDepthWalker(wigFile = wigfile, tag = params("mapID"), desc = params.getOrElse("desc","noDesc")) )
             } else if(mapType == "dropVariantsWithNs"){
               Some(new DropNs());
             } else if(mapType == "markDup"){
                Some(new DuplicateStats(params("mapID")))
             } else if(mapType == "convertToStdVcf"){
               Some( new StdVcfConverter(thirdAlleleChar = None) )

               
             } else if(mapType == "addAltSequence"){
                
               Some(AddAltSequence(tagString=params.get("mapID"),genomeFa=params("genomeFA"), len = string2int( params("windowSize") )))
             } else if(mapType == "dropGenotypeData"){
               Some(StripGenotypeData(addDummyGenotypeColumn=false))
             } else if(mapType == "addDummyGenotypeColumn"){
               Some(StripGenotypeData(addDummyGenotypeColumn=true))
             } else if(mapType == "dropSymbolicAlleles"){
                Some(new FilterSymbolicAlleleLines());
             } else if(mapType == "copyColumnToInfo"){
               val qual = if(params("columnID") == "QUAL") Some(params("mapID")) else None
               val filt = if(params("columnID") == "FILTER") Some(params("mapID")) else None
               val idtag = if(params("columnID") == "ID") Some(params("mapID")) else None
               Some(CopyFieldsToInfo( qualTag = qual, filterTag = filt, idTag = idtag ))
               /*
                * CopyFieldsToInfo(qualTag : Option[String], filterTag : Option[String], idTag : Option[String], copyFilterToGeno : Option[String],copyQualToGeno : Option[String],
                              copyInfoToGeno : List[String])
                */
               
               /*
                
                       ParamStrSet("copyAltToInfo" ,  desc = "",
                  synon = Seq("addAltSeq"),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )), category = "File Formatting."
       ),
       ParamStrSet("dropGenotypeData" ,  desc = "",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )), category = "File Formatting."
       ),
       ParamStrSet("addDummyGenotypeColumn" ,  desc = "",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )), category = "File Formatting."
       ),
       ParamStrSet("dropSymbolicAlleles" ,  desc = "",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )), category = "File Formatting."
       ),
                
                */
               
             } else {
                error("variantMapFunction TYPE: \""+mapType+"\" DOES NOT EXIST!");
                None
             }
           }}
          
            svwseq;
        
        
        
      }
      
      
      
}









 


















