package internalTests

import htsjdk.variant._;
import htsjdk.variant.variantcontext._;
import htsjdk.variant.vcf._;
import java.io.File;
//import scala.collection.JavaConversions._
import java.io._;
import internalUtils.commandLineUI._;
import internalUtils.Reporter._;

//import scala.collection.JavaConversions._
import scala.collection.JavaConverters._

import internalUtils.optionHolder._;
import internalUtils.Reporter._;
import internalUtils.stdUtils._;
import internalUtils.genomicAnnoUtils._;
import internalUtils.GtfTool._;
import internalUtils.commandLineUI._;
import internalUtils.fileUtils._;
import internalUtils.TXUtil._;
import internalUtils.TXUtil

import internalUtils.VcfTool._;

import internalUtils.VcfTool;

import htsjdk.variant._;
import htsjdk.variant.variantcontext._;
import htsjdk.variant.vcf._;

import internalUtils.genomicUtils._;
import internalUtils.commonSeqUtils._;

import jigwig.BigWigFile;

import SVcfTagFunctions._;
import SVcfWalkerUtils._;

//import com.timgroup.iterata.ParIterator.Implicits._;

object SVcfMapFunctions {

  
  
  
  
    val SNVVARIANT_BASESWAP_LIST = Seq( (("A","C"),("T","G")),
                            (("A","T"),("T","A")),
                            (("A","G"),("T","C")),
                            (("C","A"),("G","T")),
                            (("C","T"),("G","A")),
                            (("C","G"),("G","C"))
                          );

     val DEFAULT_VCF_CODES = VCFAnnoCodes();

     val COMMON_PARAMS : Map[String,ParamStr] = Seq[ParamStr](
           ParamStr(id = "genomeFA",synon=Seq(),ty="String",valueString="genome.fasta.gz",desc="The genome fasta file containing the reference genome. This will be used by various functions that require genomic information. Note that some functions that call the GATK library will also require that the fasta be indexed. Note: Chromosome names must match.",req=true),
           ParamStr(id = "groupFile",synon=Seq(),ty="String",valueString="group.file.txt",desc="A tab-delimited file containing sample ID's and a list of group IDs for each sample. See the --groupFile parameter of walkVcf.",req=false),
           ParamStr(id = "superGroupList",synon=Seq(),ty="String",valueString="superGroups",desc="See the --superGroupList parameter of walkVcf.",req=false,hidden=true)
                 ).map{ ps => {
                   (ps.id,ps)
                 }}.toMap
  
     val DEFAULT_MAP_PARAMS : Seq[ParamStr] = Seq[ParamStr](
           ParamStr(id = "mapType",synon=Seq(),ty="String",valueString="s",desc="The function to run.",req=true,initParam = false, hidden=true),
           ParamStr(id = "mapID",synon=Seq(),ty="String",valueString="id",desc="The ID to use for this operation. This ID will also be used in the output tag IDs generated by this operation.",req=true,initParam = false, hidden=true),
           ParamStr(id = "tagPrefix",synon=Seq(),ty="String",valueString="s",desc="",req=true,initParam = false, hidden=true)//,
     )
     
     
     val MAPFUNCTIONS_GROUPS = Seq("General-Purpose Tools",
                                   "Formatting/Conversion",
                                   "Variant Formatting/Conversion",
                                   "File/Database Annotation",
                                   "Genotype Processing",
                                   "General-Purpose Tools",
                                   "Concordance Caller",
                                   "Filtering",
                                   "Genomic Locus Annotation",
                                   "Data/Table Extraction",
                                   "File Formatting/Conversion",
                                   "Misc","",
                                   "DEPRECATED")

     
     val MAP_FUNCTIONS_SEQ  : Seq[(String,ParamStrSet)] = Seq(
       ParamStrSet("tagVariantsExpression" , desc = "This function takes a variant expression and creates a new INFO field that is 1 if and only if that expression returns TRUE, and 0 otherwise.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "expr",synon=Seq(),ty="String",valueString="expr",desc="The variant expression, which is a true/false expression using the variant expression syntax.",req=true),
           ParamStr(id = "desc",synon=Seq(),ty="String",valueString="...",desc="A description, to go in the info field description.",req=false,defaultValue = Some("No desc provided"))
         )), category = "DEPRECATED", hidden = true, deprecated = true
       ),
       ParamStrSet("tagVariantsFunction" ,  desc = "This is a set of functions that all take one or more input parameters and outputs one new INFO field.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "func",synon=Seq(),ty="String",valueString="func",desc="",req=true),
           ParamStr(id = "desc",synon=Seq(),ty="String",valueString="",desc="",req=false,defaultValue = Some("No desc provided")),
           ParamStr(id = "digits",synon=Seq(),ty="Integer",valueString="x",desc="",req=false, hidden=true),
           ParamStr(id = "params",synon=Seq(),ty="String",valueString="p1,p2,...",desc="",req=false)
         )), category = "DEPRECATED", hidden = true, deprecated = true
       ),
       //TAGTITLE:bufferLen:filedesc:bedfile.bed,TAGTITLE2:bufferLen:filedesc2:bedfile2.bed.gz,...
       //       //  class AddFunctionTag(func : String, newTag : String, paramTags : Seq[String], digits : Option[Int] = None, desc : Option[String] = None ) extends internalUtils.VcfTool.SVcfWalker { 
       ParamStrSet("addInfo" ,  desc = "This is a set of functions that all take one or more input parameters and outputs one new INFO field. "+
                                          "The syntax is: --fcn \"addInfo|newTagName|fcn(param1,param2,...)\". Optionally you can add \"|desc=tag description\". "+
                                          "There are numerous addInfo functions. See the section in the help doc titled INFO TAG FUNCTIONS, or use the help command: "+
                                          "varmyknife help addInfo",
           synon = Seq("addInfoTag"),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "func",synon=Seq(),ty="String",valueString="func",desc="",req=true,initParam = true),
           ParamStr(id = "desc",synon=Seq(),ty="String",valueString="",desc="The description in the header line for the new INFO field.",req=false,defaultValue = Some("No desc provided")),
           //ParamStr(id = "digits",synon=Seq(),ty="Integer",valueString="x",desc="For floating point values, the number of digits to include after the decimal",req=false),
           ParamStr(id = "params",synon=Seq(),ty="String",valueString="p1,p2,...",desc="Input parameters.",req=false,hidden=true)
         )), category = "General-Purpose Tools",
         exampleCode = Seq[Seq[String]](
           Seq[String](
             "Make a new INFO field which is the maximum from several allele frequencies (which are already in the file) "+
             "Then make a 0/1 INFO field that is 1 if the max AF is less than 0.01. "+
             "Note the CONST:0 term, which allows you to include constant values in these functions. "+
             "In this case it makes it so that if the AF is missing in all three populations, the maxAF "+
             "will be 0 rather than missing.\n",
             "   varmyknife walkVcf \\\n"+
             "          --fcn \"addInfo|maxAF|MAX(CEU_AF,AFR_AF,JPT_AF,CONST:0)|\\\n"+
             "                          desc=The max allele frequency from CEU_AF, AFR_AF, or JPT_AF (or zero if all are missing).\"\\\n"+
             "          --fcn \"addInfo|isRare|EXPR(INFO.lt:maxAF:0.01)\"\\\n"+
             "          infile.vcf.gz outfile.vcf.gz\n"),
           Seq[String](
             "   varmyknife walkVcf \\\n"+
             "          --fcn \"addInfo|CarryCt|SUM(hetCount,homAltCount)|\\\n"+
             "                          desc=The sum of the info tags: hetCount and homAltCount.\"\\\n"+
             "          infile.vcf.gz outfile.vcf.gz\n")
         )
       ),
       ParamStrSet("tally" ,  desc = "This is a set of functions that takes various stats from each variant and sums them up across the whole VCF. These functions DO NOT change the VCF itself, they simply emit meta information about the VCF. See the help section on TALLY FUNCTIONS.", 
           synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "func",synon=Seq(),ty="String",valueString="func",desc="",req=true,initParam = true),
           ParamStr(id = "params",synon=Seq(),ty="String",valueString="p1,p2,...",desc="Input parameters.",req=false,hidden=true)
         )), category = "Data/Table Extraction"
       ),
       ParamStrSet("calculateMatchMatrix" ,  desc = "....", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "file",synon=Seq(),ty="String",valueString="output.table.txt",desc="",req=true),
           ParamStr(id = "gtTag",synon=Seq(),ty="String",valueString="",desc="The genotype FORMAT field.",req=false,defaultValue = Some("GT")),
           ParamStr(id = "matchCutoff",synon=Seq(),ty="Float",valueString="x",desc="matches below this threshold will not be written to file.",req=false, defaultValue=Some("0.5"))
         )), category = "Data/Table Extraction",
       ),
       //                Some(ExtractFormatMatrix(matchFile=params.get("file").getOrElse("gt.matrix.txt") , gtTag=params.get("gtTag").getOrElse("GT"), infoFields=params.get("infoFields").map{ ff => ff.split(",").toSeq }.getOrElse(Seq()) ))
       //longForm : Boolean = false, noVarInfo : Boolean = false
       ParamStrSet("extractFormatMatrix" ,  desc = "This utility will create a matrix file with information extracted from the FORMAT fields of the VCF. "+
                                                   "There are two optional formats: standard and longForm. Standard format will have each variant output a row, "+
                                                   "the first columns will be Chrom/pos/id/ref/alt (unless noVarInfo is used, in which case these will be ommitted), followed by the "+
                                                   "info fields listed in the infoFields param, followed by one cell for each sample in the VCF, containing a bar-delimited list of the "+
                                                   "genotype fields listed in the gtTag parameter. "+
                                                   "If the longForm option is used, instead each variant will print its own line for each sample. Note that this method is generally easier to manipulate for large sample sets, but will generally result in a much larger file since the variant data is repeated many times."+
                                                   "", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "file",synon=Seq(),ty="String",valueString="output.table.txt",desc="",req=true),
           ParamStr(id = "gtTag",synon=Seq(),ty="String",valueString="",desc="A comma delimited list of the desired FORMAT fields. If more than one is specified then all will be included in the matrix. If written in standard format, each matrix cell will contain the given fields delimited with bars. If in longform format (see the longForm flag below) then these fields will be tab delimited.",req=false,defaultValue = Some("GT")),
           ParamStr(id = "infoFields",synon=Seq(),ty="String",valueString="x",desc="Comma delimited list of info fields to include after the CHROM/POS/ID/REF/ALT in the output matrix.",req=false, defaultValue=Some(".")),
           ParamStr(id = "longForm",synon=Seq(),ty="Flag",valueString="",desc="If this flag is used, matrix will be printed in 'long form' in which each element in the matrix gets its own entire line.",req=false),
           ParamStr(id = "noVarInfo",synon=Seq(),ty="Flag",valueString="",desc="If this flag is used, the variant info CHROM/POS/ID/REF/ALT is omitted from each line.",req=false)
         )), category = "Data/Table Extraction",
       ),
       
       
       ParamStrSet("addFormat" ,  desc = "This is a set of functions that all take one or more input parameters and outputs one new FORMAT field. "+
                                          "The syntax is: --fcn \"addInfo|newTagName|fcn(param1,param2,...)\". Optionally you can add \"|desc=tag description\". "+
                                          "There are numerous addInfo functions. For more information, go to the section on addFormat Functions below, or use the help command: "+
                                          "varmyknife help addFormat",
           synon = Seq("addFmtTag","addFmt","addGeno"),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "func",synon=Seq(),ty="String",valueString="func",desc="",req=true,initParam = true),
           ParamStr(id = "desc",synon=Seq(),ty="String",valueString="",desc="The description in the header line for the new INFO field.",req=false,defaultValue = Some("No desc provided")),
           ParamStr(id = "params",synon=Seq(),ty="String",valueString="p1,p2,...",desc="Input parameters.",req=false,hidden=true)
         )), category = "General-Purpose Tools",
         exampleCode = Seq[Seq[String]](
           Seq[String](
             "This example makes a new FORMAT field which is the ratio between the coverage on the first ALT allele and the total coverage across all alleles. "+
             "\n",
             "   varmyknife walkVcf \\\n"+
             "          --fcn \"addFormat|AlleleDepth_ALTALLE|extractIDX(AD,1)|\\\n"+
             "                          desc=The observed allele depth for the first alt allele.\"\\\n"+
             "          --fcn \"addFormat|AlleleDepth_TOTAL|SUM(AD)|\\\n"+
             "                          desc=The observed allele depth for the first alt allele.\"\\\n"+
             "          infile.vcf.gz outfile.vcf.gz\n"),
           Seq[String](
             "   varmyknife walkVcf \\\n"+
             "          --fcn \"addInfo|CarryCt|SUM(hetCount,homAltCount)|\\\n"+
             "                          desc=The sum of the info tags: hetCount and homAltCount.\"\\\n"+
             "          infile.vcf.gz outfile.vcf.gz\n")
         )
       ),
       ParamStrSet("tagBedFile" ,  desc = "This function takes a BED file (which can be gzipped if desired) and creates a new INFO field based on whether the variant locus overlaps with a "+
                                          "genomic region in the BED file. The new field can be either an integer that is equal to 1 if there is overlap and 0 otherwise (which is the default behavior) "+
                                          "Or, alternatively, it can copy in the title field from the bed file. NOTE: this function only uses the first 3 to 5 fields of the BED file, it does not "+
                                          "implement the optional fields 10-12 which can specify intron/exon blocks.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "file",synon=Seq(),ty="String",valueString="mybed.bed.gz",desc="",req=true),
           ParamStr(id = "desc",synon=Seq(),ty="String",valueString="",desc="The description for the new INFO line.",req=false,defaultValue = Some("No desc provided")),
           ParamStr(id = "buffer",synon=Seq(),ty="Integer",valueString="x",desc="The additional buffer to add around each BED element.",req=false, defaultValue=Some("0")),
           ParamStr(id = "style",synon=Seq(),ty="String",valueString="Either +, -, or LABEL",desc="This determines the type of INFO tag. For +, the new tag will be a dichotomous 0/1 numeric variable that will equal 1 if and only if the variant intersects with one or more BED lines (including buffer, noted above). For - the opposite is true. For LABEL, the new tag will be a String variable with the title of the element(s) that intersect with the variant, comma delimited. Note that for LABEL style the BED file must have a 4th column.",req=false,defaultValue=Some("+"))
         )), category = "File/Database Annotation",
       ),
       ParamStrSet("convertSampleNames" ,  desc = "This function converts the sample IDs of the VCF file according to a decoder file that you supply. "+
                                                  "Your decoder should be a tab-delimited text file with at least 2 columns. One column should specify the FROM sample names "+
                                                  "as they currently appear in the VCF, and one should specify the new sample names you want them converted TO. "+
                                                  "You must specify which of these columns is which using either the columnNames or columnIdx parameters. "+
                                                  ""+
                                                  ""+
                                                  ""+
                                                  "", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "file",synon=Seq(),ty="String",valueString="myChromDecoder.txt",desc="A tab delimited file with the from/to chromosome names.",req=true),
           ParamStr(id = "columnNames",synon=Seq(),ty="String",valueString="fromCol,toCol",desc="The column titles for the old chrom names and the new chrom names, in that order. If this parameter is used, the decoder file must have a title line.",req=false),
           ParamStr(id = "columnIdx",synon=Seq(),ty="Integer",valueString="fromColNum,toColNum",desc="The column number of the current chromosome names then the new chromosome names, in that order. Column indices start counting from 0. If you use this parameter to set the columns, and if the file has a title line, then you should use skipFirstRow or else it will be read in as if it were a chromosome.",req=false),
           ParamStr(id = "skipFirstRow",synon=Seq(),ty="Flag",valueString="",desc="If this parameter is set, then this tool will skip the first line on the decoder file. This is useful if you are specifying the columns using column numbers but the file also has a title line.",req=false)
         )), category = "File Formatting/Conversion"
       ),
       ParamStrSet("convertChromNames" ,  desc = "This function takes a file and translates chromosome names into a different format. "+
                                                 "This is most often used to convert between the chr1,chr2,... "+
                                                  "format and the 1,2,... format.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "file",synon=Seq(),ty="String",valueString="myChromDecoder.txt",desc="A tab delimited file with the from/to chromosome names.",req=true),
           ParamStr(id = "columnNames",synon=Seq(),ty="String",valueString="fromCol,toCol",desc="The column titles for the old chrom names and the new chrom names, "+
                                                  "in that order. If this parameter is used, the decoder file must have a title line.",req=false),
           ParamStr(id = "columnIdx",synon=Seq(),ty="Integer",valueString="fromColNum,toColNum",desc="The column number of the current chromosome names "+
                                                  "then the new chromosome names, in that order. Column indices start counting from 0. If you use this parameter to set the columns, and if the file has a title line, then you should use skipFirstRow or else it will be read in as if it were a chromosome.",req=false),
           ParamStr(id = "skipFirstRow",synon=Seq(),ty="Flag",valueString="",desc="If this parameter is set, then this tool will skip "+
                                                  "the first line on the decoder file. This is useful if you are specifying the columns using column numbers but the file also has a title line.",req=false)
         )), category = "File Formatting/Conversion"
       ),
       ParamStrSet("sampleReorder" ,  desc = "This function allows you to reorder the sample columns in your VCF. Set ONE of the parameters below to specify the desired ordering.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "sampleOrdering",synon=Seq(),ty="String",valueString="samp1,samp2,...",desc="A simple list of all the samples, in the desired order.",req=false),
           ParamStr(id = "sampleOrderingFile",synon=Seq(),ty="String",valueString="orderingFile.txt",desc="A file containing one sampleID per line. "+
                                                  "The samples will be reordered to match the order found in the file.",req=false),
           ParamStr(id = "alphabetical",synon=Seq(),ty="Flag",valueString="",desc="If this flag is set, then the samples will be reordered alphabetically.",req=false)
         )), category = "File Formatting/Conversion"
       ),
       /*
        * 
        *     } else if(mapType == "sampleReorder"){
               val sampleOrd = (params.get("sampleOrdering") match {
                 case Some(s) => Some(s);
                 case None => params.get("sampleOrderingFile")
               }).map{ s => s.split(",").toList }.getOrElse(List[String]());
               Some( new ReorderSamples(sampleOrdering = sampleOrd, sort = params.isSet("alphabetical")) )
        * 
       */
       

       
       //unPhaseAndSortGenotypes
       ParamStrSet("unPhaseAndSortGenotypes" ,  desc = "This function removes phasing and sorts genotypes (so that heterozygotes are always listed as 0/1 and never 1/0).", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "inputGT",synon=Seq(),ty="String",valueString="GT",desc="The input/output genotype FORMAT field.",req=false),
           COMMON_PARAMS("groupFile"),COMMON_PARAMS("superGroupList")
         )), category = "Genotype Processing"
       ),
       
       ParamStrSet("genotypeFilter" ,  desc = "This function filters a genotype field based on a given genotype expression. The new filtered genotype can replace the GT field or can be set to a different field, so multiple filtering strategies can be included in a single VCF.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "expr",synon=Seq(),ty="String",valueString="expr",desc="A Genotype Expression, using the genotype expression syntax.",req=true),
           ParamStr(id = "desc",synon=Seq(),ty="String",valueString="",desc="A description, to go in the new FORMAT fields.",req=false),
           ParamStr(id = "filterTag",synon=Seq(),ty="String",valueString="tagID",desc="The name of a new FORMAT field, which will be a flag equal to 1 if and only if the genotype passes the filter.",req=false),
           ParamStr(id = "outputGT",synon=Seq(),ty="String",valueString="filtered_GT",desc="The output genotype FORMAT field. If this is the same as the "+
                                                  "input genotype field then the genotype field will be overwritten.",req=false),
           ParamStr(id = "inputGT",synon=Seq(),ty="String",valueString="GT",desc="The input genotype FORMAT field.",req=false),
           ParamStr(id = "inputGtNewName",synon=Seq(),ty="",valueString="prefilt_GT",desc="If this parameter is set, the input genotype field will be copied "+
                                                  "to a new tag with this name before filtering. This can be useful if overwriting the input genotype field.",req=false),
           COMMON_PARAMS("groupFile"),COMMON_PARAMS("superGroupList")
         )), category = "Genotype Processing"
       ),
       ParamStrSet("genotypeSelect" ,  desc = "This function selects between two different a genotype fields based on a given genotype expression. The new composite genotype can replace either GT field or can be set to a different field, so multiple filtering strategies can be included in a single VCF.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "expr",synon=Seq(),ty="String",valueString="expr",desc="A Genotype Expression, using the genotype expression syntax.",req=true),
           ParamStr(id = "desc",synon=Seq(),ty="String",valueString="",desc="A description, to go in the new FORMAT fields.",req=false),
           ParamStr(id = "outputGT",synon=Seq(),ty="String",valueString="filtered_GT",desc="The output genotype FORMAT field. If this is the same as the "+
                                                  "input genotype field then the genotype field will be overwritten.",req=false),
           ParamStr(id = "inputGTifTRUE",synon=Seq(),ty="String",valueString="GT",desc="The input genotype FORMAT field to be used if the expression returns TRUE.",req=true),
           ParamStr(id = "inputGTifFALSE",synon=Seq(),ty="String",valueString="GT",desc="The input genotype FORMAT field to be used if the expression returns FALSE.",req=true),
           ParamStr(id = "missingString",synon=Seq(),ty="String",valueString="GT",desc="The string to use when setting the variable to missing.",req=false),
           COMMON_PARAMS("groupFile"),COMMON_PARAMS("superGroupList")
         )), category = "Genotype Processing"
       ),
       
       
       ParamStrSet("sampleCounts" ,  desc = "This function generates counts and frequencies for alt alleles, alt genotypes, missing genotypes, "+
                                                  "ref genotypes, and so on. Note that there are several calc- flags. If none of these are included, then this function does nothing.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           COMMON_PARAMS("groupFile"),COMMON_PARAMS("superGroupList"),
           ParamStr(id = "inputGT",synon=Seq(),ty="String",valueString="GT",desc="The input genotype FORMAT field.",req=false),
           ParamStr(id = "noCountsCalc",synon=Seq(),ty="Flag",valueString="",desc="If this is set, then no Ct fields will be generated.",req=false),
           ParamStr(id = "noFreqCalc",synon=Seq(),ty="Flag",valueString="",desc="If this is set, then no Freq fields will be generated.",req=false),
           ParamStr(id = "noMissCalc",synon=Seq(),ty="Flag",valueString="",desc="If this is set, then Ct and Freq fields will not be generated to count the number or rate of missing genotypes.",req=false),
           ParamStr(id = "noAlleCalc",synon=Seq(),ty="Flag",valueString="",desc="If this is set, then Ct and Freq fields will not be generated to count allele counts and frequencies.",req=false),
           ParamStr(id = "noHetHomCalc",synon=Seq(),ty="Flag",valueString="",desc="If this is set, then Ct and Freq fields will not be generated to count the number of HomAlt and Het genotypes.",req=false),
           ParamStr(id = "noMultiHetCalc",synon=Seq(),ty="Flag",valueString="",desc="If this is set, then the number of multiallelic heterozygotes will not be counted.",req=false),
           ParamStr(id = "addOtherCountsCalc",synon=Seq(),ty="Flag",valueString="",desc="If this is set, additional optional counts will be added.",req=false),
           ParamStr(id = "expr",synon=Seq(),ty="String",valueString="expr",desc="The variant expression, "+
                                                  "which is a true/false expression using the variant expression syntax.",req=false,defaultValue=None)
           )), category = "General-Purpose Tools"
       ),
       ParamStrSet("sampleLists" ,  desc = "This function generates sample list fields which contain comma-delimited lists of samples that are het or hom-alt.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "inputGT",synon=Seq(),ty="String",valueString="GT",desc="The input genotype FORMAT field.",req=false),
           ParamStr(id = "samplePrintLimit",synon=Seq(),ty="String",valueString="",desc="",req=false),
           COMMON_PARAMS("groupFile"),COMMON_PARAMS("superGroupList"),
           ParamStr(id = "expr",synon=Seq(),ty="String",valueString="expr",desc="The variant expression, which is a "+
                                                  "true/false expression using the variant expression syntax.",req=false,defaultValue=None)

           )), category = "General-Purpose Tools"
       ),
       ParamStrSet("depthStats" ,  desc = "This function calculates various statistics on total read depth and hetAB.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "inputGT",synon=Seq(),ty="String",valueString="GT",desc="The input genotype FORMAT field.",req=false),
           ParamStr(id = "inputAD",synon=Seq(),ty="String",valueString="AD",desc="The input allele depth or AD field.",req=false),
           ParamStr(id = "inputDP",synon=Seq(),ty="String",valueString="DP",desc="The input total depth or DP field.",req=false),
           ParamStr(id = "restrictToGroup",synon=Seq(),ty="String",valueString="",desc="If this variable is set, then all stats will be restricted to the given sample subgroup. Note that sample group information must be supplied either for this function or globally using the --groupFile parameter.",req=false),
           COMMON_PARAMS("groupFile"),COMMON_PARAMS("superGroupList")
           //restrictToGroup
           )), category = "General-Purpose Tools"
       ),
       ParamStrSet("calcStats" ,  desc = "This function combines the functions sampleCounts, sampleLists, and depthStats, performing all three.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           COMMON_PARAMS("groupFile"),COMMON_PARAMS("superGroupList"),
           ParamStr(id = "inputGT",synon=Seq(),ty="String",valueString="GT",desc="The input genotype FORMAT field.",req=false),
           
           ParamStr(id = "inputAD",synon=Seq(),ty="String",valueString="AD",desc="The input allele depth or AD field.",req=false),
           ParamStr(id = "inputDP",synon=Seq(),ty="String",valueString="DP",desc="The input total depth or DP field.",req=false),
 
           
           ParamStr(id = "noCountsCalc",synon=Seq(),ty="Flag",valueString="",desc="If this is set, then no Ct fields will be generated.",req=false),
           ParamStr(id = "noFreqCalc",synon=Seq(),ty="Flag",valueString="",desc="If this is set, then no Freq fields will be generated.",req=false),
           ParamStr(id = "noMissCalc",synon=Seq(),ty="Flag",valueString="",desc="If this is set, then Ct and Freq fields will not be generated to count the number or rate of missing genotypes.",req=false),
           ParamStr(id = "noAlleCalc",synon=Seq(),ty="Flag",valueString="",desc="If this is set, then Ct and Freq fields will not be generated to count allele counts and frequencies.",req=false),
           ParamStr(id = "noHetHomCalc",synon=Seq(),ty="Flag",valueString="",desc="If this is set, then Ct and Freq fields will not be generated to count the number of HomAlt and Het genotypes.",req=false),
           ParamStr(id = "noMultiHetCalc",synon=Seq(),ty="Flag",valueString="",desc="If this is set, then the number of multiallelic heterozygotes will not be counted.",req=false),
           ParamStr(id = "addOtherCountsCalc",synon=Seq(),ty="Flag",valueString="",desc="If this is set, additional optional counts will be added.",req=false),
           
           ParamStr(id = "samplePrintLimit",synon=Seq(),ty="String",valueString="",desc="This limits the number of samples that will be listed in the SAMPLIST fields. This can be useful to reduce file sizes and prevent problems when importing into excel due to overly long fields.",req=false),

           ParamStr(id = "noDepthStats",synon=Seq(),ty="Flag",valueString="",desc="If this is set, depth statistic fields (including total depth, depth quantiles, and hetAB stats) will not be created.",req=false),
           ParamStr(id = "noSampleLists",synon=Seq(),ty="Flag",valueString="",desc="If this is set, then SAMPLIST fields will not be generated.",req=false),
           ParamStr(id = "noSampleCounts",synon=Seq(),ty="Flag",valueString="",desc="If this is set, then sample count and frequency fields will not be generated.",req=false),
           
           ParamStr(id = "expr",synon=Seq(),ty="String",valueString="expr",desc="The variant expression, "+
                                                  "which is a true/false expression using the variant expression syntax.",req=false,defaultValue=None)
         )), category = "General-Purpose Tools"
       ),
       ParamStrSet("filterTags" ,  desc = "This function can be used to remove unwanted INFO or FORMAT fields, "+
                                                  "or remove unwanted samples. This can substantially reduce file sizes.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "FORMAT.keep",synon=Seq(),ty="String",valueString="expr",desc="If this is set, then ALL format fields EXCEPT the ones listed here will be dropped.",req=false),
           ParamStr(id = "FORMAT.drop",synon=Seq(),ty="String",valueString="",desc="IF this is set, then the listed format fields will be dropped.",req=false),
           ParamStr(id = "INFO.keep",synon=Seq(),ty="String",valueString="",desc="If this is set, then ALL info fields EXCEPT the ones listed here will be dropped.",req=false),
           ParamStr(id = "INFO.drop",synon=Seq(),ty="String",valueString="",desc="If this is set, then the listed info fields will be dropped.",req=false),
           ParamStr(id = "SAMPLES.keep",synon=Seq(),ty="String",valueString="",desc="IF this is set, then ALL samples EXCEPT the ones listed here will be dropped.",req=false),
           ParamStr(id = "SAMPLES.drop",synon=Seq(),ty="String",valueString="",desc="If this is set, the listed samples will be dropped.",req=false),
           ParamStr(id = "INFO.rename",synon=Seq(),ty="String",valueString="expr",desc="This is used to rename INFO fields. This should be set to a comma-delimited list of FROM:TO pairs, with each pair separated with a colon.",req=false),
           ParamStr(id = "FORMAT.rename",synon=Seq(),ty="String",valueString="expr",desc="This is used to rename FORMAT fields. This should be set to a comma-delimited list of FROM:TO pairs, with each pair separated with a colon.",req=false)

         )), category = "File Formatting/Conversion"
       ),
       
       // UNIMPLEMENTED:
       /*
        * 
        * Seq[SVcfWalker](new StdVcfConverter(thirdAlleleChar = thirdAlleleChar))
        * UNIMPLEMENTED FUNCTIONS: TODO!
        */
       ParamStrSet("keepVariants" ,  desc = "This function drops variants based on a given true/false expression.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "expr",synon=Seq(),ty="String",valueString="expr",desc="A variant-level expression. See the HELP section on Variant-Level Logical Expressions.",req=true, initParam=true)
         )), category = "Filtering"
       ),
       ParamStrSet("extractRegion" ,  desc = "This function extracts a single region from the VCF. NOTE: the VCF MUST BE SORTED!", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "region",synon=Seq(),ty="String",valueString="chr1:1000-2000",desc="The genomic region to extract.",req=true,initParam = true),
           ParamStr(id = "windowSize",synon=Seq(),ty="Int",valueString="0",desc="The size of the window around the genomic region to extract.",req=false,initParam = true)
         )), category = "Filtering"
       ),
       ParamStrSet("snpSiftAnno" ,  desc = "This function runs a SnpSift anno command. SnpSift's java library has been packaged internally within vArmyKnife and is called directly, producing results identical to a separate snpSift command.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "cmd",synon=Seq(),ty="String",valueString="cmd",desc="A valid SnpSift command. In general you should specify the -info and -name options followed by a VCF file to annotate with. ",req=false)
         )), category = "File/Database Annotation",
         exampleCode = Seq[Seq[String]](
           Seq[String](
             "This example annotates the current VCF file with the AC and AN fields from another VCF file. Note that the annotation VCF file must be sorted and indexed using tabix. "+
             "\n",
             "   varmyknife walkVcf \\\n"+
             "          --fcn \"snpSiftAnno|gnomad|cmd=-info AC,AN -name GNOM_ /path/to/anno/file/gnomad.vcf.gz \"\\\n"+
             "          infile.vcf.gz outfile.vcf.gz\n"),
         )
       ),
       ParamStrSet("snpSiftAnnoMulti" ,  desc = "This function runs several snpSiftAnno commands one after another. See the help for the snpSiftAnno function above. This will be faster than several separate snpSiftAnno function calls. It uses SnpEff/Sift version 4.3t.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "cmds",synon=Seq(),ty="String",valueString="cmds",desc="A semicolon delimited list of valid snpSift commands.",req=false)
         )), category = "File/Database Annotation"
       ),
       
       ParamStrSet("snpSiftDbnsfp" ,  desc = "This function runs the SnpSift dbnsfp command. SnpSift's java library has been packaged internally within vArmyKnife and is called directly, producing results identical to a separate snpSift command. It uses SnpEff/Sift version 4.3t.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "cmd",synon=Seq(),ty="String",valueString="cmd",desc="A valid SnpSift command",req=false)
         )), category = "File/Database Annotation",
         exampleCode = Seq[Seq[String]](
           Seq[String](
             "This example annotates the current VCF file with a DBNSFP database that has been downloaded and prepared by SNPSIFT. "+
             "\n",
             "   varmyknife walkVcf \\\n"+
             "          --fcn \"snpSiftDbnsfp|dbnsfp|cmd=-f genename,cds_strand,refcodon -db /path/to/db/dbNSFP/v3.5a/dbNSFP3.5a_hg19_sorted.txt.gz \"\\\n"+
             "          infile.vcf.gz outfile.vcf.gz\n"),
         )         
       ),
       ParamStrSet("snpEff" ,  desc = "This function runs SnpEff by calling the SnpEff library internally. It uses SnpEff version 4.3t.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "cmd",synon=Seq(),ty="String",valueString="cmd",desc="A valid SnpSift command.",req=false)
         )), category = "File/Database Annotation",
         exampleCode = Seq[Seq[String]](
             Seq[String](
             "varmyknife walkVcf \n"+
             "          --fcn \"snpEff|mySnpEffRun_1|cmd=GRCh37.75 -noout -c snpEff.config -v -noStats -lof -motif -nextprot\" \n"+
             "          infile.vcf.gz outfile.vcf.gz\n")
         )
       ),
       ParamStrSet("snpEffExtract" ,  desc = "This utility is designed to extract information from ANN fields generated by either SNPEFF or VEP. While the ANN field contains a large amount of information, "+
                                             "the structure and organization of this field is often difficult to parse and operate on. "+
                                             "ANN fields are structured as a series of entries each specifying a gene, transcript, and effect. For example, if a "+
                                             "variant causes a missense change in transcript A and causes a splicing change in transcript B then there would be two entries, one for each effect. "+
                                             "This function can extract whatever specific information desired from the ANN-formatted field and filters, collates, and reorganizes it in a way that is easier to use. "+
                                             "The various keep and drop lists allow you to extract or ignore ANN entries based on biotype, effect, or warnings. "+
                                             "The geneList function allows you to specify a gene list, any entries that do not pertain to a gene on that list will be ignored. This can allow you to (for example) create a new field "+
                                             "that lists the effects only for the desired gene(s). This can avoid certain common errors. For example: where one extracts a gene list and then extracts all Loss-of-Function variants and ends up with a "+
                                             "number of variants that have synonymous effect or simply nearby a gene of interest but are also loss-of-function for some other gene which is NOT a gene of interest."+
                                             "", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "annTag",synon=Seq(),ty="String",valueString="tag",desc="A valid ANN formatted field, usually generated by SNPeff.",req=false,defaultValue=Some("ANN")),
              ParamStr(id = "bioTypeKeepList",synon=Seq(),ty="String",valueString="t1,t2,...",desc="A comma delimited list of the transcript biotypes that you want to keep. All other biotypes will be ignored.",req=false),
              ParamStr(id = "effectKeepList",synon=Seq(),ty="String",valueString="t1,t2,...",desc="A comma delimited list of the effect types that you want to keep. All other EFFECT values will be ignored.",req=false),
              ParamStr(id = "warningDropList",synon=Seq(),ty="String",valueString="t1,t2,...",desc="A comma delimited list of warnings. Any entries that include a listed warning will be ignored.",req=false),
              //ParamStr(id = "keepIdx",synon=Seq(),ty="String",valueString="t1,t2,...",desc="",req=false),
              ParamStr(id = "geneList",synon=Seq(),ty="String",valueString="t1,t2,...",desc="If this variant is set, then all operations will be restricted to only the ANN entries that correspond to any gene in the supplied list of genes. This can be useful for extracting only the effect on specific genes of interest.",req=false),
              ParamStr(id = "geneListName",synon=Seq(),ty="String",valueString="myGeneListName",desc="The name you want to give to the given gene list. Should only be used in conjunction with the geneList option.",req=false),
              
              ParamStr(id = "severityList",synon=Seq(),ty="String",valueString="...",desc="Must be a list of severity levels, listed as some combination of effectseverity types delimited with slashes. "+
                                 "Legal types are: HIGH, MODERATE, LOW, and MODIFIER, which are standard SnpEFF effect types, and also: "+
                                 "NS (HIGH and MODERATE), NonNS (LOW and MODIFIER), and ANY (any type).",
                                 req=false, defaultValue = Some("HIGH/MODERATE/LOW")),
              ParamStr(id = "extractFields",synon=Seq(),ty="String",valueString="...",desc="This is a complex multi-part field that allows flexible extraction of "+
                    "information from SnpEff ANN tags. This field must be in the colon-delimited format tagInfix:ANN_idx:description:severityList[:noCollapse]. "+
                    "severityList must be in the same format as the severityList parameter above, but can override the default if desired. "+
                    "ANN_idx must be a slash-delimited list of field indices counting from zero in the ANN tag. "+
                    "The standard ANN field indices are: "+ Seq("allele","effect","impact","geneName","geneID","txType","txID","txBiotype","rank","HGVS.c","HGVS.p","cDNAposition","cdsPosition","proteinPosition","distToFeature","warnings","errors").zipWithIndex.map{ case (a,i) => i+":"+a  }.mkString(",")+" "+
                    "If multiple fields are selected then the output fields will have the format first:second:third:etc. "+
                    "For example, to create two new fields containing a list of all genes for which the current variant has HIGH and MODERATE impact respectively, use the format: "+
                    "myNewField:4:my description:HIGH/MODERATE. " +
                    "This will generate two new fields: myNewField_HIGH and myNewField_MODERATE. Note that if this function as a whole has a mapID set, then "+
                    "both field names will be prefixed by that overall ID."
                    ,req=false),
              //(tagPrefix+svexOutTag+"_",svexIdx,svexFullDesc,svexSevSet, noCollapse)
             ParamStr(id = "geneNameIdx",synon=Seq(),ty="String",valueString="i",desc="This sets the index of the geneName to be used for collating information by gene. By default this is set to 4 which as per the ANN field specification is the \"geneID\" (usually the ensembl ID). If desired this can be set to 3 which is the \"common gene name\" (usually the gene symbol), or even 6 which is the transcriptID (which will cause this tool to perform all operations on the transcript level rather than the gene level. This variable can also be useful if you have a nonstandard ANN-style input.",req=false,defaultValue = Some("4") ),
             ParamStr(id = "biotypeIdx",synon=Seq(),ty="String",valueString="i",desc="This sets the ANN field index for the warning field. As per the specification of the ANN field this should always be set to the default (7), but for certain older versions it may be different.",req=false,defaultValue = Some("7") ),
             ParamStr(id = "warnIdx",synon=Seq(),ty="String",valueString="i",desc="This sets the ANN field index for the warning field. As per the specification of the ANN field this should always be set to the default (15), but for certain older versions it may be different.",req=false,defaultValue = Some("15") )
              //TODO: figure out how to include snpEffVarExtracts!
         )), category = "File/Database Annotation",
         synon=Seq("extractANN"),
         exampleCode = Seq[Seq[String]](
             Seq[String](
             "The following command will extract various useful information from the ANN field. Entries that do not refer to protein coding transcripts will be ignored. "+
             "Entries that refer to effects that are not included in the provided effectKeepList will be ignored. "+
             "Any entries with the listed warnings will be ignored. "+
             "Several types of output fields will be generated for various effect severities. \n"+
             "   GENEEFFECT: This will be a list of geneName:Effect pairs that pass the above filters. \n"+
             "   ENSGID: This will be a list of ensemble gene ID's from any entries that pass the above filters. \n"+
             "   ENSTID: This will be a list of ensemble transcript ID's from any entries that pass the above filters. \n"+
             "   TXCHANGE: These will be a list of TXID:HGVSc transcript change pairs that pass the above filters. \n"+
             "   FIRSTEFFECT: Like the GENEEFFECT fields, this will be a list of geneName:Effect pairs that pass the above filters, but if multiple effects are listed it will only list the first effect.\n"+
             "\n"+             
             "New fields will be created for each of the above and each of the listed effect severities. For example: \n"+
             "   ANNEX_GENEEFFECT_HIGH: This will list only gene:effect pairs that pass the above filters and have severity HIGH.\n"+
             "   ANNEX_GENEEFFECT_MODERATE: This will list only gene:effect pairs that pass the above filters and have severity MODERATE.\n"+
             "   ANNEX_GENEEFFECT_NS: This will list only gene:effect pairs that pass the above filters and have severity HIGH or MODERATE.\n"+
             "and so on...\n"+
             "\n"+
             "varmyknife walkVcf \n"+
             "    --fcn \"snpEffExtract|ANNEX|annTag=ANN|\\\n"+
             "            bioTypeKeepList=protein_coding\\\n"+
             "            effectKeepList=\\\n"+
             "                coding_sequence_variant,inframe_insertion,disruptive_inframe_insertion,\\\n"+
             "                conservative_inframe_insertion,inframe_deletion,disruptive_inframe_deletion,\\\n"+
             "                conservative_inframe_insertion,exon_variant,exon_loss_variant,duplication,\\\n"+
             "                inversion,frameshift_variant,missense_variant,start_retained_variant,\\\n"+
             "                stop_retained_variant,initiator_codon_variant,rare_amino_acid_variant,\\\n"+
             "                splice_acceptor_variant,splice_donor_variant,stop_lost,start_lost,stop_gained,\\\n"+
             "                synonymous_variant,start_retained,splice_region_variant,\\\\n"+
             "                5_prime_UTR_premature,start_codon_gain_variant,\\\n"+
             "                3_prime_UTR_truncation,5_prime_UTR_truncation,\\\n"+
             "                3_prime_UTR_variant,5_prime_UTR_variant,\\\n"+
             "                intron_variant,conserved_intron_variant\\\n"+
             "            warningDropList=WARNING_TRANSCRIPT_INCOMPLETE,WARNING_TRANSCRIPT_MULTIPLE_STOP_CODONS,\\\n"+
             "                            WARNING_TRANSCRIPT_NO_START_CODON,WARNING_TRANSCRIPT_NO_STOP_CODON\\\n"+
             "            extractFields=GENEEFFECT:3/FIRSTEFFECT:set of gene-effect pairs:HIGH/MODERATE/NS:.,\\\n"+
             "               ENSGID:4:Gene ensemble ID:HIGH/NS:.,\\\n"+
             "               ENSTID:6:Affected Transcript ID:HIGH/NS:.,\\\n"+
             "               TXCHANGE:6/9:TranscriptID and HGVSc change:HIGH/NS:.,\\\n"+
             "               FIRSTEFFECT:FIRSTEFFECT:Extracted First Effect:HIGH/MODERATE/LOW/NS/ANY:.|\\\n"+
             "            geneNameIdx=3\\\n"+
             "            severityList=HIGH/MODERATE/NS/LOW\"\\\n"+
             "          infile.vcf.gz outfile.vcf.gz\n")
         )         
       ),
       /*
                           new SnpEffInfoExtract(tagID = params("annTag"),
                                         tagPrefix = params("tagPrefix"),
                                         snpEffBiotypeKeepList = params.get("bioTypeKeepList").map{ _.split(",").toList },
                                         snpEffEffectKeepList  = params.get("effectKeepList").map{ _.split(",").toList },
                                         snpEffWarningDropList = params.get("warningDropList").map{ _.split(",").toList },
                                         //snpEffKeepIdx         = params.get("keepIdx").map{ _.split(",").toList },
                                         geneListTagInfix      = params.getOrElse("geneListName","onList_"),
                                         geneList              = params.get("geneList").map{ _.split(",").toList },
                                         
                                         snpEffFields    = params.get("extractFields").map{ x => x.split(",") },
                                         severityListSet = Some(params("severityList")),
                                         
                                         snpEffGeneNameIdx   = Some(string2int(params("geneNameIdx"))),
                                         snpEffBiotypeIdx    = (string2int(params("biotypeIdx"))),
                                         snpEffWarnIdx       = (string2int(params("warnIdx")))
        */
       
       
       ParamStrSet("snpEffExtractField" ,  desc = "", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "tagPrefix",synon=Seq(),ty="String",valueString="tag",desc="",req=true),
              ParamStr(id = "outputTagPrefix",synon=Seq(),ty="String",valueString="t1,t2,...",desc="",req=false),
              ParamStr(id = "columns",synon=Seq(),ty="String",valueString="t1,t2,...",desc="",req=false),
              ParamStr(id = "desc",synon=Seq(),ty="String",valueString="...",desc="",req=false),
              ParamStr(id = "collapseUniques",synon=Seq(),ty="Flag",valueString="t1,t2,...",desc="",req=false),
              ParamStr(id = "tagSet",synon=Seq(),ty="String",valueString="HIGH,MODERATE,LOW,NS,ANY",desc="",req=false)
         )), category = "File/Database Annotation", hidden = true
       ),
       ParamStrSet("homopolymerRunStats" ,  desc = "This tool adds several new INFO tags that indicate whether the variant is near a homopolymer run, and if so, whether it extends or truncates that run.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "runSize",synon=Seq(),ty="String",valueString="k",desc="The number of repeated bases required to count as a homopolymer run",req=true),
              COMMON_PARAMS("genomeFA")
         )), category = "Genomic Locus Annotation"
       ),
       ParamStrSet("addContextBases" ,  desc = "This function adds several new INFO fields which list the base pairs flanking the variant.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "windowSize",synon=Seq(),ty="String",valueString="k",desc="The number of bases to include in the context window",req=true),
              COMMON_PARAMS("genomeFA")
         )), category = "Genomic Locus Annotation"
       ),//AddTrinucleotideComplexity(tagPrefix : String, genomeFa : String, windowSize : Int)
       ParamStrSet("addTrinucleotideComplexity" ,  desc = "This function adds a new INFO field containing the trinucleotide complexity for the given genomic window around the variant locus, defined as the sum of the squares of the proportions of each 3-bp combination.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "windowSize",synon=Seq(),ty="String",valueString="k",desc="The number of bases to include in the context window",req=true),
              COMMON_PARAMS("genomeFA")
         )), category = "Genomic Locus Annotation"
       ),
       ParamStrSet("gcContext" ,  desc = "This function calculates the fraction of bases within k bases from the variant locus that are G or C. "+
                                         "This can be useful to identify high-GC areas where variant calling and sequencing may be less accurate.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "windowSize",synon=Seq(),ty="String",valueString="k",desc="The number of bases to include in the context window for determining local gc content.",req=true),
              ParamStr(id = "digits",synon=Seq(),ty="String",valueString="int",desc="Number of digits to round to.",req=false, defaultValue = Some("4")),
              COMMON_PARAMS("genomeFA")
         )), category = "Genomic Locus Annotation"
       ),
       ParamStrSet("addVariantIdx" ,  desc = "This function adds a new INFO column with a unique numeric value for each line. Optionally, you can add "+
                                             "a prefix to each ID.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "prefix",synon=Seq(),ty="String",valueString="prefix",desc="Prefix to prepend to the index field.",req=false)
         )),category = "General-Purpose Tools"
       ),//dropNullVariants
       ParamStrSet("addVariantPosInfo" ,  desc = "This function adds a new INFO field in the form: CHROM:START:REF>ALT. This can be useful for "+
                                                 "checking the effects of functions that alter the variant columns. "+
                                                 "For example, you can run this function before and after leftAlignAndTrim to see how "+
                                                 "a variant changes.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )),category = "General-Purpose Tools"
       ),//dropNullVariants
       ParamStrSet("dropNullVariants" ,  desc = "This drops variants if they appear beyond the endpoint of the genome builds chromosome. Certain tools will "+
                                                "occasionally create variants like this and they will crash many other functions like left-align-and-trim or GC-content calculations, etc.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              COMMON_PARAMS("genomeFA")
         )),category = "Filtering"
       ),//dropVariantsBeyondChromEnd
       ParamStrSet("dropVariantsBeyondChromEnd" ,  desc = "This function drops all lines with no alt alleles ('.' in the ALT column), or lines where the ALT allele is identical to the REF. "+
                                                "Note: you must split multiallelics first. See the 'splitMultiallelics' function.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )),category = "Filtering"
       ),//
       ParamStrSet("dropSpanIndels" ,  desc = "This function drops Spanning indel lines ('*' alleles). Note: you must split multiallelics first!", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )),category = "Filtering"
       ),
       
       ParamStrSet("checkReferenceMatch" ,  desc = "This function compares the REF column to the genomic reference and makes sure that they actually match. "+
                                                   "If mismatches are found, a warning will be thrown. In addition, a new INFO field will be added to the VCF that will be a "+
                                                   "simple integer field that will equal 1 if and only if the REF matches the reference, and 0 otherwise.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              COMMON_PARAMS("genomeFA")
         )),category = "Genomic Locus Annotation"
       ),
       ParamStrSet("sanitize" ,  desc = "This function strips out additional optional fields in the INFO lines which are technically valid according to the VCF specification, but that will be rejected by certain applications including GATK.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              
         )),category = "File Formatting/Conversion"
       ),
       ParamStrSet("calcBurdenCounts" ,  desc = "This function generates the .", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "geneTag",synon=Seq(),ty="String",valueString="k",desc="This is the INFO tag that indicates the geneID. It can be a comma-delimited list.",req=true),
              //
              ParamStr(id = "snpEffAnnField",synon=Seq(),ty="String",valueString="k",desc="NOT IMPLEMENTED",req=false, hidden=true),
              ParamStr(id = "snpEffGeneField",synon=Seq(),ty="String",valueString="k",desc="NOT IMPLEMENTED",req=false, hidden=true),
              ParamStr(id = "snpEffVariantTypes",synon=Seq(),ty="String",valueString="k",desc="NOT IMPLEMENTED",req=false, hidden=true),
              //
              ParamStr(id = "expr",synon=Seq(),ty="String",valueString="k",desc="This is a true/false variant expression. Variants will only be counted towards a burden test if they pass this expression. This can be used to generate several burden count tables with different filtering strategies in a single run.",req=false),
              ParamStr(id = "sampleSet",synon=Seq(),ty="String",valueString="k",desc="This is a list of samples to include. Samples not on this list will be ignored.",req=false),
              ParamStr(id = "group",synon=Seq(),ty="String",valueString="k",desc="This is a sample group to include. Samples that are not in this sample group will be ignored. Note that this requires the groupFile variable to be set.",req=false),
              ParamStr(id = "inputGT",synon=Seq(),ty="String",valueString="k",desc="This is the FORMAT column to use as the genotype column.",req=false),
              
           COMMON_PARAMS("groupFile"),COMMON_PARAMS("superGroupList"),
           
           ParamStr(id = "countFileID",synon=Seq(),ty="String",valueString="k",desc="If multiple output count files are desired, you can specify which functions output to which count file using this parameter. Note that each file must be created using a --burdenCountsFile parameter, with the form fileID:/path/to/file.txt",req=false)

         )),category = "Data/Table Extraction"
       ),
       ParamStrSet("calcBurdenCountsByGroups" ,  desc = "", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "geneTag",synon=Seq(),ty="String",valueString="k",desc="This is the INFO tag that indicates the geneID. It can be a comma-delimited list.",req=true),
              ParamStr(id = "groups",synon=Seq(),ty="String",valueString="k",desc="This is a comma delimited list of sample groups, taken from the groupFile.",req=true),

              ParamStr(id = "snpEffAnnField",synon=Seq(),ty="String",valueString="k",desc="NOT IMPLEMENTED",req=false, hidden=true),
              ParamStr(id = "snpEffGeneField",synon=Seq(),ty="String",valueString="k",desc="NOT IMPLEMENTED",req=false, hidden=true),
              ParamStr(id = "snpEffVariantTypes",synon=Seq(),ty="String",valueString="k",desc="NOT IMPLEMENTED",req=false, hidden=true),
              //
              ParamStr(id = "expr",synon=Seq(),ty="String",valueString="k",desc="This is a true/false variant expression. Variants will only be counted towards a burden test if they pass this expression. This can be used to generate several burden count tables with different filtering strategies in a single run.",req=false),
              ParamStr(id = "sampleSet",synon=Seq(),ty="String",valueString="k",desc="This is a list of samples to include. Samples not on this list will be ignored.",req=false),
              ParamStr(id = "inputGT",synon=Seq(),ty="String",valueString="k",desc="This is the FORMAT column to use as the genotype column.",req=false),
              
           COMMON_PARAMS("groupFile"),COMMON_PARAMS("superGroupList"),
           
           ParamStr(id = "countFileID",synon=Seq(),ty="String",valueString="k",desc="If multiple output count files are desired, you can specify which functions output to which count file using this parameter. Note that each file must be created using a --burdenCountsFile parameter, with the form fileID:/path/to/file.txt",req=false)

         )),category = "Data/Table Extraction"
       ),
       
       ParamStrSet("calcBurdenMatrix" ,  desc = "This utility creates a matrix file with ", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "geneTag",synon=Seq(),ty="String",valueString="k",desc="",req=true),
              ParamStr(id = "expr",synon=Seq(),ty="String",valueString="k",desc="",req=false),
              ParamStr(id = "sampleSet",synon=Seq(),ty="String",valueString="k",desc="",req=false),
              ParamStr(id = "group",synon=Seq(),ty="String",valueString="k",desc="",req=false),
              ParamStr(id = "inputGT",synon=Seq(),ty="String",valueString="k",desc="",req=false),
              
              ParamStr(id = "geneList",synon=Seq(),ty="String",valueString="k",desc="",req=false),
              ParamStr(id = "geneListFile",synon=Seq(),ty="String",valueString="k",desc="",req=false),
              ParamStr(id = "printFullGeneList",synon=Seq(),ty="flag",valueString="k",desc="",req=false),

              ParamStr(id = "pathwayList",synon=Seq(),ty="String",valueString="A:a,b,c,d;B:c,d,e,f;...",desc="",req=false),
              
             COMMON_PARAMS("groupFile"),COMMON_PARAMS("superGroupList"),
           
             ParamStr(id = "outfile",synon=Seq(),ty="String",valueString="k",desc="The output matrix file path.",req=true)

         )),category = "Data/Table Extraction"
       ),
       
       
       
       
       ParamStrSet("concordanceCaller" ,  desc = "....", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "callerNames",synon=Seq(),ty="String",valueString="k",
                                               desc="Comma delimited list of caller IDs, used in the callerSet INFO fields and the names of the output GT fields. "+
                                                    "By default, callers will simply be named C1,C2,..."+
                                                    "",req=false),
              ParamStr(id = "priority",synon=Seq(),ty="String",valueString="k",
                                               desc="Comma delimited list of caller IDs. "+
                                                    "The list of caller IDs in order of descending priority."+
                                                    "",req=false),
              ParamStr(id = "gtDecisionMethod",synon=Seq(),ty="String",valueString="k",
                                               desc="The merge rule for calculating ensemble-merged GT and AD tags. Valid options are priority, prioritySkipMissing, and majority_priorityOnTies. Default is simple priority."+
                                                    ""+
                                                    "",req=false),
                                                    //gtDecisionMethod
              ParamStr(id = "ignoreSampleIds",synon=Seq(),ty="flag",valueString="k",desc="If this flag is set, then sample IDs will be ignored and each VCF will be assumed to have the "+
                                                                                         "exact same samples in the exact same order. Use at your own risk.",req=false),
              ParamStr(id = "ignoreSampleOrder",synon=Seq(),ty="flag",valueString="k",desc="If this flag is set, then the sample IDs will be used to match up the "+
                                                                                           "different VCFs, and the samples may be in different orders in the different files.",req=false),
              //TODO:
              ParamStr(id = "mergeGenotypeField_ADstyle",synon=Seq(),ty="String",valueString="k",
                                               desc=""+
                                                    ""+
                                                    "",req=false,hidden=true),
              ParamStr(id = "mergeGenotypeField_simple",synon=Seq(),ty="String",valueString="k",
                                               desc=""+
                                                    ""+
                                                    "",req=false,hidden=true),
              ParamStr(id = "mergeGenotypeField_GTstyle",synon=Seq(),ty="String",valueString="k",
                                               desc=""+
                                                    ""+
                                                    "",req=false,hidden=true)

                                                    
                                                    
                                                    
         )),category = "Concordance Caller"
       ),
       /*
        * UNTESTED:
        */
       
       ParamStrSet("fixFirstBaseMismatch" ,  desc = "This utility will extend indels in which the first base is not a matching base. Certain variant processing tools "+
                                                    "may use blanks to mark indels or may not begin combination insertion-deletion variants with a matching base "+
                                                    "(this latter case is technically legal VCF, but some tools may throw errors). "+
                                                    ""+
                                                    "", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "windowSize",synon=Seq(),ty="Int",valueString="k",desc="Sets the size of the sliding window used. Problems may occur if you have variants longer than this window size. Default is 200bp.",req=false),
              COMMON_PARAMS("genomeFA")
         )), category = "Variant Formatting/Conversion"
       ),
      ParamStrSet("leftAlignAndTrim" ,  desc =      "This utility performs the exact same operations as GATK leftAlignAndTrim. It trims excess bases and shifts ambiguously-positioned indels to their leftmost possible position. "+
                                                    "This can assist in ensuring that variants are consistantly represented which is critical in matching indels between files. "+
                                                    "IMPORTANT: if there are multiallelic variants then they MUST be split apart before this step. You can use the splitMultiAllelics function to do this."+
                                                    ""+
                                                    "", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "windowSize",synon=Seq(),ty="Int",valueString="k",desc="Sets the size of the sliding window used. Problems may occur if you have variants longer than this window size. Default is 200bp.",req=false),
              COMMON_PARAMS("genomeFA")
         )), category = "Variant Formatting/Conversion"
       ),
      ParamStrSet("fixSwappedRefAlt" ,  desc = "This utility searches for cases where the REF and ALT bases are swapped.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              COMMON_PARAMS("genomeFA")
         )), category = "Variant Formatting/Conversion"
       ), 
      ParamStrSet("splitMultiAllelics" ,  desc = "This utility takes any multiallelic variables and splits them apart so that each line contains only one ALT allele. "+
                                                 "There are two options for how this will be carried out. The default creates several new FORMAT fields. "+
                                                 "TODO explain more! "+
                                                 ""+
                                                 "...Thus after the split the "+
                                                 "multiallelics will have an ALT field of the form A,* and the "+
                                                 "GT field and AD field will use this coding. Thus if a sample has one of the "+
                                                 "other alt alleles then ", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "useStarAlle",synon=Seq(),ty="Flag",valueString="",desc="If this flag is used, the asterisk allele will be used "+
                                                                                    "as a placeholder for all other alleles. See the explanation above."+
                                                                                    "",req=false),
              ParamStr(id = "treatOtherAsRef",synon=Seq(),ty="Flag",valueString="",desc=" "+
                                                                                    ""+
                                                                                    "",req=false),                                                                  

         )), category = "Variant Formatting/Conversion"
       ),
      ParamStrSet("rmDup" ,  desc = "This utility detects identical variant lines and deletes any excess beyond the first. NOTE: VCF FILE MUST BE SORTED!", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              
         )), category = "Filtering"
       ),
      ParamStrSet("markDup" ,  desc = "This map function will detect duplicate variant lines and add two new INFO fields: "+
                                                    "mapID_CT and mapID_IDX. The CT will indicate how many duplicates were found "+
                                                    "matching the current variant, and the IDX will number each duplicate with a unique identifier, counting from 0. All nonduplicates will "+
                                                    "be marked with CT=1 and IDX=0. VCF FILE MUST BE SORTED!", 
                                                    synon = Seq("mkDup"),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              
         )), category = "General-Purpose Tools"
       ),
       ParamStrSet("mergeDup" ,  desc = "Merges duplicated lines. NOTE: REQUIRES THE VCF TO BE SORTED. NOTE: DOES NOT WORK ON GENOTYPES."+
                                        "NOTE: Splitting multiallelics and left-align-and-trim are also require for it to work properly with multiallelics and indels respectively.", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](           
         )), category = "General-Purpose Tools"
       ),
       
       /*
        *             duplicateTag.toSeq.map{ dt => {
              new DuplicateStats(dt)
            }}, category = "Formatting/Conversion"
        */
       
      ParamStrSet("fixDotAltIndels" ,  desc = "...", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              COMMON_PARAMS("genomeFA")
         )), category = "Variant Formatting/Conversion"
       ),
      ParamStrSet("getLocusDepthFromWig" ,  desc = "This utility takes a .wig file (aka a wiggle file) and annotates each variant with the depth indicated in the wiggle file for the variant site.", 
           (DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "wigFile",synon=Seq(),ty="String",valueString="depthfile.wig.gz",desc="The input wiggle file.",req=false),
              ParamStr(id = "desc",synon=Seq(),ty="String",valueString="...",desc="The description for the new INFO field, to be included in the INFO line.",req=false)
         )), category = "File/Database Annotation"
       ),
      ParamStrSet("addDistToFeature" ,  desc = "This utility takes a simple 2-column text file. the first column must be the chrom ID and the second column must be position. "+
                                               "A new integer info field will be added that is equal to the distance to the nearest position in the file. "+
                                               "If there is no listed position on the given chromosome then the info field will be missing.", 
           (DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "file",synon=Seq(),ty="String",valueString="filename.txt",desc="The input text file. Must have 2 columns, chrom and pos",req=false),
              ParamStr(id = "desc",synon=Seq(),ty="String",valueString="...",desc="The description for the new INFO field, to be included in the INFO line.",req=false)
         )), category = "File/Database Annotation"
       ),
       /*
        * 
        * Seq[SVcfWalker](new StdVcfConverter(thirdAlleleChar = thirdAlleleChar))
        * UNIMPLEMENTED FUNCTIONS: TODO!
        */
       ParamStrSet("convertToStdVcf" ,  desc = "Certain utilities (eg GATK) do not allow certain optional features of the VCFv4.2 format standard "+
                                                "(For example: additional tag-pairs in the INFO or FORMAT header lines). This function strips out this additional metadata."+
                                                "",
                  synon = Seq("convertToStandardVcf"),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )), category = "File Formatting/Conversion"
       ),
       
       ParamStrSet("addAltSequence" ,  desc = "",
                  synon = Seq("addAltSeq"),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "windowSize",synon=Seq(),ty="String",valueString="k",desc="The number of flanking bases to include on each side of the alt sequence.",req=false,defaultValue=Some("10")),
              COMMON_PARAMS("genomeFA")
         )), category = "Variant Formatting/Conversion"
       ),
       ParamStrSet("dropGenotypeData" ,  desc = "This utility drops the entire genotype table, including all columns from the FORMAT column on.",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )), category = "File Formatting/Conversion"
       ),
       ParamStrSet("addDummyGenotypeColumn" ,  desc = "This utility adds a new genotype column and FORMAT column, containing a simple GT field that is always 0/1. Some utilities will refuse to process files without genotype data or will ignore VCF lines with no alt genotypes.",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )), category = "File Formatting/Conversion"
       ),
       ParamStrSet("dropSymbolicAlleles" ,  desc = "This utility strips all symbolic alleles. See the VCF v4.2 specification for more information on what those are and what they are used for. Many older tools will return errors if fed symbolic alleles.",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )), category = "Filtering"
       ), //dropVariantsWithNs
       ParamStrSet("dropInvalidAlleleLines" ,  desc = "This utility strips all symbolic alleles. See the VCF v4.2 specification for more information on the definition of valid allele columns. Some tools return invalid alleles, and many tools will crash when fed such data.",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )), category = "Filtering"
       ), //dropVariantsWithNs
       
       
       ParamStrSet("dropVariantsWithNs" ,  desc = "This utility drops variants if they contain Ns in either the REF or ALT columns.",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )), category = "Filtering"
       ),
       
       ParamStrSet("copyColumnToInfo" ,  desc = "This utility copies the contents of one of the VCF columns to a new INFO field. Note that some columns allow "+
                                                "characters that are not allowed in INFO fields, such as equal signs. Any illegal characters will be automatically replaced with underscores.",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
               ParamStr(id = "columnID",synon=Seq(),ty="String",valueString="FILTER|ID|REF|ALT|etc",desc="",req=true)
         )), category = "File Formatting/Conversion"
       ),
       ParamStrSet("copyInfoToColumn" ,  desc = "This utility copies the contents of an INFO field to one of the the other VCF columns.",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
               ParamStr(id = "infoColumn",synon=Seq(),ty="String",valueString="myInfoColumn",desc="",req=true),
               ParamStr(id = "columnID",synon=Seq(),ty="String",valueString="FILTER|ID|REF|ALT|POS|CHROM|QUAL|etc",desc="",req=true)
         )), category = "File Formatting/Conversion"
       ),
       ParamStrSet("copyInfoToGeno" ,  desc = "This utility copies the contents of one of the INFO fields into the genotype level.",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
               ParamStr(id = "info",synon=Seq(),ty="String",valueString="infoFieldToCopy",desc="",req=true,initParam=true)
           )), category = "File Formatting/Conversion"
       ),
       ParamStrSet("copyAllInfoToGeno" ,  desc = "This utility copies the contents of ALL info fields plus the FILTER column into the genotype FORMAT columns. This can be useful for preserving sample-level information stored in the INFO column of a single-sample VCF prior to merging across multiple samples.",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](

           )), category = "File Formatting/Conversion"
       ),
       ParamStrSet("fixInfoFieldMetadata" ,  desc = "This function swaps out fields from an INFO header line, allowing you to change the Number, desc, etc. This can be useful when a field has invalid metadata, or for adding descriptions and documentation to your fields.",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
                 ParamStr(id = "field",synon=Seq(),ty="String",valueString="myInfoColumn",desc="",req=true),
                 ParamStr(id = "Type",synon=Seq("TYPE","type"),ty="String",valueString=".",desc="",req=false),
                 ParamStr(id = "Number",synon=Seq("number","NUMBER"),ty="String",valueString=".",desc="",req=false),
                 ParamStr(id = "desc",synon=Seq("Desc","DESC"),ty="String",valueString=".",desc="",req=false),
                 ParamStr(id = "removeMeta",synon=Seq(),ty="Flag",valueString=".",desc="",req=false)
           )), category = "File Formatting/Conversion"
       ),
       ParamStrSet("fixFormatFieldMetadata" ,  desc = "This function swaps out fields from an INFO header line, allowing you to change the Number, desc, etc. This can be useful when a field has invalid metadata, or for adding descriptions and documentation to your fields.",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
                 ParamStr(id = "field",synon=Seq(),ty="String",valueString="myInfoColumn",desc="",req=true),
                 ParamStr(id = "Type",synon=Seq("TYPE","type"),ty="String",valueString=".",desc="",req=false),
                 ParamStr(id = "Number",synon=Seq("number","NUMBER"),ty="String",valueString=".",desc="",req=false),
                 ParamStr(id = "desc",synon=Seq("Desc","DESC"),ty="String",valueString=".",desc="",req=false),
                 ParamStr(id = "removeMeta",synon=Seq(),ty="Flag",valueString=".",desc="",req=false)
           )), category = "File Formatting/Conversion"
       ),
       ParamStrSet("mergeSamplesIntoSingleColumn" ,  desc = "This utility copies multiple samples into a single merged sample.",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
               ParamStr(id = "suffixes",synon=Seq(),ty="String",valueString="Sample,Suffixes",desc="Must be a comma delimited list with a short name for each sample column.",req=true),
               ParamStr(id = "sampID",synon=Seq(),ty="String",valueString="newSampID",desc="The name for the new sample column",req=true)
           )), category = "File Formatting/Conversion"
       ),
       //,
      //ParamStrSet("dropVariantsWithNs" ,  desc = "Removes all variants with N's in the REF or ALT sequences. Some callers will produce variants like this, and some tools will crash if given such variants.", 
      //     (DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
      //   ))
      // )

       
       //TODO:
       //convertROAOtoAD
       
       
       
       
       
       //add more params to the ParamStrSet:
       //    hidden, deprecated, category, priority
       
       //Add more fcn:
       
       //makeFirstBaseMatch
       //fixSwappedRefAlt
       //leftAlignAndTrim
       //splitMultiAllelics
       //fixDotAltIndels
       //rmDup
       //ConcordanceCaller?
       //dropVariantsWithNs, 
       //wiggles
       
       //copyColumnToINFO, copyINFOtoGENO, copyGENOtoINFO
       //DONE - unPhaseAndSortGenotypes 

       
     ).map{ pss => {
       (pss.mapType,pss)
     }}
     
     val MAP_FUNCTIONS  : Map[String,ParamStrSet] = MAP_FUNCTIONS_SEQ.toMap
     
     val MAP_ID_MAP : Map[String,String] = MAP_FUNCTIONS.flatMap{ case (mapID,pss) => {
       pss.nameSet.map{ nn => {
         (nn,mapID)
       }}
     }}.toMap;
     
     /*
} else if(mapType == "homopolymerRunStats"){
               Some(HomopolymerRunStats(tagPrefix=params("tagPrefix"),genomeFa=params("genomeFA"), lenThreshold = params("runSize").toInt))
             } else if(mapType == "addContextBases"){
               Some(AddContextBases(tagPrefix=params("tagPrefix"),genomeFa=params("genomeFA"), len = params("windowSize").toInt))
             } else if(mapType == "gcContext"){
               Some(localGcInfoWalker(tagPrefix=params("tagPrefix"),windows=params("windowSize").split(",").toSeq.map{_.toInt},genomeFa=params("genomeFA"), roundDigits = params.get("digits").map{_.toInt}))
             
              Some(new calcBurdenCountsWalker(tagID=params("mapID"),
                  geneTag=params("geneTag"),
                  filterExpressionString=params.getOrElse("expr","TRUE"),
                  sampSubset=params.get("sampleSet").map{ x => x.split(",").toSet},
                  sampGroup=params.get("group"),
                  gtTag=params("inputGT"), 
                  out=burdenWriter.get, 
                  groupFile = params.get("groupFile"), 
                  groupList = None, 
                  superGroupList  = params.get("superGroupList")))



    def MAPFUNCTIONS_logicManualRaw : Seq[(Option[String],String)] = 
      Seq[(Option[String],String)](
                                  (Some("Variant Map Functions"),
                                        "Variant Map Functions are a set of tools that perform operations on a variant set "+
                                        "one variant at a time. Unlike other parameters and operations, map functions are performed in the order "+
                                        "that they appear in the command line, after all other operations have been carried out (excluding output ops)."+
                                        ""),
                                  (Some("BASIC SYNTAX:"),
                                        "--FCN functionName|ID|param1=p1|param2=p2|..."
                                  ),
                                  (Some(""),
                                        "")
                                  (None," "+
                                        " "+
                                        " "+
                                        " "
                                  )
      );
     
    def MAPFUNCTIONS_getManualString() : String = {
      indentTitle : Int = 4, indentBlock : Int = 8,
                              indentFirst:Int= 8
    }*/
   
     
   val MAPFUNCTIONS_USERMANUALBLOCKS : Seq[internalUtils.commandLineUI.UserManualBlock] = Seq[internalUtils.commandLineUI.UserManualBlock](
       internalUtils.commandLineUI.UserManualBlock(title=Some("VARIANT OPERATIONS"),
                                                   lines = Seq("","Variant Operations or Variant Map Functions are a set of sub-utilities that perform operations on a variant set "+
                                                               "one variant at a time. When more than one function is specified in a run, these functions are performed in the order "+
                                                               "that they appear in the command line, after all other operations have been carried out (excluding output ops)."+
                                                               "",
                                                               "Basic Syntax:",
                                                               "    --FCN functionName|ID|param1=p1|param2=p2|...",
                                                               "",
                                                               "functionName: one of the functions listed below.",
                                                               "ID: The ID for this particular operation run. "+
                                                               "This will be used in warning/error messages and in the "+
                                                               "header metadata. It is recommended that this ID be unique. "+
                                                               "In some functions this ID is used to determine the INFO field names.",
                                                               "param1,param2,...: Most functions take one or more parameters. Parameters are "+
                                                               "specified with the format: param=value, where param is the parameter ID listed in the "+
                                                               "documentation below."), level = 1, indentTitle = 0, indentBlock = 2, indentFirst = 2),
       internalUtils.commandLineUI.UserManualBlock(title=Some("Available Operations"),
                                                   lines = Seq(""), level = 2,indentTitle = 2, indentBlock = 2, indentFirst = 2)
   ) ++ MAP_FUNCTIONS_SEQ.filter{ case (fcnID,mf) => {
     ! mf.hidden
   }}.toSeq.sortBy{ case (fcnID,mf) => {
     MAPFUNCTIONS_GROUPS.indexOf( mf.category );
   }}.map{ case (fcnID,mf) => {
     (fcnID,mf.category,mf);
   }}.foldLeft( ("",Seq[internalUtils.commandLineUI.UserManualBlock]()) ){ case ((prevCat,soFar),(fcnID,currCat,mf)) => {
     val sf = if( soFar.length == 0 || prevCat != currCat ){
        soFar :+ internalUtils.commandLineUI.UserManualBlock(lines=Seq(),title=Some(currCat),level=5);
     } else {
       soFar
     }
      val fcnTitleLine =  internalUtils.commandLineUI.UserManualBlock(title=Some( fcnID ),subtitle = Some(mf.desc),
                                                   lines = Seq(), level = 3, indentTitle = 4, indentBlock = 12, indentFirst=4, 
                                                   mdCaret=true,mdBold=true)
      val examples = mf.exampleCode.zipWithIndex.flatMap{ case (exampleCodeSeq,idx) => {
        Seq[internalUtils.commandLineUI.UserManualBlock](
            internalUtils.commandLineUI.UserManualBlock(lines = Seq("###### Example "+(idx+1)+":"),
                mdIndentBlock = 0, mdIndentFirst = 0,
                hiddenInPlain = true)
        ) ++
        exampleCodeSeq.map{ exampleCodeString => {
            internalUtils.commandLineUI.UserManualBlock(lines = exampleCodeString.split("\n").map{x => x.trim()}.toSeq,
                mdIndentBlock = 8, mdIndentFirst = 4,
                hiddenInPlain = true)
        }} ++
        Seq[internalUtils.commandLineUI.UserManualBlock](
            internalUtils.commandLineUI.UserManualBlock(lines = Seq("###### End Example"),
                mdIndentBlock = 0, mdIndentFirst = 0,
                hiddenInPlain = true)
        )
      }}
      (currCat,sf ++ Seq(fcnTitleLine) ++ mf.pp.filter{ pp => ! pp.hidden }.map{ pp => {
        internalUtils.commandLineUI.UserManualBlock(lines = Seq(""+pp.id+": "+
                                                            pp.desc +"("+pp.ty+""+ { if(pp.req){
                                                              ", required)"
                                                            } else {
                                                              pp.defaultDesc.map{ dfd => {
                                                                ", default="+dfd+")"
                                                              }}.getOrElse(
                                                                 pp.defaultValue.map{ dfv => {
                                                                   ", default="+dfv+")"
                                                                 }}.getOrElse(")")
                                                              )
                                                            }}), indentTitle = 4, indentBlock = 12, indentFirst=8,mdCaret=true)
      }}.padTo(1,internalUtils.commandLineUI.UserManualBlock(lines = Seq("(This function takes no parameters)"), indentTitle = 4, indentBlock = 12, indentFirst=8,mdCaret=true))++
      examples)
    }}._2
   /*

     


   }}.flatMap{ case (fcnID,mf) => {
      val fcnTitleLine =  internalUtils.commandLineUI.UserManualBlock(title=Some( fcnID ),subtitle = Some(mf.desc),
                                                   lines = Seq(), level = 3, indentTitle = 4, indentBlock = 12, indentFirst=4, 
                                                   mdCaret=true,mdBold=true)
      val examples = mf.exampleCode.zipWithIndex.flatMap{ case (exampleCodeSeq,idx) => {
        Seq[internalUtils.commandLineUI.UserManualBlock](
            internalUtils.commandLineUI.UserManualBlock(lines = Seq("###### Example "+(idx+1)+":"),
                mdIndentBlock = 0, mdIndentFirst = 0,
                hiddenInPlain = true)
        ) ++
        exampleCodeSeq.map{ exampleCodeString => {
            internalUtils.commandLineUI.UserManualBlock(lines = exampleCodeString.split("\n").map{x => x.trim()}.toSeq,
                mdIndentBlock = 8, mdIndentFirst = 4,
                hiddenInPlain = true)
        }} ++
        Seq[internalUtils.commandLineUI.UserManualBlock](
            internalUtils.commandLineUI.UserManualBlock(lines = Seq("###### End Example"),
                mdIndentBlock = 0, mdIndentFirst = 0,
                hiddenInPlain = true)
        )
      }}
      Seq(fcnTitleLine) ++ mf.pp.filter{ pp => ! pp.hidden }.map{ pp => {
        internalUtils.commandLineUI.UserManualBlock(lines = Seq(""+pp.id+": "+
                                                            pp.desc +"("+pp.ty+""+ { if(pp.req){
                                                              ", required)"
                                                            } else {
                                                              pp.defaultDesc.map{ dfd => {
                                                                ", default="+dfd+")"
                                                              }}.getOrElse(
                                                                 pp.defaultValue.map{ dfv => {
                                                                   ", default="+dfv+")"
                                                                 }}.getOrElse(")")
                                                              )
                                                            }}), indentTitle = 4, indentBlock = 12, indentFirst=8,mdCaret=true)
      }}.padTo(1,internalUtils.commandLineUI.UserManualBlock(lines = Seq("(This function takes no parameters)"), indentTitle = 4, indentBlock = 12, indentFirst=8,mdCaret=true))++
      examples
   }}*/
     
   def MAPFUNCTIONS_getBlockStringManual : String = MAPFUNCTIONS_USERMANUALBLOCKS.filter{ umb => ! umb.hiddenInPlain }.map{ umb => {
     umb.getBlockString()
   }}.mkString("\n")+"\n";
   def MAPFUNCTIONS_getMarkdownStringManual : String = MAPFUNCTIONS_USERMANUALBLOCKS.map{ umb => {
     umb.getMarkdownString();
   }}.mkString("\n")+"\n";
   
      /*
       ***********************************************************************************************************************************************************************************************************************************************************************************************************
       ***********************************************************************************************************************************************************************************************************************************************************************************************************
       ***********************************************************************************************************************************************************************************************************************************************************************************************************
       ***********************************************************************************************************************************************************************************************************************************************************************************************************
       * 
       * 
       * 
       * 
       * 
       * 
       * 
       * 
       * 
       ***********************************************************************************************************************************************************************************************************************************************************************************************************
       ***********************************************************************************************************************************************************************************************************************************************************************************************************
       ***********************************************************************************************************************************************************************************************************************************************************************************************************
       ***********************************************************************************************************************************************************************************************************************************************************************************************************
       */
      
      def getSVcfMapFunction( variantMapFunction : List[String], 
                             chromList : Option[List[String]],
                             burdenWriterMap : Map[String,internalUtils.fileUtils.WriterUtil] ,
                             groupFile : Option[String],
                             superGroupList : Option[String],
                genomeFA : Option[String],
                calcStatGtTag : String
 
      ) : Seq[SVcfWalker] = {
          /*val burdenWriterMap = burdenCountsFile.map{ bcf => 
            val cc = bcf.split("[:]");
            if(cc.length == 2){
              (cc(0),openWriterSmart(cc(1)));
            } else if(cc.length > 2){
              error("Error: burdenCountsFile must be at most 2 elements seperated by a colon: fileID and filePath. Or just filepath");
              ("",openWriterSmart(""))
            } else {
              ("",openWriterSmart(bcf))
            }
            
          }.toMap;*/
            val (sampleToGroupMap,groupToSampleMap,groups) : (scala.collection.mutable.AnyRefMap[String,Set[String]],
                           scala.collection.mutable.AnyRefMap[String,Set[String]],
                           Vector[String]) = getGroups(groupFile, None, superGroupList);
            
           val ssseq = variantMapFunction.toSeq.map{ vmfString => {
              val fullcells = vmfString.split("(?<!\\\\)[|]",-1).map{ xx => xx.replaceAll("\\\\[|]","|") }.map{ s => s.trim() }
              
              //if(fullcells.length < 2){
              //  error("variantMapFunction must be composed of at least 2 |-delimited elements: the mapFunctionType and the walker ID. In most cases it will also require additional parameters. Found: [\""+fullcells.mkString("\"|\"")+"\"]");
              //}
              val rawMapType = fullcells.head;
              val mapType = MAP_ID_MAP(rawMapType);
              val mapID = fullcells.lift(1).getOrElse("")
              if(mapID.contains('=')){
                error("Error in mapFunction: second parameter must be the ID! Instead found: \""+mapID+"\"");
              }
              
              val sc = fullcells.drop(2)
              //if( ! MAP_FUNCTIONS.contains(mapType)){
              //  error("FCN \"+mapTYPE+\" NOT FOUND!");
              //}
                if( ! MAP_FUNCTIONS.contains(mapType)){
                  error("FCN \""+mapType+"\" NOT FOUND!");
                }
              val tagPrefix = if(mapID == "") "" else mapID + "_";
              val defaultFcnParams = Map[String,String](
                    ("filterTag",tagPrefix+"FILTER"),
                    ("inputGT",calcStatGtTag),
                    ("outputGT",tagPrefix+"FILTER_GT"),
                    ("inputGtNewName",tagPrefix+"PREFILTER_GT"),
                    ("desc","(no description provided)")
                ) ++ groupFile.toSeq.map{ gf => {
                  ("groupFile",gf)
                }}.toMap ++ superGroupList.toSeq.map{ sg => {
                  ("superGroupList",sg)
                }}.toMap ++ genomeFA.toSeq.map{ gfa => {
                  ("genomeFA",gfa)
                }}
              
                val ppss = ParsedParamStrSet(sc, MAP_FUNCTIONS(mapType))
                ppss.set("mapID",mapID);
                ppss.set("mapType",mapType);
                ppss.set("tagPrefix",tagPrefix);
                
                ppss.setDefaults(defaultFcnParams)
                (mapType, ppss)
           }}
      
           val svwseq : Seq[SVcfWalker] = ssseq.flatMap{ case (mapType,params) => {
             
             if(mapType == "tagVariantsExpression"){
                warning("Warning: This function is DEPRECATED! Use function \"addInfo\" instead!","DEPRECATED_FUNCTION_tagVariantsFunction",-1)
               Some( VcfExpressionTag(expr = params("expr"), tagID = params("mapID"), tagDesc = params("desc")) );
             } else if(mapType == "tagVariantsFunction"){
                warning("Warning: This function is DEPRECATED! Use function \"addInfo\" instead!","DEPRECATED_FUNCTION_tagVariantsFunction",-1)
                val paramTags = params.get("params").map{ pp => {
                  pp.split(",").toSeq;
                }}.getOrElse(Seq[String]())
                
                Some(new AddFuncTag(func=params("func"),newTag=params("mapID"),paramTags=paramTags,digits=params.get("digits").map{d => string2int(d)},desc=Some(params("desc"))));

             } else if(mapType == "addInfo"){
                val rawFunc = params("func").split("[(]").head;
                val paramTags = params("func").split("[(]",2).lift(1).map{ pp => {
                  if(pp.trim().last != ')'){
                    error("Error: hanging open paren in string: "+params("func"));
                  }
                  //pp.init.split(",").toSeq.map{ _.trim() }
                  pp.trim().init.split(",(?![^()]*+\\))").toSeq.map{ _.trim() };
                }} match {
                  case Some(rp) => {
                    rp;
                  }
                  case None => {
                    params.get("params").map{ pp => {
                      //pp.split(",").toSeq;
                      pp.trim().split(",(?![^()]*+\\))").toSeq.map{ _.trim() };
                    }}.getOrElse(Seq[String]())
                  }
                }
                Some(new AddFunctionTag(func=rawFunc,newTag=params("mapID"),paramTags=paramTags,digits=None,desc=Some(params("desc")),sampleToGroupMap=sampleToGroupMap));
             } else if(mapType == "calculateMatchMatrix" ){
             /*
                     ParamStrSet("calculateMatchMatrix" ,  desc = "....", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "file",synon=Seq(),ty="String",valueString="output.table.txt",desc="",req=true),
           ParamStr(id = "gtTag",synon=Seq(),ty="String",valueString="",desc="The genotype FORMAT field.",req=false,defaultValue = Some("GT")),
           ParamStr(id = "matchCutoff",synon=Seq(),ty="Float",valueString="x",desc="matches below this threshold will not be written to file.",req=false, defaultValue=Some("0.5"))
         )), category = "Data/Table Extraction",
       ),
              * CountMatchMatrix(matchFile : String, gtTag : String = "GT", matchPctCutoff : Double = 0.5 ) 
              */
                Some(CountMatchMatrix(matchFile=params.get("file").getOrElse("match.matrix.txt") , gtTag=params.get("gtTag").getOrElse("GT"), matchPctCutoff=string2double(params.get("matchCutoff").getOrElse("0.5")) ))
             } else if(mapType == "extractFormatMatrix" ){
             /*
                     ParamStrSet("calculateMatchMatrix" ,  desc = "....", 
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "file",synon=Seq(),ty="String",valueString="output.table.txt",desc="",req=true),
           ParamStr(id = "gtTag",synon=Seq(),ty="String",valueString="",desc="The genotype FORMAT field.",req=false,defaultValue = Some("GT")),
           ParamStr(id = "matchCutoff",synon=Seq(),ty="Float",valueString="x",desc="matches below this threshold will not be written to file.",req=false, defaultValue=Some("0.5"))
         )), category = "Data/Table Extraction",
       ),
              * CountMatchMatrix(matchFile : String, gtTag : String = "GT", matchPctCutoff : Double = 0.5 ) 
              *   case class ExtractFormatMatrix(matchFile : String, gtTag : String = "GT", infoFields : Seq[String] = Seq(), 
              *   longForm : Boolean = false, noVarInfo : Boolean = false) extends SVcfWalker {
              * 
              */
                Some(ExtractFormatMatrix(matchFile=params.get("file").getOrElse("gt.matrix.txt") , 
                                         gtTag=params.get("gtTag").getOrElse("GT"), 
                                         infoFields=params.get("infoFields").map{ ff => ff.split(",").toSeq }.filter{ ff => ff != "." }.getOrElse(Seq()),
                                         longForm=params.isSet("longForm"),
                                         noVarInfo=params.isSet("noVarInfo")
                                         ))
             
             //longForm : Boolean = false, noVarInfo
             } else if(mapType == "addFormat"){
                val rawFunc = params("func").split("[(]").head;
                val paramTags = params("func").split("[(]",2).lift(1).map{ pp => {
                  if(pp.trim().last != ')'){
                    error("Error: hanging open paren in string: "+params("func"));
                  }
                  pp.init.split(",").toSeq.map{ _.trim() }
                }} match {
                  case Some(rp) => {
                    rp;
                  }
                  case None => {
                    params.get("params").map{ pp => {
                      pp.split(",").toSeq;
                    }}.getOrElse(Seq[String]())
                  }
                }
                Some(new AddFunctionFormat(func=rawFunc,newTag=params("mapID"),paramTags=paramTags,desc=Some(params("desc")),sampleToGroupMap=sampleToGroupMap));
                
               //AddFunctionFormat(func : String, newTag : String, paramTags : Seq[String], desc : Option[String] = None) 
             } else if(mapType == "tally"){
                val rawFunc = params("func").split("[(]").head;
                val paramTags = params("func").split("[(]",2).lift(1).map{ pp => {
                  if(pp.trim().last != ')'){
                    error("Error: hanging open paren in string: "+params("func"));
                  }
                  pp.init.split(",").toSeq.map{ _.trim() }
                }} match {
                  case Some(rp) => {
                    rp;
                  }
                  case None => {
                    params.get("params").map{ pp => {
                      pp.split(",").toSeq;
                    }}.getOrElse(Seq[String]())
                  }
                }
                Some(new RunTally(func=rawFunc,newTag=params("mapID"),paramTags=paramTags,sampleToGroupMap=sampleToGroupMap));
                
                /*
                        ParamStrSet("tally" ,  desc = "This is a set of functions that takes various counts and totals across the whole VCF.", 
           synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "func",synon=Seq(),ty="String",valueString="func",desc="",req=true,initParam = true),
           ParamStr(id = "params",synon=Seq(),ty="String",valueString="p1,p2,...",desc="Input parameters.",req=false,hidden=true)
         )), category = "Variant Annotation"
       ),
                 */
                
             } else if(mapType == "genotypeFilter"){
                Some( FilterGenotypesByStat(
                   filter = params("expr"), 
                   filterTag = params("filterTag"),
                   gtTag = params("inputGT"),
                   rawGtTag = params("inputGtNewName"),
                   noRawGt = params.isSet("inputGtNewName"),
                   newGTTag = params("outputGT"),
                   groupFile = params.get("groupFile"), 
                   groupList = None, 
                   superGroupList  = params.get("superGroupList")
                ))
             } else if(mapType == "genotypeSelect"){
                Some( SelectGenotypesByStat(
                   filter = params("expr"), 
                   gtTagA = params("inputGTifTRUE"),
                   gtTagB = params("inputGTifFALSE"),
                   newGTTag = params("outputGT"),
                   missingString = params.get("missingString"),
                   groupFile = params.get("groupFile"), 
                   groupList = None, 
                   superGroupList  = params.get("superGroupList")
                ))
             } else if(mapType == "unPhaseAndSortGenotypes"){
                 Some( FilterTags(
                     unPhaseAndSortGenotypes = params.get("inputGT").map{s => s.split(",").toList }
                  ))
             } else if(mapType == "genotypeExpression"){
                error("variantMapFunction TYPE: \""+mapType+"\" is NOT YET IMPLEMENTED!");
                None
            // } else if(mapType == "keepVariantsExpression"){
            //    error("variantMapFunction TYPE: \""+mapType+"\" is NOT YET IMPLEMENTED!");
            //    None
             } else if(mapType == "sampleReorder"){
               val sampleOrd = (params.get("sampleOrdering") match {
                 case Some(s) => Some( s.split(",").toList );
                 case None => params.get("sampleOrderingFile").map{ getLines(_).toList }
               }).getOrElse(List[String]());
               Some( new ReorderSamples(sampleOrdering = sampleOrd, sort = params.isSet("alphabetical")) )
               //              Seq[SVcfWalker]( new ReorderSamples(sampleOrdering = inputSampleOrdering.getOrElse(List[String]()), sort = inputSampleOrderingAlphabetical) )
               //None
             } else if(mapType == "tagBedFile"){
               //AddTxBedFile(bedFile = bedFile, tag =t, bufferDist = string2int(bufferDist), desc =desc, chromList = chromList,style=style);
/*
 *            (DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
           ParamStr(id = "file",synon=Seq(),ty="String",valueString="mybed.bed.gz",desc="",req=true),
           ParamStr(id = "desc",synon=Seq(),ty="String",valueString="",desc="",req=false,defaultValue = Some("No desc provided")),
           ParamStr(id = "buffer",synon=Seq(),ty="Integer",valueString="x",desc="",req=false),
           ParamStr(id = "style",synon=Seq(),ty="String",valueString="Either +, -, or s",desc="",req=false)
 */
               Some( AddTxBedFile(
                   bedFile = params("file"),
                   tag = params("mapID"),
                   bufferDist = string2int(params("buffer")),
                   desc = params("desc"),
                   chromList = chromList,
                   style = params("style")
               ))
               
             } else if(mapType == "sampleCounts"){
                val vcfCodes : VCFAnnoCodes = VCFAnnoCodes(CT_INFIX = params("tagPrefix")+"_")
                Some( SAddGroupInfoAnno(groupFile = params.get("groupFile"),
                                                groupList = None,
                                                superGroupList  = params.get("superGroupList"), 
                                                chromList = chromList,
                                                noMultiAllelics = true,
                                                tagFilter = None,
                                                tagPreFiltGt = None,
                                                GTTag = params("inputGT"),
                                                vcfCodes = vcfCodes,
                                                addAlle = ! params.isSet("noAlleCalc"), addCounts = ! params.isSet("noCountsCalc"), addFreq = ! params.isSet("noFreqCalc"), addMiss = ! params.isSet("noMissCalc"),
                                                addHetHom = ! params.isSet("noHetHomCalc"), addMultiHet = ! params.isSet("noMultiHetCalc"),
                                                expr=params.get("expr")
                                                ))
             } else if(mapType == "sampleLists"){
                Some(AddAltSampLists(tagGT = params("inputGT"),
                             outputTagPrefix = params("mapID")+"_SAMPLIST_" ,
                             printLimit = params.get("samplePrintLimit").map{ string2int(_) },
                             groupFile = params.get("groupFile"), groupList = None, superGroupList = params.get("superGroupList"),
                             expr = params.get("expr")
                            ))
             } else if(mapType == "depthStats"){
                Some(AddStatDistributionTags(tagAD = params.get("inputAD"), 
                                            tagGT = params("inputGT"), 
                                            tagDP = params.get("inputDP"),
                                            tagSingleCallerAlles = None,
                                            outputTagPrefix= params("mapID")+"_",
                                            variantStatExpression = None,
                                            restrictToGroup = params.get("restrictToGroup"),
                                                groupFile = params.get("groupFile"),
                                                groupList = None,
                                                superGroupList  = params.get("superGroupList")
                ))
             } else if(mapType == "calcStats"){
               
               (if(params.isSet("noDepthStats")){
                 None
               } else {
                Some(AddStatDistributionTags(tagAD = params.get("inputAD"), 
                                            tagGT = params("inputGT"), 
                                            tagDP = params.get("inputDP"),
                                            tagSingleCallerAlles = None,
                                            outputTagPrefix= params("mapID")+"_",
                                            variantStatExpression = None
                ))
               }).toSeq ++
               (if(params.isSet("noSampleLists")){
                 None
               } else {
                Some(AddAltSampLists(tagGT = params("inputGT"),
                             outputTagPrefix = params("mapID")+"_SAMPLIST_" ,
                             printLimit = params.get("samplePrintLimit").map{ string2int(_) },
                             groupFile = params.get("groupFile"), groupList = None, superGroupList = params.get("superGroupList"),
                             expr = params.get("expr")
                            ))
               }).toSeq ++
               (if(params.isSet("noSampleCounts")){
                 None
               } else {
                val vcfCodes : VCFAnnoCodes = VCFAnnoCodes(CT_INFIX = params("mapID")+"_")
                Some( SAddGroupInfoAnno(groupFile = params.get("groupFile"),
                                                groupList = None,
                                                superGroupList  = params.get("superGroupList"), 
                                                chromList = chromList,
                                                noMultiAllelics = true,
                                                tagFilter = None,
                                                tagPreFiltGt = None,
                                                GTTag = params("inputGT"),
                                                vcfCodes = vcfCodes,
                                                addAlle = ! params.isSet("noAlleCalc"), addCounts = ! params.isSet("noCountsCalc"), addFreq = ! params.isSet("noFreqCalc"), addMiss = ! params.isSet("noMissCalc"),
                                                addHetHom = ! params.isSet("noHetHomCalc"), addMultiHet = ! params.isSet("noMultiHetCalc"),
                                                addOtherCountsCalc = params.isSet("addOtherCountsCalc"),
                                                expr=params.get("expr")
                                                ))
               }).toSeq
               
             } else if(mapType == "filterTags"){
                 val keepGeno = params.get("FORMAT.keep").map{ _.split(",").toList }
                 val keepInfo = params.get("INFO.keep").map{ _.split(",").toList }
                 val keepSamp = params.get("SAMPLES.keep").map{ _.split(",").toList }
                 val dropGeno = params.get("FORMAT.drop").map{ _.split(",").toList }.toList.flatten
                 val dropInfo = params.get("INFO.drop").map{ _.split(",").toList }.toList.flatten
                 val dropSamp = params.get("SAMPLES.drop").map{ _.split(",").toList }.toList.flatten
                 
                 val renameInfo = params.get("INFO.rename").map{ _.split(",").toList }
                 val renameGeno = params.get("FORMAT.rename").map{ _.split(",").toList }

                 Some( FilterTags(
                     keepGenotypeTags = keepGeno,
                     dropGenotypeTags = dropGeno,
                     keepInfoTags = keepInfo,
                     dropInfoTags = dropInfo,
                     dropAsteriskAlleles = false,
                     keepSamples = keepSamp,
                     dropSamples = dropSamp,
                     alphebetizeHeader = false,
                     renameInfoTags = renameInfo,
                     renameGenoTags = renameGeno
                  ))
             } else if(mapType == "keepVariants"){
                Some(VcfExpressionFilter(filterExpr = params("expr")))
             } else if(mapType == "extractRegion"){
                Some(VcfExtractRegionFromSorted(region = params("region"), windowSize = params.get("windowSize").map{ string2int(_)}  ))
             } else if(mapType == "snpSiftAnno"){
                Some(SnpSiftAnnotater(params("mapID"),params("cmd")))
             } else if(mapType == "snpSiftAnnoMulti"){
                Some(SnpSiftAnnotaterMulti( params("cmds").split(";").zipWithIndex.map{ case (cmd,ii) => ("multiSift."+ii,cmd.trim()) } ))
                //SnpSiftAnnotaterMulti(cmdTriples : Seq[(String,String)])
             } else if(mapType == "snpSiftDbnsfp"){
                Some(SnpSiftDbnsfp(params("mapID"),params("cmd")))
             } else if(mapType == "snpEff"){
                Some(SnpEffAnnotater(params("mapID"),params("cmd"),params("mapID")))
             } else if(mapType == "homopolymerRunStats"){
               Some(HomopolymerRunStats(tagPrefix=params("tagPrefix"),genomeFa=params("genomeFA"), lenThreshold = params("runSize").toInt))
             } else if(mapType == "addContextBases"){
               Some(AddContextBases(tagPrefix=params("tagPrefix"),genomeFa=params("genomeFA"), len = params("windowSize").toInt))
             } else if(mapType == "addTrinucleotideComplexity"){
               //AddTrinucleotideComplexity(tagPrefix : String, genomeFa : String, windowSize : Int)
               Some(AddTrinucleotideComplexity(tagPrefix=params("mapID"),genomeFa=params("genomeFA"),windowSize=params("windowSize").toInt))
             } else if(mapType == "gcContext"){
               Some(localGcInfoWalker(tagPrefix=params("tagPrefix"),windows=params("windowSize").split(",").toSeq.map{_.toInt},genomeFa=params("genomeFA"), roundDigits = params.get("digits").map{_.toInt}))
             } else if(mapType == "convertChromNames"){
               //Seq[SVcfWalker](ChromosomeConverter(chromDecoder = icd, fromCol= inputChromDecoderFromCol, toCol = inputChromDecoderToCol))
               /*
                ChromosomeConverterAdv(chromDecoder : String, 
                 fromToColumnNames : Option[(String,String)] = None,
                 fromToIdx : Option[(String,String)] = None,
                 hasTitleColumn : Boolean = true,
                       quiet : Boolean = false)
                */
               Some(ChromosomeConverterAdv(chromDecoder = params("file"),
                                           fromToColumnNames = params.get("columnNames").map{ s => (s.split(",")(0),s.split(",")(1)) },
                                           fromToIdx = params.get("columnIdx").map{ s => (s.split(",")(0),s.split(",")(1)) },
                                           skipFirstRow = params.isSet("skipFirstRow")));
             } else if(mapType == "convertSampleNames"){
               Some(SampleRenameAdv(decoder = params("file"),
                                           fromToColumnNames = params.get("columnNames").map{ s => (s.split(",")(0),s.split(",")(1)) },
                                           fromToIdx = params.get("columnIdx").map{ s => (s.split(",")(0),s.split(",")(1)) },
                                           skipFirstRow = params.isSet("skipFirstRow")));
             } else if(mapType == "sanitize"){
               //error("NOT YET IMPLEMENTED!");
               //None;
               Some(new SanitizeVcf());
             
             } else if(mapType == "snpEffExtract"){
               /*
                  
  class SnpEffInfoExtract(tagID : String = "ANN", 
                          tagPrefix : String = "ANNEX_",
                          geneList : Option[List[String]] = None,
                          snpEffBiotypeKeepList : Option[List[String]] = None,
                          snpEffEffectKeepList : Option[List[String]] = None,
                          snpEffWarningDropList : Option[List[String]] = None,
                          snpEffKeepIdx : Option[List[String]] = None,
                          geneListName : Option[String] = None,
                          snpEffVarExtract : List[String] = List[String](),
                          snpEffInfoExtract : List[String] = List[String](),
                          geneListTagInfix : String = "onList_",
                          snpEffBiotypeIdx : Int = 7,
                          snpEffWarnIdx : Int = 15,
                          snpEffFieldLen : Int = 16,
                          snpEffFields : Option[List[String]] = None,
                          snpEffGeneNameIdx : Option[Int] = None,
                          severityListSet : Option[String] = None
                          ) 
                */
               
               
               
               Some(
                   new SnpEffInfoExtract(tagID = params("annTag"),
                                         tagPrefix = params("tagPrefix"),
                                         snpEffBiotypeKeepList = params.get("bioTypeKeepList").map{ _.split(",").toList },
                                         snpEffEffectKeepList  = params.get("effectKeepList").map{ _.split(",").toList },
                                         snpEffWarningDropList = params.get("warningDropList").map{ _.split(",").toList },
                                         //snpEffKeepIdx         = params.get("keepIdx").map{ _.split(",").toList },
                                         geneListTagInfix      = params.getOrElse("geneListName","onList_"),
                                         geneList              = params.get("geneList").map{ _.split(",").toList },
                                         
                                         snpEffVarExtract    = params.get("extractFields").map{ x => x.split(",").toList }.getOrElse(List()),
                                         severityListSet = Some(params("severityList")),
                                         
                                         snpEffGeneNameIdx   = Some(string2int(params("geneNameIdx"))),
                                         snpEffBiotypeIdx    = (string2int(params("biotypeIdx"))),
                                         snpEffWarnIdx       = (string2int(params("warnIdx")))
                                         
                       )
               )
             } else if(mapType == "snpEffExtractField"){
                //error("variantMapFunction TYPE: \""+mapType+"\" NOT YET IMPLEMENTED!");

                Some(
                   new SnpEffExtractElement(
                       tagPrefix = params("tagPrefix"),
                       tagPrefixOutput = params.get("outputTagPrefix"),
                       fieldInfix = params("mapID"),
                       columnIx = params("columns").split(",").map{_.toInt}.toList,
                       desc = params("desc"),
                       collapseUniques = params.isSet("collapseUniques"),
                       tagSet = params.getOrElse("tagSet","HIGH,MODERATE,LOW,NS,ANY").split(",").toSeq
                   )
                )
             } else if(mapType == "checkReferenceMatch"){
               //checkReferenceMatch
               Some(new internalUtils.GatkPublicCopy.CheckReferenceMatch(genomeFa = params("genomeFA"), infotag = params("mapID")));
             } else if(mapType == "addVariantIdx"){
                //val (tagString,idxPrefix) = (addVariantIdx.get.split(",").head, addVariantIdx.get.split(",").lift(1) )
                Seq[SVcfWalker](new AddVariantIdx(tag = params("mapID"),idxPrefix = params.get("prefix")))
             } else if(mapType == "addVariantPosInfo"){
                //val (tagString,idxPrefix) = (addVariantIdx.get.split(",").head, addVariantIdx.get.split(",").lift(1) )
                Seq[SVcfWalker](new AddVariantPosInfoWalker(params("mapID")))
             } else if(mapType == "calcBurdenMatrix"){
               //error("NOT YET IMPLEMENTED!")
               
              //ParamStr(id = "geneListFile",synon=Seq(),ty="String",valueString="k",desc="",req=false),
              //ParamStr(id = "printFullGeneList",synon=Seq(),ty="flag",valueString="k",desc="",req=false),
              val geneList  = params.get("geneList").map{ g => {
                Some( g.split("[,]").toSeq ++ params.get("geneListFile").map{ gf => {
                  getLinesSmartUnzip(gf).toSeq
                }}.getOrElse(Seq()) )
              }}.getOrElse(
                params.get("geneListFile").map{ gf => {
                  getLinesSmartUnzip(gf).toSeq
                }}
              )
               
              /*
               * sampleToGroupMap,groupToSampleMap,groups
               */
              val (a,b,c) = if( params.get("groupFile") == groupFile & params.get("superGroupList") == superGroupList ){
                (sampleToGroupMap,groupToSampleMap,groups)
              } else { 
                  getGroups(params.get("groupFile"), None, params.get("superGroupList"));
              }
              
              Some(new calcBurdenMatrixWalker(tagID=params("mapID"),
                  geneTag=params("geneTag"),
                  filterExpressionString=params.getOrElse("expr","TRUE"),
                  sampSubset=params.get("sampleSet").map{ x => x.split(",").toSet},
                  sampGroup=params.get("group"),
                  gtTag=params("inputGT"), 
                  outfile=params("outfile"), 
                   sampleToGroupMap=a,groupToSampleMap=b,groups=c,
                  geneList = geneList,
                  pathwayList = params.get("pathwayList").map{ g => g.split("[;]").toSeq }.getOrElse(Seq()),
                  printFullGeneList = params.isSet("printFullGeneList")
              ) )
               
               
               
                    /*  ParamStrSet("calcBurdenMatrix" ,  desc = "....", 
           (DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
              ParamStr(id = "geneTag",synon=Seq(),ty="String",valueString="k",desc="",req=true),
              ParamStr(id = "expr",synon=Seq(),ty="String",valueString="k",desc="",req=false),
              ParamStr(id = "sampleSet",synon=Seq(),ty="String",valueString="k",desc="",req=false),
              ParamStr(id = "group",synon=Seq(),ty="String",valueString="k",desc="",req=false),
              ParamStr(id = "inputGT",synon=Seq(),ty="String",valueString="k",desc="",req=false),
              
              ParamStr(id = "geneList",synon=Seq(),ty="String",valueString="k",desc="",req=true),
              ParamStr(id = "pathwayList",synon=Seq(),ty="String",valueString="A=a:b:c:d,B=c:d:e:f",desc="",req=true),
              
             COMMON_PARAMS("groupFile"),COMMON_PARAMS("superGroupList"),
           
             ParamStr(id = "countFileID",synon=Seq(),ty="String",valueString="k",desc="If multiple output count files are desired, you can specify which functions output to which count file using this parameter. Note that each file must be created using a --burdenCountsFile parameter, with the form fileID:/path/to/file.txt",req=false)
*/
               
             } else if(mapType == "calcBurdenCounts"){
               
              val writerID = params.getOrElse("countFileID","");
              if(! burdenWriterMap.contains(writerID)){
                error("Error: countfile not specified! You must specify a countfile using --burdenCountsMap ("+writerID+")");
              }
              val (a,b,c) = if( params.get("groupFile") == groupFile & params.get("superGroupList") == superGroupList ){
                (sampleToGroupMap,groupToSampleMap,groups)
              } else { 
                  getGroups(params.get("groupFile"), None, params.get("superGroupList"));
              }
              Some(new calcBurdenCountsWalker(tagID=params("mapID"),
                  geneTag=params("geneTag"),
                  filterExpressionString=params.getOrElse("expr","TRUE"),
                  sampSubset=params.get("sampleSet").map{ x => x.split(",").toSet},
                  sampGroup=params.get("group"),
                  gtTag=params("inputGT"), 
                  out=burdenWriterMap( writerID ), 
                  sampleToGroupMap=a,groupToSampleMap=b,groups=c))

                /*
                 * 
              val params = cbc.split(",");
              val tagID = params(0);
              val geneTag = params(1);
              val filterExpressionString = params.find( pp => pp.startsWith("keepVariantsExpression=")).map{pp => pp.drop( "keepVariantsExpression=".length )}.getOrElse("TRUE");
              val sampSubset = params.find( pp => pp.startsWith("samples=")).map{pp => pp.drop( "samples=".length ).split("[|]").toSet};
              val sampGroup  = params.find( pp => pp.startsWith("group=")).map{pp => pp.drop( "group=".length )}
              val gtTag = params.find( pp => pp.startsWith("gtTag=")).map{pp => pp.drop( "gtTag=".length )}.getOrElse("GT");
              new calcBurdenCountsWalker(tagID=tagID,geneTag=geneTag,filterExpressionString=filterExpressionString,sampSubset=sampSubset,sampGroup=sampGroup,gtTag=gtTag, out=burdenWriter.get, groupFile = groupFile, groupList = None, superGroupList  = superGroupList)
                */
             } else if(mapType == "calcBurdenCountsByGroups"){
               
              val writerID = params.getOrElse("countFileID","");
              if(! burdenWriterMap.contains(writerID)){
                error("Error: countfile not specified! You must specify a countfile using --burdenCountsMap ("+writerID+")");
              }
              val (a,b,c) = if( params.get("groupFile") == groupFile & params.get("superGroupList") == superGroupList ){
                (sampleToGroupMap,groupToSampleMap,groups)
              } else { 
                  getGroups(params.get("groupFile"), None, params.get("superGroupList"));
              }
              Some(new calcBurdenCountsSetWalker(tagID=params("mapID"),
                  geneTag=params("geneTag"),
                  filterExpressionString=params.getOrElse("expr","TRUE"),
                  sampGroups=params("groups").split(",").toSeq,
                  gtTag=params("inputGT"), 
                  out=burdenWriterMap( writerID ), 
                  sampleToGroupMap=a,groupToSampleMap=b,groups=c))
                  
             } else if(mapType == "fixFirstBaseMismatch"){
               // Some(HomopolymerRunStats(tagPrefix=params("tagPrefix"),genomeFa=params("genomeFA"), lenThreshold = params("runSize").toInt))
               Some(internalUtils.GatkPublicCopy.FixFirstBaseMismatch(genomeFa = params("genomeFA"),windowSize = string2int( params.getOrElse("windowSize","200"))));
               
             } else if(mapType == "leftAlignAndTrim"){
               Some( internalUtils.GatkPublicCopy.LeftAlignAndTrimWalker(genomeFa = params("genomeFA"),windowSize =  string2int( params.getOrElse("windowSize","200")) , useGatkLibCall = false) )
             } else if(mapType == "fixSwappedRefAlt"){
               Some(internalUtils.GatkPublicCopy.FixRefAltSwaps( genomeFa = params("genomeFA"), changeTag = Some("RefAltSwap"), warnTag  = Some("BadRefAlle")))
             } else if(mapType == "splitMultiAllelics"){
               if( params.isSet("useStarAlle") ){
                   Seq( SSplitMultiAllelics(vcfCodes = DEFAULT_VCF_CODES, clinVarVariants = false, splitSimple = false) )
               } else {
                 Seq(SSplitMultiAllelics2(vcfCodes = DEFAULT_VCF_CODES))
                 
                  /* Seq( SSplitMultiAllelics(vcfCodes = DEFAULT_VCF_CODES, clinVarVariants = false, splitSimple = false),
                        new StdVcfConverter(cleanHeaderLines = false, 
                           cleanInfoFields =false, 
                           cleanMetaData = false,
                           collapseStarAllele = true,
                           deleteUnannotatedFields  = false)
//                          thirdAlleleChar : Option[String] = None,
//                         multAlleInfoTag : Option[String] = None)
                    )*/
               }
             } else if(mapType == "rmDup"){
               Some(new RemoveDuplicateLinesWalker())
             } else if(mapType == "fixDotAltIndels"){
               Some( new internalUtils.GatkPublicCopy.FixDotAltVcfLines(genomeFa = params("genomeFA") ) )
             } else if(mapType == "dropNullVariants"){
               Some(SFilterNonVariantWalker())
             } else if(mapType == "dropVariantsBeyondChromEnd"){
               Some( internalUtils.GatkPublicCopy.SFilterVariantsOffChromosomeEnd(genomeFa=params("genomeFA"), true) )
             } else if(mapType == "dropSpanIndels"){
               Some(new DropSpanIndels())
             } else if(mapType == "getLocusDepthFromWig"){
               val wigFile = params("wigFile")
               if( ! (new File(wigFile)).exists() ){
                 error("ERROR: Wiggle file: "+wigFile+" does not exist!");
               }
               Some( new addWiggleDepthWalker(wigFile = wigFile, tag = params("mapID"), desc = params.getOrElse("desc","noDesc")) )
               
               //addDistToFeature(file : String, tag : String, desc : String)
             } else if(mapType == "addDistToFeature"){
               val file = params("file")
               if( ! (new File(file)).exists() ){
                 error("ERROR: File: "+file+" does not exist!");
               }
               Some( new addDistToFeature(file = file, tag = params("mapID"), desc = params.getOrElse("desc","noDesc")) )
             } else if(mapType == "dropVariantsWithNs"){
               Some(new DropNs());
             } else if(mapType == "markDup"){
                Some(new DuplicateStats(params("mapID")))
             } else if(mapType == "mergeDup"){
                Some(new DuplicateMerge(params("mapID")))
                
             } else if(mapType == "convertToStdVcf"){
               Some( new StdVcfConverter(thirdAlleleChar = None) )

               
             } else if(mapType == "addAltSequence"){
                
               Some(AddAltSequence(tagString=params.get("mapID"),genomeFa=params("genomeFA"), len = string2int( params("windowSize") )))
             } else if(mapType == "dropGenotypeData"){
               Some(StripGenotypeData(addDummyGenotypeColumn=false))
             } else if(mapType == "addDummyGenotypeColumn"){
               Some(StripGenotypeData(addDummyGenotypeColumn=true))
             } else if(mapType == "dropSymbolicAlleles"){
                Some(new FilterSymbolicAlleleLines());
                
                //dropInvalidAlleleLines
             } else if(mapType == "dropInvalidAlleleLines"){
                Some(new FilterInvalidAlleleLines());
                
             } else if(mapType == "copyColumnToInfo"){
               val qual = if(params("columnID") == "QUAL") Some(params("mapID")) else None
               val filt = if(params("columnID") == "FILTER") Some(params("mapID")) else None
               val idtag = if(params("columnID") == "ID") Some(params("mapID")) else None
               val ref   = if(params("columnID") == "REF") Some(params("mapID")) else None
               val alt   = if(params("columnID") == "ALT") Some(params("mapID")) else None

               Some(CopyFieldsToInfo( qualTag = qual, filterTag = filt, idTag = idtag, refTag = ref, altTag=alt ))
               
             } else if( mapType == "mergeSamplesIntoSingleColumn" ){
        /*ParamStrSet("mergeSamplesIntoSingleColumn" ,  desc = "This utility copies multiple samples into a single merged sample.",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
               ParamStr(id = "prefixes",synon=Seq(),ty="String",valueString="Sample Prefixes",desc="",req=true,initParam=true)
           )), category = "File Formatting/Conversion"
       ),*/
               val prefixes = params("suffixes").split(",");
               val sampID = params("sampID")
               
               Some( MergeSamplesIntoSingleColumn( prefixes=prefixes,sampID=sampID));
               
             } else if(mapType == "copyAllInfoToGeno"){
               
               Some( CopyAllToGeno() );
               
             } else if(mapType == "copyInfoToGeno"){

               val geno = params("mapID");
               val info = params("info");
               
               Some( CopyInfoToGeno(info=info,geno=geno) );
             } else if(mapType == "fixInfoFieldMetadata"){
               
               val field = params("field");
               val ty = params.get("Type")
               val num = params.get("Number")
               val desc = params.get("desc")
               val removeMeta = params.isSet("dropMetadata")
               
               Some(new FixInfoFieldMetadata(field = field,num=num,desc=desc,ty=ty,removeMeta=removeMeta))
               //FixInfoFieldMetadata( field : String, num : Option[String], desc : Option[String], ty : Option[String] )
             } else if(mapType == "fixFormatFieldMetadata"){
               val field = params("field");
               val ty = params.get("Type")
               val num = params.get("Number")
               val desc = params.get("desc")
               val removeMeta = params.isSet("dropMetadata")
               
               Some(new FixFormatFieldMetadata(field = field,num=num,desc=desc,ty=ty,removeMeta=removeMeta))
               
               /*
                * CopyFieldsToInfo(qualTag : Option[String], filterTag : Option[String], idTag : Option[String], copyFilterToGeno : Option[String],copyQualToGeno : Option[String],
                              copyInfoToGeno : List[String])
                */
               
               /*

       ParamStrSet("fixInfoFieldMetadata" ,  desc = "This function swaps out fields from an INFO header line, allowing you to change the Number, desc, etc. This can be useful when a field has invalid metadata, or for adding descriptions and documentation to your fields.",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
                 ParamStr(id = "infoField",synon=Seq(),ty="String",valueString="myInfoColumn",desc="",req=true),
                 ParamStr(id = "Type",synon=Seq("TYPE","type"),ty="String",valueString=".",desc="",req=false),
                 ParamStr(id = "Number",synon=Seq("number","NUMBER"),ty="String",valueString=".",desc="",req=false),
                 ParamStr(id = "desc",synon=Seq("Desc","DESC"),ty="String",valueString=".",desc="",req=false),
           )), category = "File Formatting/Conversion"
       ),
       ParamStrSet("fixFormatFieldMetadata" ,  desc = "This function swaps out fields from an INFO header line, allowing you to change the Number, desc, etc. This can be useful when a field has invalid metadata, or for adding descriptions and documentation to your fields.",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
                 ParamStr(id = "infoColumn",synon=Seq(),ty="String",valueString="myInfoColumn",desc="",req=true),
                 ParamStr(id = "Type",synon=Seq("TYPE","type"),ty="String",valueString=".",desc="",req=false),
                 ParamStr(id = "Number",synon=Seq("number","NUMBER"),ty="String",valueString=".",desc="",req=false),
                 ParamStr(id = "desc",synon=Seq("Desc","DESC"),ty="String",valueString=".",desc="",req=false),
            )), category = "File Formatting/Conversion"
       ),
                
                       ParamStrSet("copyAltToInfo" ,  desc = "",
                  synon = Seq("addAltSeq"),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )), category = "File Formatting."
       ),
       ParamStrSet("dropGenotypeData" ,  desc = "",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )), category = "File Formatting."
       ),
       ParamStrSet("addDummyGenotypeColumn" ,  desc = "",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )), category = "File Formatting."
       ),
       ParamStrSet("dropSymbolicAlleles" ,  desc = "",
                  synon = Seq(),
           pp=(DEFAULT_MAP_PARAMS ++ Seq[ParamStr](
         )), category = "File Formatting."
       ),
                
                */
               
             } else {
                error("variantMapFunction TYPE: \""+mapType+"\" DOES NOT EXIST!");
                None
             }
           }}
          
            svwseq;
        
        
        
      }
      
      
      
}









 


















