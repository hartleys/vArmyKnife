<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
		<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="chrome=1">
		<title>vArmyKnife: Variant Army Knife Toolkit</title>

		<link rel="stylesheet" href="stylesheets/styles.2.css">
		<link rel="stylesheet" href="stylesheets/pygment_trac.css">
		<script src="javascripts/scale.fix.js"></script>
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

		<!--[if lt IE 9]>
		<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
</head>

<body>
<div class="wrapper">


<header>
			<h1><a href="index.html">vArmyKnife</a></h1>
			<p>Variant Army Knife</p>
</header>


<section>
<h1>vArmyKnife</h1>

<blockquote>
  <p>Version 3.1.1 (Updated Tue Feb 11 15:23:49 EST 2020)</p>

<p>(<a href="../index.html">back to main</a>) (<a href="index.html">back to java-utility help</a>)</p>
</blockquote>

</section> <h2>Help for vArmyKnife command "walkVcf"</h2> <section>

</section> <h2>USAGE:</h2> <section>

<p>GENERAL SYNTAX:</p>

<pre><code>varmyknife [java_options]  [options] infile outfile
OR
varmyknife [java_options]  [options] infile - &gt; outfile
OR, to use other secondary tools:
varmyknife [java_options] --CMD commandName [options]
</code></pre>

</section> <h2>DESCRIPTION:</h2> <section>

<p>This utility performs a series of transformations on an input VCF file and adds an array of informative tags.</p>

</section> <h2>REQUIRED ARGUMENTS:</h2> <section>

<h4>infile.vcf.gz:</h4>

<blockquote>
  <p>input VCF file. Can be gzipped or in plaintext. Can use dash - to read from STDIN. Note that multifile processing will obviously not be available in this mode. (String)</p>
</blockquote>

<h4>outfile.vcf.gz:</h4>

<blockquote>
  <p>The output file. Can be gzipped or in plaintext. Can use dash - to write to STDOUT Note that multifile processing will obviously not be available in this mode. (String)</p>
</blockquote>

</section> <h2>OPTIONAL ARGUMENTS:</h2> <section>

<h3>Input Parameters:</h3>

<h4>--infileList:</h4>

<blockquote>
  <p>If this option is set, then the infile parameter is a text file containing a list of input VCF files (one per line), rather than a simple path to a single VCF file. Multiple VCF files will be concatenated and used as input. Note that only the first file's headers will be used, and if any of the subsequent files have tags or fields that are not present in the first VCF file then errors may occur. Also note that if the VCF file includes sample genotypes then the samples MUST be in the same order. (flag)</p>
</blockquote>

<h4>--infileListInfix infileList.txt:</h4>

<blockquote>
  <p>If this command is included, then all input files are treated very differently. The input VCF file path (or multiple VCFs, if you are running a VCF merge of some sort) must contain a BAR character. The file path string will be split at the bar character and the string infixes from the supplied infileList.txt infix file will be inserted into the break point. This can be very useful for merging multiple chromosomes or genomic-region-split VCFs. (String)</p>
</blockquote>

<h4>--numLinesRead N:</h4>

<blockquote>
  <p>If this parameter is set, then the utility will stop after reading in N variant lines. Intended for testing purposes. (Int)</p>
</blockquote>

<h3>Universal Parameters:</h3>

<h4>--genomeFA genome.fa.gz:</h4>

<blockquote>
  <p>The genome fasta file. Can be gzipped or in plaintext. (String)</p>
</blockquote>

<h3>Output Parameters:</h3>

<h4>--splitOutputByChrom:</h4>

<blockquote>
  <p>If this option is set, the output will be split up into parts by chromosome. NOTE: The outfile parameter must be either a file prefix (rather than a full filename), or must be a file prefix and file suffix separated by a bar character. In other worse, rather than being 'outputFile.vcf.gz', it should be either just 'outputFile' or 'outputFile.|.vcf.gz'.  (flag)</p>
</blockquote>

<h3>Annotation:</h3>

<h4>--variantMapFunction FunctionType|ID|param1=p1|param2=p2|...:</h4>

<blockquote>
  <p>TODO DESC (repeatable String)</p>
</blockquote>

<h4>--tallyFile file.txt:</h4>

<blockquote>
  <p>Write a file with a table containing counts for all tallies, warnings and notices reported during the run. (String)</p>
</blockquote>

<h3>Preprocessing:</h3>

<h4>--chromList chr1,chr2,...:</h4>

<blockquote>
  <p>List of chromosomes. If supplied, then all analysis will be restricted to these chromosomes. All other chromosomes will be ignored. For a VCF that contains only one chromosome this option will improve runtime, since the utility will not have to load and process annotation data for the other chromosomes. (CommaDelimitedListOfStrings)</p>
</blockquote>

<h4>--splitOutputByBed intervalBedFile.bed:</h4>

<blockquote>
  <p>If this option is set, the output will be split up into multiple VCF files based on the supplied BED file. An output VCF will be created for each line in the BED file. If the BED file has the 4th (optional) column, and if this 'name' column contains a unique name with no special characters then this name column will be used as the infix for all the output VCF filenames. If the BED file name column is missing, non-unique, or contains illegal characters then the files will simply be numbered. NOTE: If this option is used, then the 'outfile' parameter must be either a file prefix (rather than a full filename), or must be a file prefix and file suffix separated by a bar character. In other worse, rather than being 'outputFile.vcf.gz', it should be either just 'outputFile' or 'outputFile.|.vcf.gz'.  (String)</p>
</blockquote>

<h4>--universalTagPrefix VAK_:</h4>

<blockquote>
  <p>Set the universal tag prefix for all vArmyKnife INFO and FORMAT tags. By default it is VAK_. Warning: if you change this at any point, then all subsequent vArmyKnife commands may need to be changed to match, as vArmyKnife sometimes expects its own tag formatting. (String)</p>
</blockquote>

<h3>Sample Info:</h3>

<h4>--groupFile groups.txt:</h4>

<blockquote>
  <p>File containing a group decoder. This is a simple 2-column file (no header line). The first column is the sample ID, the 2nd column is the group ID. (String)</p>
</blockquote>

<h4>--superGroupList sup1,grpA,grpB,...;sup2,grpC,grpD,...:</h4>

<blockquote>
  <p>A list of top-level supergroups. Requires the --groupFile parameter to be set. (String)</p>
</blockquote>

<h3>OTHER OPTIONS:</h3>

<h4>--verbose:</h4>

<blockquote>
  <p>Flag to indicate that debugging information and extra progress information should be sent to stderr. (flag)</p>
</blockquote>

<h4>--quiet:</h4>

<blockquote>
  <p>Flag to indicate that only errors and warnings should be sent to stderr. (flag)</p>
</blockquote>

<h4>--paramFile paramFile.txt:</h4>

<blockquote>
  <p>A file containing additional parameters and options. Each parameter must begin with a dash. Leading whitespace will be ignored, and newlines preceded by a backslash are similarly ignored. Lines that begin with a pound sign will be skipped. Trailing parameters (infile, outfile, etc) CANNOT be defined using a parameter file. (paramFile)</p>
</blockquote>

<h4>--debugMode:</h4>

<blockquote>
  <p>Flag to indicate that much more debugging information should be sent to stderr. (flag)</p>
</blockquote>

<h4>--createRunningFile filename.txt:</h4>

<blockquote>
  <p>A file to create when this utility starts, to be deleted on a clean exit. The file WILL be deleted even if errors are caught. It will only remain if uncaught errors are thrown or if the process is killed externally. (String)</p>
</blockquote>

<h4>--successfulCompletionFile filename.txt:</h4>

<blockquote>
  <p>A file to create if and when this utility successfully completes without fatal errors. (String)</p>
</blockquote>

<h1>VARIANT OPERATIONS</h1>

<pre><code>Variant Operations or Variant Map Functions are a set of 
sub\-utilities that perform operations on a variant set one 
variant at a time\. When more than one function is specified in 
a run, these functions are performed in the order that they 
appear in the command line, after all other operations have 
been carried out \(excluding output ops\)\.
Basic Syntax:
    \-\-FCN functionName|ID|param1=p1|param2=p2|\.\.\.
</code></pre>

</section> <h2>Available Functions:</h2> <section>

<h3>snpEffExtract</h3>

<pre><code>annTag: A valid SnpSift command\(String, default=ANN\)
bioTypeKeepList: \(String\)
effectKeepList: \(String\)
warningDropList: \(String\)
geneListName: \(String\)
geneList: \(String\)
severityList: Must be a list of severity levels, listed as some 
combination of effectseverity types delimited with slashes\. 
Legal types are: HIGH, MODERATE, LOW, and MODIFIER, which are 
standard SnpEFF effect types, and also: NS \(HIGH and 
MODERATE\), NonNS \(LOW and MODIFIER\), and ANY \(any 
type\)\.\(String, default=HIGH/MODERATE/LOW\)
extractFields: This is a complex multi\-part field that allows 
flexible extraction of information from SnpEff ANN tags\. This 
field must be in the colon\-delimited format 
tagInfix:ANN\_idx:description:severityList\[:noCollapse\]\. 
severityList must be in the same format as the severityList 
parameter above, but can override the default if desired\. 
ANN\_idx must be a slash\-delimited list of field indices 
counting from zero in the ANN tag\. The standard ANN field 
indices are: 0:allele,1:effect,2:impact,3:geneName,4:geneID,5:t-
xType,6:txID,7:txBiotype,8:rank,9:HGVS\.c,10:HGVS\.p,11:cDNApos-
ition,12:cdsPosition,13:proteinPosition,14:distToFeature,15:war-
nings,16:errors If multiple fields are selected then the output 
fields will have the format first:second:third:etc\. For 
example, to create two new fields containing a list of all 
genes for which the current variant has HIGH and MODERATE 
impact respectively, use the format: myNewField:4:my 
description:HIGH/MODERATE\. This will generate two new fields: 
myNewField\_HIGH and myNewField\_MODERATE\. Note that if this 
function as a whole has a mapID set, then both field names will 
be prefixed by that overall ID\.\(String\)
geneNameIdx: \(String, default=4\)
biotypeIdx: \(String, default=7\)
warnIdx: \(String, default=15\)
</code></pre>

<h3>fixSwappedRefAlt</h3>

<pre><code>\.\.\.
genomeFA: \(String, required\)
</code></pre>

<h3>convertSampleNames</h3>

<pre><code>This function converts the sample IDs of the VCF file according 
to a decoder file that you supply\. The decoder will decode
file: A tab delimited file with the from/to chromosome 
names\.\(String, required\)
columnNames: The column titles for the old chrom names and the 
new chrom names, in that order\. If this parameter is used, the 
decoder file must have a title line\.\(String\)
columnIdx: The column number of the current chromosome names 
then the new chromosome names, in that order\. Column indices 
start counting from 0\. If you use this parameter to set the 
columns, and if the file has a title line, then you should use 
skipFirstRow or else it will be read in as if it were a 
chromosome\.\(Integer\)
skipFirstRow: If this parameter is set, then this tool will 
skip the first line on the decoder file\. This is useful if you 
are specifying the columns using column numbers but the file 
also has a title line\.\(Flag\)
</code></pre>

<h3>tagBedFile</h3>

<pre><code>This function takes a BED file \(which can be gzipped if 
desired\) and creates a new INFO field based on whether the 
variant locus overlaps with a genomic region in the BED file\. 
The new field can be either an integer that is equal to 1 if 
there is overlap and 0 otherwise \(which is the default 
behavior\) Or, alternatively, it can copy in the title field 
from the bed file\. NOTE: this function only uses the first 3 
to 5 fields of the BED file, it does not implement the optional 
fields 10\-12 which can specify intron/exon blocks\.
file: \(String, required\)
desc: \(String, default=No desc provided\)
buffer: \(Integer, default=0\)
style: \(String, default=\+\)
</code></pre>

<h3>copyColumnToInfo</h3>

<pre><code>columnID: \(String, required\)
</code></pre>

<h3>checkReferenceMatch</h3>

<pre><code>genomeFA: \(String, required\)
</code></pre>

<h3>keepVariants</h3>

<pre><code>This function drops variants based on a given true/false 
expression\.
expr: \(String\)
</code></pre>

<h3>dropNullVariants</h3>

<h3>fixFirstBaseMismatch</h3>

<pre><code>\.\.\.
windowSize: Sets the size of the sliding window used\. Problems 
may occur if you have variants longer than this window size\. 
Default is 200bp\.\(Int\)
</code></pre>

<h3>depthStats</h3>

<pre><code>This function calculates various statistics on total read depth 
and hetAB\.
inputGT: The input genotype FORMAT field\.\(String\)
inputAD: \(String\)
inputDP: \(String\)
restrictToGroup: \(String\)
groupFile: A tab\-delimited file containing sample ID's and a 
list of group IDs for each sample\. See the \-\-groupFile 
parameter of walkVcf\.\(String\)
superGroupList: See the \-\-superGroupList parameter of 
walkVcf\.\(String\)
</code></pre>

<h3>snpSiftDbnsfp</h3>

<pre><code>This function runs the SnpSift dbnsfp command
cmd: A valid SnpSift command\(String\)
</code></pre>

<h3>calcBurdenMatrix</h3>

<pre><code>\.\.\.\.
geneTag: \(String, required\)
expr: \(String\)
sampleSet: \(String\)
group: \(String\)
inputGT: \(String\)
geneList: \(String\)
geneListFile: \(String\)
printFullGeneList: \(flag\)
pathwayList: \(String\)
groupFile: A tab\-delimited file containing sample ID's and a 
list of group IDs for each sample\. See the \-\-groupFile 
parameter of walkVcf\.\(String\)
superGroupList: See the \-\-superGroupList parameter of 
walkVcf\.\(String\)
outfile: The output matrix file path\.\(String, required\)
</code></pre>

<h3>splitMultiAllelics</h3>

<pre><code>\.\.\.
</code></pre>

<h3>filterTags</h3>

<pre><code>This function can be used to remove unwanted INFO or FORMAT 
fields, or remove unwanted samples\. This can substantially 
reduce file sizes\.
FORMAT\.keep: \(String\)
FORMAT\.drop: \(String\)
INFO\.keep: \(String\)
INFO\.drop: \(String\)
SAMPLES\.keep: \(String\)
SAMPLES\.drop: \(String\)
</code></pre>

<h3>gcContext</h3>

<pre><code>windowSize: The number of bases to include in the context 
window for determining local gc content\.\(String, required\)
digits: Number of digits to round to\.\(String, default=4\)
genomeFA: \(String, required\)
</code></pre>

<h3>addInfoTag</h3>

<pre><code>This is a set of functions that all take one or more input 
parameters and outputs one new INFO field\.
func: \(String, required\)
desc: The description in the header line for the new INFO 
field\.\(String, default=No desc provided\)
digits: For floating point values, the number of digits to 
include after the decimal\(Integer\)
</code></pre>

<h3>tagVariantsExpression</h3>

<pre><code>This function takes a variant expression and creates a new INFO 
field that is 1 if and only if that expression returns TRUE, 
and 0 otherwise\.
expr: The variant expression, which is a true/false expression 
using the variant expression syntax\.\(String, required\)
desc: A description, to go in the info field 
description\.\(String, default=No desc provided\)
</code></pre>

<h3>addVariantPosInfo</h3>

<h3>sanitize</h3>

<h3>snpEff</h3>

<pre><code>This function runs SnpEff
cmd: A valid SnpSift command\(String\)
</code></pre>

<h3>getLocusDepthFromWig</h3>

<pre><code>\.\.\.
wigfile: \(String\)
desc: \(String\)
</code></pre>

<h3>tagVariantsFunction</h3>

<pre><code>This is a set of functions that all take one or more input 
parameters and outputs one new INFO field\.
func: \(String, required\)
desc: \(String, default=No desc provided\)
digits: \(Integer\)
params: \(String\)
</code></pre>

<h3>convertToStdVcf</h3>

<pre><code>Certain utilities \(eg GATK\) do not allow certain optional 
features of the VCFv4\.2 format standard \(For example: 
additional tag\-pairs in the INFO or FORMAT header lines\)\. 
This function strips out this additional metadata\.
</code></pre>

<h3>snpEffExtractField</h3>

<pre><code>tagPrefix: \(String, required\)
outputTagPrefix: \(String\)
columns: \(String\)
desc: \(String\)
collapseUniques: \(Flag\)
tagSet: \(String\)
</code></pre>

<h3>snpSiftAnno</h3>

<pre><code>This function runs a SnpSift anno command
cmd: A valid SnpSift command\(String\)
</code></pre>

<h3>unPhaseAndSortGenotypes</h3>

<pre><code>This function removes phasing and sorts genotypes\.
inputGT: The input/output genotype FORMAT field\.\(String\)
groupFile: A tab\-delimited file containing sample ID's and a 
list of group IDs for each sample\. See the \-\-groupFile 
parameter of walkVcf\.\(String\)
superGroupList: See the \-\-superGroupList parameter of 
walkVcf\.\(String\)
</code></pre>

<h3>calcStats</h3>

<pre><code>This function combines the functions sampleCounts, sampleLists, 
and depthStats, performing all three\.
groupFile: A tab\-delimited file containing sample ID's and a 
list of group IDs for each sample\. See the \-\-groupFile 
parameter of walkVcf\.\(String\)
superGroupList: See the \-\-superGroupList parameter of 
walkVcf\.\(String\)
inputGT: The input genotype FORMAT field\.\(String\)
inputAD: \(String\)
inputDP: \(\)
noCountsCalc: \(Flag\)
noFreqCalc: \(Flag\)
noMissCalc: \(Flag\)
noAlleCalc: \(Flag\)
noHetHomCalc: \(Flag\)
noMultiHetCalc: \(Flag\)
samplePrintLimit: \(String\)
noDepthStats: \(Flag\)
noSampleLists: \(Flag\)
noSampleCounts: \(Flag\)
expr: The variant expression, which is a true/false expression 
using the variant expression syntax\.\(String\)
</code></pre>

<h3>calcBurdenCounts</h3>

<pre><code>geneTag: \(String, required\)
expr: \(String\)
sampleSet: \(String\)
group: \(String\)
inputGT: \(String\)
groupFile: A tab\-delimited file containing sample ID's and a 
list of group IDs for each sample\. See the \-\-groupFile 
parameter of walkVcf\.\(String\)
superGroupList: See the \-\-superGroupList parameter of 
walkVcf\.\(String\)
countFileID: If multiple output count files are desired, you 
can specify which functions output to which count file using 
this parameter\. Note that each file must be created using a 
\-\-burdenCountsFile parameter, with the form 
fileID:/path/to/file\.txt\(String\)
</code></pre>

<h3>markDup</h3>

<pre><code>This map function will detect duplicate variant lines and add 
two new INFO fields: mapID\_CT and mapID\_IDX\. The CT will 
indicate how many duplicates were found matching the current 
variant, and the IDX will number each duplicate with a unique 
identifier, counting from 0\. All nonduplicates will be marked 
with CT=1 and IDX=0\.
</code></pre>

<h3>homopolymerRunStats</h3>

<pre><code>runSize: The number of repeated bases required to count as a 
homopolymer run\(String, required\)
genomeFA: \(String, required\)
</code></pre>

<h3>addDummyGenotypeColumn</h3>

<h3>concordanceCaller</h3>

<pre><code>\.\.\.\.
callerNames: Comma delimited list of caller IDs, used in the 
callerSet INFO fields and the names of the output GT fields\. 
By default, callers will simply be named C1,C2,\.\.\.\(String\)
priority: Comma delimited list of caller IDs\. The list of 
caller IDs in order of descending priority\.\(String\)
gtDecisionMethod: The merge rule for calculating 
ensemble\-merged GT and AD tags\. Valid options are priority, 
prioritySkipMissing, and majority\_priorityOnTies\. Default is 
simple priority\.\(String\)
ignoreSampleIds: If this flag is set, then sample IDs will be 
ignored and each VCF will be assumed to have the exact same 
samples in the exact same order\. Use at your own risk\.\(flag\)
ignoreSampleOrder: If this flag is set, then the sample IDs 
will be used to match up the different VCFs, and the samples 
may be in different orders in the different files\.\(flag\)
</code></pre>

<h3>addContextBases</h3>

<pre><code>windowSize: The number of bases to include in the context 
window\(String, required\)
genomeFA: \(String, required\)
</code></pre>

<h3>convertChromNames</h3>

<pre><code>\.\.\.\.
file: A tab delimited file with the from/to chromosome 
names\.\(String, required\)
columnNames: The column titles for the old chrom names and the 
new chrom names, in that order\. If this parameter is used, the 
decoder file must have a title line\.\(String\)
columnIdx: The column number of the current chromosome names 
then the new chromosome names, in that order\. Column indices 
start counting from 0\. If you use this parameter to set the 
columns, and if the file has a title line, then you should use 
skipFirstRow or else it will be read in as if it were a 
chromosome\.\(Integer\)
skipFirstRow: If this parameter is set, then this tool will 
skip the first line on the decoder file\. This is useful if you 
are specifying the columns using column numbers but the file 
also has a title line\.\(Flag\)
</code></pre>

<h3>addVariantIdx</h3>

<pre><code>prefix: Prefix to prepend to the index field\.\(String\)
</code></pre>

<h3>dropSpanIndels</h3>

<h3>addAltSequence</h3>

<pre><code>windowSize: The number of flanking bases to include on each 
side of the alt sequence\.\(String, default=10\)
genomeFA: \(String, required\)
</code></pre>

<h3>sampleLists</h3>

<pre><code>This function generates sample list fields which contain 
comma\-delimited lists of samples that are het or hom\-alt\.
inputGT: The input genotype FORMAT field\.\(String\)
samplePrintLimit: \(String\)
groupFile: A tab\-delimited file containing sample ID's and a 
list of group IDs for each sample\. See the \-\-groupFile 
parameter of walkVcf\.\(String\)
superGroupList: See the \-\-superGroupList parameter of 
walkVcf\.\(String\)
expr: The variant expression, which is a true/false expression 
using the variant expression syntax\.\(String\)
</code></pre>

<h3>fixDotAltIndels</h3>

<pre><code>\.\.\.
</code></pre>

<h3>dropGenotypeData</h3>

<h3>extractRegion</h3>

<pre><code>This function extracts a single region from the VCF\. NOTE: the 
VCF MUST BE SORTED\!
region: The genomic region to extract\.\(String, required\)
windowSize: The size of the window around the genomic region to 
extract\.\(Int\)
</code></pre>

<h3>calcBurdenCountsByGroups</h3>

<pre><code>geneTag: \(String, required\)
groups: \(String, required\)
expr: \(String\)
sampleSet: \(String\)
inputGT: \(String\)
groupFile: A tab\-delimited file containing sample ID's and a 
list of group IDs for each sample\. See the \-\-groupFile 
parameter of walkVcf\.\(String\)
superGroupList: See the \-\-superGroupList parameter of 
walkVcf\.\(String\)
countFileID: If multiple output count files are desired, you 
can specify which functions output to which count file using 
this parameter\. Note that each file must be created using a 
\-\-burdenCountsFile parameter, with the form 
fileID:/path/to/file\.txt\(String\)
</code></pre>

<h3>rmDup</h3>

<pre><code>\.\.\.
</code></pre>

<h3>leftAlignAndTrim</h3>

<pre><code>\.\.\.
windowSize: Sets the size of the sliding window used\. Problems 
may occur if you have variants longer than this window size\. 
Default is 200bp\.\(Int\)
genomeFA: \(String, required\)
</code></pre>

<h3>sampleCounts</h3>

<pre><code>This function generates counts and frequencies for alt alleles, 
alt genotypes, missing genotypes, ref genotypes, and so on\. 
Note that there are several calc\- flags\. If none of these are 
included, then this function does nothing\.
groupFile: A tab\-delimited file containing sample ID's and a 
list of group IDs for each sample\. See the \-\-groupFile 
parameter of walkVcf\.\(String\)
superGroupList: See the \-\-superGroupList parameter of 
walkVcf\.\(String\)
inputGT: The input genotype FORMAT field\.\(String\)
noCountsCalc: \(Flag\)
noFreqCalc: \(Flag\)
noMissCalc: \(Flag\)
noAlleCalc: \(Flag\)
noHetHomCalc: \(Flag\)
noMultiHetCalc: \(Flag\)
</code></pre>

<h3>dropSymbolicAlleles</h3>

<h3>sampleReorder</h3>

<pre><code>This function allows you to reorder the sample columns in your 
VCF\. Set ONE of the parameters below to specify the desired 
ordering\.
sampleOrdering: A simple list of all the samples, in the 
desired order\.\(String\)
sampleOrderingFile: A file containing one sampleID per line\. 
The samples will be reordered to match the order found in the 
file\.\(String, required\)
alphabetical: If this flag is set, then the samples will be 
reordered alphabetically\.\(Flag\)
</code></pre>

<h3>genotypeFilter</h3>

<pre><code>This function filters a genotype field based on a given 
genotype expression\. The new filtered genotype can replace the 
GT field or can be set to a different field, so multiple 
filtering strategies can be included in a single VCF\.
expr: A Genotype Expression, using the genotype expression 
syntax\.\(String, required\)
desc: A description, to go in the new FORMAT fields\.\(String\)
filterTag: The name of a new FORMAT field, which will be a flag 
equal to 1 if and only if the genotype passes the 
filter\.\(String\)
outputGT: The output genotype FORMAT field\. If this is the 
same as the input genotype field then the genotype field will 
be overwritten\.\(String\)
inputGT: The input genotype FORMAT field\.\(String\)
inputGtNewName: If this parameter is set, the input genotype 
field will be copied to a new tag with this name before 
filtering\. This can be useful if overwriting the input 
genotype field\.\(\)
groupFile: A tab\-delimited file containing sample ID's and a 
list of group IDs for each sample\. See the \-\-groupFile 
parameter of walkVcf\.\(String\)
superGroupList: See the \-\-superGroupList parameter of 
walkVcf\.\(String\)
</code></pre>

<h1>INFO TAG FUNCTIONS</h1>

<pre><code>Info Tag Functions are simple modular functions that take one 
variant at a time and add a new INFO field\.
Basic Syntax:
\-\-FCN 
addInfoTag|newTagID|fcn=infoTagFunction|params=p1,p2,\.\.\.
</code></pre>

</section> <h2>Available Functions:</h2> <section>

<h3>MULT(x,y)</h3>

<pre><code>Input should be a pair of numeric constants and/or info fields 
specified as INFO:tagID\. Output field will be the product of 
the two inputs\. Missing INFO fields will be treated as ZEROS 
unless all params are INFO fields and all are missing, in which 
case the output will be missing\. Output field type will be an 
integer if all inputs are integers and otherwise a float\.
x \(INT|FLOAT|INFO:Int|INFO:Float\)
y \(INT|FLOAT|INFO:Int|INFO:Float\)
</code></pre>

<h3>DIFF(x,y)</h3>

<pre><code>Input should be a pair of numeric constants and/or info fields 
specified as INFO:tagID\. Output field will be the difference 
of the two inputs \(ie x \- y\)\. Missing INFO fields will be 
treated as ZEROS unless all params are INFO fields and all are 
missing, in which case the output will be missing\. Output 
field type will be an integer if all inputs are integers and 
otherwise a float\.
x \(INT|FLOAT|INFO:Int|INFO:Float\)
y \(INT|FLOAT|INFO:Int|INFO:Float\)
</code></pre>

<h3>SUM(x...)</h3>

<pre><code>Input should be a set of info tags specified as INFO:tagID, and 
numeric constants\. Output field will be the sum of the 
inputs\. Missing INFO fields will be treated as zeros unless 
all params are INFO fields and all are missing, in which case 
the output will be missing\. Output field type will be an 
integer if all inputs are integers and otherwise a float\.
x\.\.\. \(INT|FLOAT|INFO:Int|INFO:Float\)
</code></pre>

<h3>FLAGSET(x...)</h3>

<pre><code>Input should be a set of infoFields and optionally a name, with 
the format tagID:name\. If names are omitted, then the name 
will be equal to the tagID\. Output field will be the set of 
names for which the respective info field is equal to 1\. Any 
value other than 1, including missing fields, will be treated 
as 0\.
x\.\.\. \(INFO:Int\)
</code></pre>

<h3>RANDFLAG(x,seed)</h3>

<pre><code>x \(FLOAT\)
seed \(INT\)
</code></pre>

<h3>DIV(x,y)</h3>

<pre><code>Input should be a pair of numeric constants and/or info fields 
specified as INFO:tagID\. Output field will be the product of 
the two inputs\. Missing INFO fields will be treated as ZEROS 
unless all params are INFO fields and all are missing, in which 
case the output will be missing\. Output field type will be a 
float\.
x \(INT|FLOAT|INFO:Int|INFO:Float\)
y \(INT|FLOAT|INFO:Int|INFO:Float\)
</code></pre>

<h3>MIN(x...)</h3>

<pre><code>x\.\.\. \(INT|FLOAT|INFO:Int|INFO:Float\)
</code></pre>

<h3>CONVERT.TO.INT(x,defaultValue)</h3>

<pre><code>Input should be an INFO field
x \(INFO:String\)
defaultValue \(Optional\) \(Int\)
</code></pre>

<h3>CONVERT.TO.FLOAT(x,defaultValue)</h3>

<pre><code>Input should be an INFO field\. Converts to a numeric float\. 
If no defaultValue is supplied then non\-floats will be 
dropped\. Note that NaN and Inf will be dropped / replaced with 
the default\.
x \(INFO:String\)
defaultValue \(Optional\) \(Float\)
</code></pre>

<h3>EXPR(expr)</h3>

<pre><code>The new field will be an integer field which will be equal to 1 
if and only if the expression is TRUE, and 0 otherwise\. See 
the expression format definition for more information on how 
the logical expression syntax works\.
expr \(STRING\)
</code></pre>

<h3>DECODE(x,decoder)</h3>

<pre><code>x \(INFO:String\)
decoder \(FILE:String\)
</code></pre>

<h3>CONCAT(x...)</h3>

<pre><code>This simple function concatenates the values of the input 
parameters\. Input parameters can be any combination of INFO 
fields or constant strings\.
x\.\.\. \(String|INFO:String\)
</code></pre>

<h3>PRODUCT.ARRAY(x...)</h3>

<pre><code>Input should be a set of numeric constants or info tags 
specified as INFO:tagID\. Output field will be the product of 
the inputs\. Missing INFO fields will be treated as ones unless 
all params are INFO fields and all are missing, in which case 
the output will be missing\. Output field type will be an 
integer if all inputs are integers and otherwise a float\.
x\.\.\. \(INT|FLOAT|INFO:Int|INFO:Float\)
</code></pre>

<h3>SETS.DIFF(x,y)</h3>

<pre><code>Input should be a pair of sets that are either INFO fields 
specified as INFO:tagID, text files specified as FILE:fileName, 
or a constant set delimited with colons\.Output field will be a 
comma delimited string containing the elements in the first set 
with the second set subtracted out\.
x 
\(String|INFO:String|INT|FLOAT|INFO:Int|INFO:Float|FILE:String\)
y 
\(String|INFO:String|INT|FLOAT|INFO:Int|INFO:Float|FILE:String\)
</code></pre>

<h3>SWITCH.EXPR(expr,A,B)</h3>

<pre><code>Switches between two options depending on a logical 
expression\. The 'expr' expression parameter must be formatted 
like standard variant\-level expressions\. The A and B 
parameters can each be either a constant or an INFO field\. The 
output field will be equal to A if the logical expression is 
TRUE, and otherwise will be B\.
expr \(STRING\)
A \(INFO:Int|INFO:Float|INFO:String|Int|Float|String\)
B \(Optional\) 
\(INFO:Int|INFO:Float|INFO:String|Int|Float|String\)
</code></pre>

<h3>MAX(x...)</h3>

<pre><code>x\.\.\. \(INT|FLOAT|INFO:Int|INFO:Float\)
</code></pre>

<h3>PICK.RANDOM(seed,x,y...)</h3>

<pre><code>The first parameter must be either '\.' or a supplied random 
seed for the random number generator\. You can then provide 
either a single additional parameter and the output field will 
be a randomly picked element from that parameter\. In this case 
the output will be chosen from this one input parameter \(which 
is assumed to be a list of some sort\), which can be a string 
constant list delimited with colons, an INFO field specified as 
INFO:fieldName, or a text file specified as FILE:filename\. 
Alternately: you can provide several additional parameters, in 
which case it will select randomly from the set of parameters\.
seed \(String\)
x \(String|INFO:String|FILE:String\)
y\.\.\. \(Optional\) \(String|INFO:String\)
</code></pre>

<h3>SETS.UNION(x...)</h3>

<pre><code>The new field will be equal to the union of the inputs\. Inputs 
can either be INFO fields specified with 'INFO:tagName', can 
point to a text file with 'FILE:filename', or can be constants 
\(delimited with colons\)\. The output will be the union of the 
given parameters, in alphabetical order\.
x\.\.\. \(String|INFO:String|FILE:String\)
</code></pre>

<h3>COPY(oldField)</h3>

<pre><code>oldField \(INFO:Float|INFO:String\)
</code></pre>

<h3>SETS.INTERSECT(x...)</h3>

<pre><code>Input should be a pair of sets that are either INFO fields 
specified as INFO:tagID, text files specified as FILE:fileName, 
or a constant set delimited with colons\. Output field will be 
a comma delimited string containing the intersect between the 
supplied sets\.
x\.\.\. \(String|INFO:String|FILE:String\)## VCF Line Filter Expressions
</code></pre>

<h3>BASIC SYNTAX:</h3>

<p>Filtering expressions are parsed as a series of logical filters 
connected with AND, OR, NOT, and parentheses. All expressions must 
be separated with whitespace, though it does not matter how much 
whitespace or what kind. Alternatively, expressions can be read 
directly from file by setting the expression to 
EXPRESSIONFILE:filepath.</p>

<p>Logical filters are all of the format 
FILTERNAME:PARAM1:PARAM2:etc. Some filters have no parameters, 
other filters can accept a variable number of parameters. All 
filters return TRUE or FALSE. Filters can be inverted using the 
NOT operator before the filter (with whitespace in between). 
Unless indicated otherwise, elements are dropped when the full 
expression returns FALSE.</p>

<h3>Filter Functions:</h3>

<h4>ALT.eq:k</h4>

<blockquote>
  <p>PASS iff the first ALT allele equals k.</p>
</blockquote>

<h4>ALT.isOneOf:k1:k2:...</h4>

<blockquote>
  <p>PASS iff the first ALT allele is one of k1,k2,...</p>
</blockquote>

<h4>ALT.len.eq:k</h4>

<blockquote>
  <p>PASS iff the first ALT allele is of length k.</p>
</blockquote>

<h4>ALT.len.gt:k</h4>

<blockquote>
  <p>PASS iff the first ALT allele is of length gt k.</p>
</blockquote>

<h4>AnyGtNonRef:gtTag</h4>

<blockquote>
  
</blockquote>

<h4>AnyGtPass:simpleGtFiltExpression:k1:...</h4>

<blockquote>
  <p>PASS iff any one of the samples pass the supplied GT filter.</p>
</blockquote>

<h4>CHROM.inAnyOf:chrX:...</h4>

<blockquote>
  <p>True iff the variant is one one of the given chromosomes</p>
</blockquote>

<h4>FALSE:</h4>

<blockquote>
  <p>Never pass</p>
</blockquote>

<h4>FILTER.eq:k</h4>

<blockquote>
  <p>PASS iff the FILTER column is equal to k.</p>
</blockquote>

<h4>FILTER.ne:k</h4>

<blockquote>
  <p>PASS iff the FILTER column is not equal to k.</p>
</blockquote>

<h4>GENO.MAFgt:t:k</h4>

<blockquote>
  <p>PASS iff the genotype-field tag t is a genotype-style-formatted field and the minor allele frequency is greater than k.</p>
</blockquote>

<h4>GENO.MAFlt:t:k</h4>

<blockquote>
  <p>PASS iff the genotype-field tag t is a genotype-style-formatted field and the minor allele frequency is less than k.</p>
</blockquote>

<h4>GENO.hasTagPairGtStyleMismatch:t1:t2</h4>

<blockquote>
  <p>PASS iff the genotype-field t1 and t2 are both found on a given line and have at least 1 sample where both tags are not set to missing but they do not have the same value.</p>
</blockquote>

<h4>GENO.hasTagPairMismatch:t1:t2</h4>

<blockquote>
  <p>PASS iff the genotype-field t1 and t2 are both found on a given line but are not always equal for all samples.</p>
</blockquote>

<h4>GTAG.any.gt:gtTag:k</h4>

<blockquote>
  <p>PASS iff any one of the samples have a value for their genotype-tag entry greater than k.</p>
</blockquote>

<h4>INFO.any.gt:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is nonmissing and less than or equal to k.</p>
</blockquote>

<h4>INFO.any.lt:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is nonmissing and less than or equal to k.</p>
</blockquote>

<h4>INFO.eq:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is nonmissing and equal to k.</p>
</blockquote>

<h4>INFO.ge:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is nonmissing and greater than or equal to k.</p>
</blockquote>

<h4>INFO.gem:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is missing or greater than or equal to k.</p>
</blockquote>

<h4>INFO.gt:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is nonmissing and greater than k.</p>
</blockquote>

<h4>INFO.gtm:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is missing or greater than k.</p>
</blockquote>

<h4>INFO.in:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is a comma delimited list that contains string k.</p>
</blockquote>

<h4>INFO.inAny:t:k</h4>

<blockquote>
  <p>PASS if INFO field t is a list delimited with commas and bars, and contains string k.</p>
</blockquote>

<h4>INFO.inAnyOf:t:k1:k2:...</h4>

<blockquote>
  <p>PASS iff INFO field t is a list delimited with commas and bars, and contains any of the parameters k1,k2,...</p>
</blockquote>

<h4>INFO.inAnyOfN:t:k1:k2:...</h4>

<blockquote>
  <p>PASS iff INFO field t is a list delimited with commas, bars, slashes, OR COLONS, and contains any of the parameters k1,k2,...</p>
</blockquote>

<h4>INFO.inAnyOfND:t:k1:k2:...</h4>

<blockquote>
  <p>PASS iff INFO field t is a list delimited with commas, bars, slashes, colons, or dashes, and contains any of the parameters k1,k2,...</p>
</blockquote>

<h4>INFO.le:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is nonmissing and less than or equal to k.</p>
</blockquote>

<h4>INFO.lem:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is missing or less than or equal to k</p>
</blockquote>

<h4>INFO.len.eq:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is nonmissing and has length equal to k.</p>
</blockquote>

<h4>INFO.len.gt:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is nonmissing and has length greater than k.</p>
</blockquote>

<h4>INFO.len.lt:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is nonmissing and has length less than k.</p>
</blockquote>

<h4>INFO.lt:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is nonmissing and less than k.</p>
</blockquote>

<h4>INFO.ltm:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is missing or less than k.</p>
</blockquote>

<h4>INFO.m:t</h4>

<blockquote>
  <p>PASS iff INFO field t is missing.</p>
</blockquote>

<h4>INFO.mempty:t</h4>

<blockquote>
  <p>PASS iff INFO field t is missing or less than or equal to k</p>
</blockquote>

<h4>INFO.ne:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is either missing or not equal to k.</p>
</blockquote>

<h4>INFO.nm:t</h4>

<blockquote>
  <p>PASS iff INFO field t is nonmissing.</p>
</blockquote>

<h4>INFO.notIn:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is missing or is a comma delimited list that does NOT contain string k.</p>
</blockquote>

<h4>INFO.notInAny:t:k</h4>

<blockquote>
  <p>PASS if INFO field t is a list delimited with commas and bars, and does not contain string k.</p>
</blockquote>

<h4>INFO.subsetOf:t:k1:k2:...</h4>

<blockquote>
  <p>PASS iff INFO field t is a comma delimited list and is a subset of k1,k2,etc</p>
</blockquote>

<h4>INFO.subsetOfFileList:t:f</h4>

<blockquote>
  <p>PASS iff INFO field t is a comma delimited list and is a subset of the list contained in file f</p>
</blockquote>

<h4>INFO.tagsDiff:t1:t2</h4>

<blockquote>
  <p>PASS iff the INFO-field t1 and t2 are different, including when one is missing and the other is not.</p>
</blockquote>

<h4>INFO.tagsMismatch:t1:t2</h4>

<blockquote>
  <p>PASS iff the INFO-field t1 and t2 are both found on a given line but are not equal.</p>
</blockquote>

<h4>LOCUS.eq:chrom:pos</h4>

<blockquote>
  <p>True if the variant is at the given chromosome and position</p>
</blockquote>

<h4>LOCUS.range:chrom:from:to</h4>

<blockquote>
  <p>True if the variant is at the given chromosome and between the given positions (0-based)</p>
</blockquote>

<h4>POS.gt:pos</h4>

<blockquote>
  <p>True iff the variant is at a position greater than the given position</p>
</blockquote>

<h4>POS.inAnyOf:pos1:...</h4>

<blockquote>
  <p>True iff the variant is at one of the given positions</p>
</blockquote>

<h4>QUAL.gt:k</h4>

<blockquote>
  <p>PASS iff the QUAL column is greater than k.</p>
</blockquote>

<h4>QUAL.gtm:k</h4>

<blockquote>
  <p>PASS iff the QUAL column is greater than k, OR qual is missing.</p>
</blockquote>

<h4>REF.eq:k</h4>

<blockquote>
  <p>PASS iff the REF allele equals k.</p>
</blockquote>

<h4>REF.isOneOf:k1:k2:...</h4>

<blockquote>
  <p>PASS iff the REF allele is one of k1,k2,...</p>
</blockquote>

<h4>REF.len.eq:k</h4>

<blockquote>
  <p>PASS iff the REF allele is of length k.</p>
</blockquote>

<h4>REF.len.gt:k</h4>

<blockquote>
  <p>PASS iff the REF allele is of length gt k.</p>
</blockquote>

<h4>TRUE:</h4>

<blockquote>
  <p>Always pass</p>
</blockquote>

<h4>allelesHaveNoNs:</h4>

<blockquote>
  <p>FAIL iff the variant has unknown bases, ie N, in the ALT or REF alleles.</p>
</blockquote>

<h4>isSNV:</h4>

<blockquote>
  <p>PASS iff the variant is an SNV.</p>
</blockquote>

<h4>isVariant:</h4>

<blockquote>
  <p>FAIL iff the variant has no alt alleles, or if the only alt allele is exactly equal to the ref allele.</p>
</blockquote>

<h4>simpleSNV:</h4>

<blockquote>
  <p>PASS iff the variant is a biallelic SNV.</p>
</blockquote>

</section> <h2>Genotype Filter Expressions</h2> <section>

<h3>BASIC SYNTAX:</h3>

<p>Filtering expressions are parsed as a series of logical filters 
connected with AND, OR, NOT, and parentheses. All expressions must 
be separated with whitespace, though it does not matter how much 
whitespace or what kind. Alternatively, expressions can be read 
directly from file by setting the expression to 
EXPRESSIONFILE:filepath.</p>

<p>Logical filters are all of the format 
FILTERNAME:PARAM1:PARAM2:etc. Some filters have no parameters, 
other filters can accept a variable number of parameters. All 
filters return TRUE or FALSE. Filters can be inverted using the 
NOT operator before the filter (with whitespace in between). 
Unless indicated otherwise, elements are dropped when the full 
expression returns FALSE.</p>

<h3>Filter Functions:</h3>

<h4>FALSE:</h4>

<blockquote>
  <p>Never pass</p>
</blockquote>

<h4>GTAG.SC.altDepth.gt:splitIdxTag:t:v</h4>

<blockquote>
  <p>PASS iff the tag t, which must be a single-caller-AD-style-formatted field, has an observed alt-allele-frequency greater than k.</p>
</blockquote>

<h4>GTAG.SC.altDepth.lt:splitIdxTag:t:v</h4>

<blockquote>
  <p>PASS iff the tag t, which must be a single-caller-AD-style-formatted field, has an observed alt-allele-frequency greater than k.</p>
</blockquote>

<h4>GTAG.SC.altProportion.gt:splitIdxTag:t:v</h4>

<blockquote>
  <p>PASS iff the tag t, which must be a single-caller-AD-style-formatted field, has an observed alt-allele-frequency greater than k.</p>
</blockquote>

<h4>GTAG.SC.altProportion.lt:splitIdxTag:t:v</h4>

<blockquote>
  <p>PASS iff the tag t, which must be a single-caller-AD-style-formatted field, has an observed alt-allele-frequency greater than k.</p>
</blockquote>

<h4>GTAG.altDepthForAlle.gt:gt:ad:v</h4>

<blockquote>
  <p>PASS iff for AD-style tag ad and GT-style tag gt, the sample is called as having an allele K while having less than v reads covering said allele.</p>
</blockquote>

<h4>GTAG.altProportion.gt:t:k</h4>

<blockquote>
  <p>PASS iff the tag t, which must be a AD-style-formatted field, has an observed alt-allele-frequency greater than k.</p>
</blockquote>

<h4>GTAG.altProportion.lt:t:k</h4>

<blockquote>
  <p>PASS iff the tag t, which must be a AD-style-formatted field, has an observed alt-allele-frequency less than k.</p>
</blockquote>

<h4>GTAG.eq:t:s</h4>

<blockquote>
  <p>PASS iff GT field t equals the string s. DROP if tag t is not present or set to missing.</p>
</blockquote>

<h4>GTAG.ge:t:k</h4>

<blockquote>
  <p>PASS iff tag t is present and not set to missing, and is a number greater than or equal to k.</p>
</blockquote>

<h4>GTAG.gem:t:k</h4>

<blockquote>
  <p>PASS iff tag t is either not present, set to missing, or a number greater than or equal to k.</p>
</blockquote>

<h4>GTAG.gt:t:k</h4>

<blockquote>
  <p>PASS iff tag t is present and not set to missing, and is a number greater than k.</p>
</blockquote>

<h4>GTAG.gtm:t:k</h4>

<blockquote>
  <p>PASS iff tag t is either not present, set to missing, or a number greater than k.</p>
</blockquote>

<h4>GTAG.isAnyAlt:t</h4>

<blockquote>
  <p>PASS iff the tag t, which must be a genotype-style-formatted field, is present and not set to missing and contains the alt allele.</p>
</blockquote>

<h4>GTAG.isCleanHet:t</h4>

<blockquote>
  <p>PASS iff the tag t, which must be a genotype-style-formatted field, is present and not set to missing and is heterozygous between the alt and reference allele.</p>
</blockquote>

<h4>GTAG.isHet:t</h4>

<blockquote>
  <p>PASS iff the tag t, which must be a genotype-style-formatted field, is present and not set to missing and is heterozygous.</p>
</blockquote>

<h4>GTAG.isHomAlt:t</h4>

<blockquote>
  <p>PASS iff the tag t, which must be a genotype-style-formatted field, is present and not set to missing and is homozygous-alt.</p>
</blockquote>

<h4>GTAG.isHomRef:t</h4>

<blockquote>
  <p>PASS iff the tag t, which must be a genotype-style-formatted field, is present and not set to missing and is homozygous-reference.</p>
</blockquote>

<h4>GTAG.le:t:k</h4>

<blockquote>
  <p>PASS iff tag t is present and not set to missing, and is a number less than or equal to k.</p>
</blockquote>

<h4>GTAG.lem:t:k</h4>

<blockquote>
  <p>PASS iff tag t is either not present, set to missing, or a number less than or equal to k.</p>
</blockquote>

<h4>GTAG.lt:t:k</h4>

<blockquote>
  <p>PASS iff tag t is present and not set to missing, and is a number less than k.</p>
</blockquote>

<h4>GTAG.ltm:t:k</h4>

<blockquote>
  <p>PASS iff tag t is either not present, set to missing, or a number less than k.</p>
</blockquote>

<h4>GTAG.m:t:k</h4>

<blockquote>
  <p>PASS iff the GT field t is is not present or set to missing.</p>
</blockquote>

<h4>GTAG.ne:t:k</h4>

<blockquote>
  <p>PASS iff GT field t does not equal the string s. DROP if tag t is not present or set to missing.</p>
</blockquote>

<h4>GTAG.nm:t</h4>

<blockquote>
  <p>PASS iff the GT field t is present and not set to missing.</p>
</blockquote>

<h4>GTAGARRAY.gt:t:i:k</h4>

<blockquote>
  <p>PASS iff the tag t is present and not set to missing, and is a list with at least i elements, and the i-th element of which is greater than k.</p>
</blockquote>

<h4>GTAGARRAYSUM.gt:t:k</h4>

<blockquote>
  <p>PASS iff the tag t is present and not set to missing, and is a list of numbers the sum of which is greater than k.</p>
</blockquote>

<h4>SAMPGRP.in:g</h4>

<blockquote>
  <p>PASS iff the sample is a member of group g.</p>
</blockquote>

<h4>TAGPAIR.match:t1:t2</h4>

<blockquote>
  <p>PASS iff the two tags t1 and t2 are both present and not set to missing, and are equal to one another.</p>
</blockquote>

<h4>TRUE:</h4>

<blockquote>
  <p>Always pass</p>
</blockquote>

<pre><code>    ## Secondary Commands:
    In addition to the standard command which parses a VCF or 
    variant table, vArmyKnife includes a few ancillary tools 
    which perform other tasks.
    These tools can be invoked with the command:
        varmyknife --CMD commandName [options]
    For more information see the [secondary command 
    page](secondaryCommands.html), or use the command:
        varmyknife --help CMD
    For a listing of all secondary commands, use the command: 
        varmyknife --help secondaryCommands## AUTHORS:
</code></pre>

<p>Stephen W. Hartley, Ph.D. stephen.hartley (at nih dot gov)</p>

</section> <h2>LEGAL:</h2> <section>

<p>Written 2017-2019 by Stephen Hartley, PhD  National Cancer Institute (NCI), Division of Cancer Epidemiology and Genetics (DCEG), Human Genetics Program As a work of the United States Government, this software package and all related documentation and information is in the public domain within the United States. Additionally, the National Institutes of Health and the National Cancer Institute waives copyright and related rights in the work worldwide through the CC0 1.0 Universal Public Domain Dedication (which can be found at https://creativecommons.org/publicdomain/zero/1.0/). Although all reasonable efforts have been taken to ensure the accuracy and reliability of the software and data, the National Human Genome Research Institute (NHGRI), the National Cancer Institute (NCI) and the U.S. Government does not and cannot warrant the performance or results that may be obtained by using this software or data. NHGRI, NCI and the U.S. Government disclaims all warranties as to performance, merchantability or fitness for any particular purpose. In work or products derived from this material, proper attribution of the authors as the source of the software or data may be made using "NCI Division of Cancer Epidemiology and Genetics, Human Genetics Program" as the citation. This package uses (but is not derived from) several externally-developed, open-source libraries which have been distributed under various open-source licenses. vArmyKnife is distributed with compiled versions of these packages. Additional License information can be accessed using the command:     vArmyKnife --help LICENSES And can also found in the distributed source code in:     src/main/resources/library.LICENSES.txt</p>

</div></body></html>
