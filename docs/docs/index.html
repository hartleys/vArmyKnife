<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
		<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="chrome=1">
		<title>vArmyKnife: Variant Army Knife Toolkit</title>

		<link rel="stylesheet" href="stylesheets/styles.2.css">
		<link rel="stylesheet" href="stylesheets/pygment_trac.css">
		<script src="javascripts/scale.fix.js"></script>
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

		<!--[if lt IE 9]>
		<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
</head>

<body>
<div class="wrapper">


<header>
			<h1><a href="index.html">vArmyKnife</a></h1>
			<p>Variant Army Knife</p>
</header>


<section>
<h1>vArmyKnife</h1>

<blockquote>
  <p>Version 2.2.319 (Updated Thu Jan 16 10:58:39 EST 2020)</p>

<p>(<a href="../index.html">back to main</a>) (<a href="index.html">back to java-utility help</a>)</p>
</blockquote>

</section> <h2>Help for vArmyKnife command "walkVcf"</h2> <section>

<p>ALIASES: multiStepPipeline</p>

</section> <h2>USAGE:</h2> <section>

<p>GENERAL SYNTAX:</p>

<pre><code>varmyknife [java_options]  [options] infile outfile
OR
varmyknife [java_options]  [options] infile - &gt; outfile
OR, to use other secondary tools:
varmyknife [java_options] --CMD commandName [options]
</code></pre>

</section> <h2>DESCRIPTION:</h2> <section>

<p>This utility performs a series of transformations on an input VCF file and adds an array of informative tags.</p>

</section> <h2>REQUIRED ARGUMENTS:</h2> <section>

<h4>variants.vcf:</h4>

<blockquote>
  <p>input VCF file. Can be gzipped or in plaintext. (String)</p>
</blockquote>

<h4>outfile.vcf.gz:</h4>

<blockquote>
  <p>The output file. Can be gzipped or in plaintext. (String)</p>
</blockquote>

</section> <h2>OPTIONAL ARGUMENTS:</h2> <section>

<h3>Input Parameters:</h3>

<h4>--infileList:</h4>

<blockquote>
  <p>If this option is set, then the input file is a text file containing a list of input VCF files (one per line), rather than a simple path to a single VCF file. Multiple VCF files will be concatenated and used as input. Note that only the first file's headers will be used, and if any of the subsequent files have tags or fields that are not present in the first VCF file then errors may occur. Also note that if the VCF file includes sample genotypes then the samples MUST be in the same order. (flag)</p>
</blockquote>

<h4>--infileListInfix infileList.txt:</h4>

<blockquote>
  <p>If this command is included, then all input files are treated very differently. The input VCF file path (or multiple VCFs, if you are running a VCF merge of some sort) must contain a BAR character. The file path string will be split at the bar character and the string infixes from the supplied infileList.txt infix file will be inserted into the break point. This can be very useful for merging multiple chromosomes or genomic-region-split VCFs. (String)</p>
</blockquote>

<h4>--numLinesRead N:</h4>

<blockquote>
  <p>If this parameter is set, then the utility will stop after reading in N variant lines. Intended for testing purposes. (Int)</p>
</blockquote>

<h4>--testRun:</h4>

<blockquote>
  <p>Only read the first 1000 lines. Equivalent to --numLinesRead 1000. Intended for testing purposes. (flag)</p>
</blockquote>

<h3>Universal Parameters:</h3>

<h4>--genomeFA genome.fa.gz:</h4>

<blockquote>
  <p>The genome fasta file. Can be gzipped or in plaintext. (String)</p>
</blockquote>

<h3>Preprocessing:</h3>

<h4>--splitMultiAllelics:</h4>

<blockquote>
  <p>If this flag is used, multiallelic variants will be split into multiple separate VCF lines. In order to preserve cross-allele genotypes and multiallelic FORMAT fields, the star allele will be used to indicate a different alt allele on a different variant line. The star-allele encoding can be deactivated using the --splitMultiAllelicsNoStarAllele option instead. (flag)</p>
</blockquote>

<h4>--splitMultiAllelicsNoStarAlle:</h4>

<blockquote>
  <p>If this flag is used, multiallelic variants will be split into multiple separate VCF lines. Two copies of the AD tag will be created, AD and AD_multAlle. (flag)</p>
</blockquote>

<h4>--dropSpanIndels:</h4>

<blockquote>
  <p>Requires splitMultiAllelic. Drops spanning indels, which are marked with an asterisk allele. (flag)</p>
</blockquote>

<h4>--convertROAOtoAD:</h4>

<blockquote>
  <p>If this flag is used, then the RO/AO FORMAT fields used by certain callers (freebayes) will be merged and copied over into a new AD tag. (flag)</p>
</blockquote>

<h4>--nonNullVariantsOnly:</h4>

<blockquote>
  <p>If this flag is used, only write variants that have non-null alt alleles. (flag)</p>
</blockquote>

<h4>--rmDup:</h4>

<blockquote>
  <p>If this flag is used, duplicate lines will be dropped. VCF must be sorted. (flag)</p>
</blockquote>

<h4>--chromList chr1,chr2,...:</h4>

<blockquote>
  <p>List of chromosomes. If supplied, then all analysis will be restricted to these chromosomes. All other chromosomes will be ignored. For a VCF that contains only one chromosome this option will improve runtime, since the utility will not have to load and process annotation data for the other chromosomes. (CommaDelimitedListOfStrings)</p>
</blockquote>

<h4>--extractInterval chr1:1000-5000:</h4>

<blockquote>
  <p>This tool will extract variants across the given genomic interval. All other loci will be discarded. Note: the VCF MUST be sorted! Furthermore: this extract will occur before any leftAlignAndTrim or similar preprocessing steps. (String)</p>
</blockquote>

<h4>--splitOutputByBed intervalBedFile.bed:</h4>

<blockquote>
  <p>If this option is set, the output will be split up into multiple VCF files based on the supplied BED file. An output VCF will be created for each line in the BED file. If the BED file has the 4th (optional) column, and if this 'name' column contains a unique name with no special characters then this name column will be used as the infix for all the output VCF filenames. If the BED file name column is missing, non-unique, or contains illegal characters then the files will simply be numbered. NOTE: If this option is used, then the 'outfile' parameter must be either a file prefix (rather than a full filename), or must be a file prefix and file suffix separated by a bar character. In other worse, rather than being 'outputFile.vcf.gz', it should be either just 'outputFile' or 'outputFile.|.vcf.gz'.  (String)</p>
</blockquote>

<h4>--fixSwappedRefAlt:</h4>

<blockquote>
  <p>Checks if the ref allele matches the alt allele. IF they don't match, it checks if the alt allele matches and switches the ref/alt if it does. Otherwise it simply adds a warning tag. (flag)</p>
</blockquote>

<h4>--leftAlignAndTrim:</h4>

<blockquote>
  <p>Left align and trim the primary input VCF using a modified and ported version of the GATK v3.8-2 LeftAlignAndTrim walker. (flag)</p>
</blockquote>

<h4>--leftAlignAndTrimWindow N:</h4>

<blockquote>
  <p>Set the window size used for left align and trim. Indels larger than this will not be left aligned. (Int)</p>
</blockquote>

<h4>--fixDotAltIndels:</h4>

<blockquote>
  <p>Some callers return variant lines that use a dot or dashin the alt column, especially if the VCFs were converted over from ANNOVAR files. technically per the VCF spec this should be interpreted as the absence of any variant alleles (an allele list of length 0). But some tools seem to sometimes use this encoding when they actually mean to indicate an indel. If you use this parameter, then dot-alt indels will be converted to proper form before any other processing. Note: the genomeFA parameter is required in order to use this option, as we need to be able to find the reference sequence for the previous base. (flag)</p>
</blockquote>

<h4>--unPhaseAndSortGenotypes GT,GT_PREFILT,etc:</h4>

<blockquote>
  <p>Replace phased genotypes with unphased and reorder genotypes so that heterozygote alleles are always written in ascending order. (CommaDelimitedListOfStrings)</p>
</blockquote>

<h4>--dropSymbolicAlleleLines:</h4>

<blockquote>
  <p>Drop all variant lines that contain symbolic alleles. If this flag is used with splitMultiAllelic, then the non-symbolic alleles of mixed-type variants will be preserved. (flag)</p>
</blockquote>

<h4>--dropVariantsWithNs:</h4>

<blockquote>
  <p>Drop any variants that contain Ns in the ref or alt allele. (flag)</p>
</blockquote>

<h4>--inputKeepSamples samp1,samp2,...:</h4>

<blockquote>
  <p>If this parameter is set, all samples other than the listed samples will be removed PRIOR to processing. (CommaDelimitedListOfStrings)</p>
</blockquote>

<h4>--inputKeepInfoTags tag1,tag2,...:</h4>

<blockquote>
  <p>List of tags to keep from the input file before processing. All other tags will be dropped before processing. This can be useful for updating a file with a new version or annotation, as it can be used to ensure a clean input. (CommaDelimitedListOfStrings)</p>
</blockquote>

<h4>--inputDropInfoTagsFromFile tag1,tag2,...:</h4>

<blockquote>
  <p>List of tags to DROP from the input file before processing. All other tags will be dropped before processing. This can be useful for updating a file with a new version or annotation, as it can be used to ensure a clean input. (String)</p>
</blockquote>

<h4>--inputKeepInfoTagsFromFile tag1,tag2,...:</h4>

<blockquote>
  <p>List of tags to keep from the input file before processing. All other tags will be dropped before processing. This can be useful for updating a file with a new version or annotation, as it can be used to ensure a clean input. (String)</p>
</blockquote>

<h4>--inputDropInfoTags tag1,tag2,...:</h4>

<blockquote>
  <p>List of tags to DROP from the input file before processing. All other tags will be dropped before processing. This can be useful for updating a file with a new version or annotation, as it can be used to ensure a clean input. (CommaDelimitedListOfStrings)</p>
</blockquote>

<h4>--inputSampleOrdering samp1,samp2,...:</h4>

<blockquote>
  <p>List of samples in the order you want them to be in prior to any analysis. If you are filtering down your sample list using inputKeepSamples or renaming your samples via sampleRenameFile, then the reordering happens AFTER the renaming. (CommaDelimitedListOfStrings)</p>
</blockquote>

<h4>--inputSampleOrderingAlphabetical:</h4>

<blockquote>
  <p>This option causes the samples to be reordered into alphabetical order. See --inputSampleOrdering for more info on how and when the reordering happens. (flag)</p>
</blockquote>

<h4>--inputChromDecoder chromDecoder.txt:</h4>

<blockquote>
  <p>Assigns a chromosome name decoder file. All chromosomes will be renamed based on this decoder. By default, the first column will be the FROM column and the second column will be the TO column. The FROM and TO column numbers can be changed with the --inputChromDecoderFromCol and --inputChromDecoderToCol parameters. These parameters can be used to translate chromosome names between the chr1,chr2,... and 1,2,... style chromosome name conventions. Any chrom names not found in this file will be left as is, throwing a warning. Note: the translation will take place BEFORE any other processing. (String)</p>
</blockquote>

<h4>--inputChromDecoderFromCol val:</h4>

<blockquote>
  <p>Define the column in the chromDecoder text file that contains the chrom names found in the original input VCF. (Int)</p>
</blockquote>

<h4>--inputChromDecoderToCol val:</h4>

<blockquote>
  <p>Define the column in the chromDecoder text file that contains the chrom names that are to be used in the new output VCF. (Int)</p>
</blockquote>

<h4>--universalTagPrefix VAK_:</h4>

<blockquote>
  <p>Set the universal tag prefix for all vArmyKnife INFO and FORMAT tags. By default it is VAK_. Warning: if you change this at any point, then all subsequent vArmyKnife commands may need to be changed to match, as vArmyKnife sometimes expects its own tag formatting. (String)</p>
</blockquote>

<h3>Annotation:</h3>

<h4>--addLocalGcInfo tagPrefix,windowsize1|ws2|...,numDigits:</h4>

<blockquote>
  <p>Will add VCF INFO tags that indicate the GC fraction of flanking bases. Requires an indexed genome fasta to be set with the --genomeFA option. The parameter must be formatted in 3 comma-delimited parts: first the prefix to append to the INFO tags, then a bar-delimited list of window sizes, and then the number of digits to include in the output. (repeatable String)</p>
</blockquote>

<h4>--snpSiftAnnotate tagPrefix,snpSiftParameters:</h4>

<blockquote>
  <p>Options for a SnpSift annotate run. Provide all the options for the standard run.  Do not include the annotate command itself or the input VCF. This will call the internal SnpSift annotate methods, not merely run an external instance of SnpSift.  (repeatable String)</p>
</blockquote>

<h4>--snpSiftFilter filter Name|KEEP_MATCH or DROP_MATCH|SnpSift command:</h4>

<blockquote>
  <p>Options for a SnpSift annotate run. Filters based on the results of this run.  (repeatable String)</p>
</blockquote>

<h4>--snpEffAnnotate tagPrefix,snpEffParameters:</h4>

<blockquote>
  <p>Options for a SnpEff ann run. Provide all the options for the standard run.  Do not include the annotate command itself or the input VCF. This will call the internal SnpEff ann methods, not merely run an external instance of SnpEff.  (String)</p>
</blockquote>

<h4>--snpSiftDbnsfp ...:</h4>

<blockquote>
  <p>Options for a SnpSift Dbnsfp run. Provide all the options for the standard run. Do not include the Dbnsfp command itself or the input VCF. This will call the internal SnpSift annotate commands, not merely run an external instance of SnpSift.  (repeatable String)</p>
</blockquote>

<h4>--addBedTags TAGTITLE:bufferLen:filedesc:bedfile.bed,TAGTITLE2:bufferLen:filedesc2:bedfile2.bed.gz,...:</h4>

<blockquote>
  <p>List of tags and bed files that define said tags. For each tag, the variant will have a tag value of 1 iff the variant appears on the bed file region, and 0 otherwise. This should be a comma-delimited list consisting of one or more colon-delimited lists. Each element in the comma delimited list must have 4 colon-delimited sub-elements: the tag title (ie, the tag that will be added to the VCF file, the buffer distance, the tag description (for the VCF header), and the bedfile path. Bed files may be gzipped or zipped. (repeatable CommaDelimitedListOfStrings)</p>
</blockquote>

<h4>--addContextBases windowSize[:tagInfix]:</h4>

<blockquote>
  <p>Adds fields containing the sequence flanking the variant with the assigned windowsize. Note: requires genomeFA be set! (repeatable String)</p>
</blockquote>

<h4>--addAltSequence windowSize[:tagID]:</h4>

<blockquote>
  <p>Adds a field with the alt allele and [windowSize] base pairs of reference-genome flanking sequence to each side. If no tagID is specified, the tagID will be VAK_altSeq[windowsSize]. Note: requires genomeFA be set! Note: this parameter can be set more than once (with different window sizes). (repeatable String)</p>
</blockquote>

<h4>--homopolymerRunStats tagID|bedfile.bed|hrunThreshold:</h4>

<blockquote>
  <p>Adds a new tag that indicates when a variant adds to or deletes from a homopolymer run. Requires a homopolymer run bed file. (String)</p>
</blockquote>

<h4>--addVariantPosInfo tagPrefix:</h4>

<blockquote>
  <p>Copies the chrom, start, ref, and alt columns into an info field. This can be useful for keeping track of variants before and after variant transformations such as leftAlignAndTrim or multiallelic splits. (String)</p>
</blockquote>

<h4>--addInfoVcfs vcfTitle:vcfFilename:List|of|tags:</h4>

<blockquote>
  <p>A comma delimited list with each element containing 3 colon-delimited parts consisting of the title, filename, and the desired tags for a secondary VCF file. The indicated tags from each VCF file will be copied over. Deprecated: we recommend using the snpEffAnnotate function instead. (repeatable CommaDelimitedListOfStrings)</p>
</blockquote>

<h4>--thirdAlleleChar tag:</h4>

<blockquote>
  <p>Some users may not prefer the use of the star allele to indicate an other allele in multiallelic variants. If this tag is raised, then the star allele will be removed from multiallelics. In addition, in the GT field all other-allele For multiallelic-split variants, this defines the character used for the 'other' allele. If this is used, the original version will be copied as a backup. (String)</p>
</blockquote>

<h4>--addVariantIdx tag:</h4>

<blockquote>
  <p>. (String)</p>
</blockquote>

<h4>--tagVariantsExpression newTagID|desc|variantExpression:</h4>

<blockquote>
  <p>If this parameter is set, then additional tags will be generated based on the given expression(s). The list of expressions must be comma delimited. Each element in the comma-delimited list must begin with the tag ID, then a bar-symbol, followed by the tag description, then a bar-symbol, and finally with the expression. The expressions are always booleans, and follow the same rules for VCF line filtering. See the section on VCF line filtering, below. (repeatable String)</p>
</blockquote>

<h4>--duplicatesTag duplicateTagPrefix:</h4>

<blockquote>
  <p>If this parameter is set, duplicates will be detected and two new tags will be added: duplicateTagPrefix_CT and duplicateTagPrefix_IDX. The CT will indicate how many duplicates were found matching the current variant, and the IDX will number each duplicate with a unique identifier, counting from 0. All nonduplicates will be marked with CT=1 and IDX=0. (String)</p>
</blockquote>

<h4>--tagVariantsGtCountExpression newTagID|desc|genotypeExpression[|type]:</h4>

<blockquote>
  <p>If this parameter is set, then additional tags will be generated based on the given GENOTYPE expression(s). Each element in the comma-delimited list must begin with the tag ID, then a bar-symbol, followed by the tag description, then a bar-symbol, and finally with the genotype expression. The expressions are always booleans, and follow the same rules for VCF genotype-level filtering. See the section on VCF genotype filtering, below. Optionally, a fourth element in the list can define the type which can be either FRAC, PCT, or CT, which defines the output as either a fraction, a percentage, or a count. (repeatable String)</p>
</blockquote>

<h4>--tagVariantsFunction newTagID|desc|funcName|param1,param2,...:</h4>

<blockquote>
  <p>(repeatable String)</p>
</blockquote>

<h4>--variantMapFunction FunctionType|ID|param1=p1|param2=p2|...:</h4>

<blockquote>
  <p>TODO DESC (repeatable String)</p>
</blockquote>

<h4>--ctrlAlleFreqKeys ...:</h4>

<blockquote>
  <p>A comma-delimited list of field IDs to use to calculate the maximum of several included allele frequency fields. Optionally, the list can be preceded by the output tag ID, followed by a colon. Can be specified more than once with different parameters and a different output tag ID. (repeatable String)</p>
</blockquote>

<h4>--tallyFile file.txt:</h4>

<blockquote>
  <p>Write a file with a table containing counts for all tallies, warnings and notices reported during the run. (String)</p>
</blockquote>

<h3>Sample Stats:</h3>

<h4>--groupFile groups.txt:</h4>

<blockquote>
  <p>File containing a group decoder. This is a simple 2-column file (no header line). The first column is the sample ID, the 2nd column is the group ID. (String)</p>
</blockquote>

<h4>--superGroupList sup1,grpA,grpB,...;sup2,grpC,grpD,...:</h4>

<blockquote>
  <p>A list of top-level supergroups. Requires the --groupFile parameter to be set. (String)</p>
</blockquote>

<h4>--addSampCountWithMultVector tagID|desc|sampMultFile.txt:</h4>

<blockquote>
  <p>Beta feature: not for general use. (repeatable String)</p>
</blockquote>

<h4>--addSampTag N:</h4>

<blockquote>
  <p>If this parameter is set, then a tags will be added with sample IDs that possess alt genotypes. Samples will only be printed if the number of samples that possess a given genotype are less than N.  (String)</p>
</blockquote>

<h4>--calcStatGtTag GT:</h4>

<blockquote>
  <p>The genotype tag used to calculate stats like het count, Het-AD-balance, etc. (String)</p>
</blockquote>

<h3>Transcript Annotation:</h3>

<h4>--inputSavedTxFile txdata.data.txt.gz:</h4>

<blockquote>
  <p>Loads a saved TXdata file in order to add transcript annotation. To generate TX annotation, either this parameter OR the --genomeFA parameter must be set. Using this file will be much faster than regenerating the tx data from the gtf/fasta. this TXdata file must be generated using the GenerateTranscriptAnnotation command (String)</p>
</blockquote>

<h4>--txTypes protein_coding,...:</h4>

<blockquote>
  <p>List of transcript biotypes to include. Only works if biotype info is available in the TX annotation. (CommaDelimitedListOfStrings)</p>
</blockquote>

<h4>--gtfFile gtfFile.gtf.gz:</h4>

<blockquote>
  <p>A gene annotation GTF file. Can be gzipped or in plaintext. (String)</p>
</blockquote>

<h4>--addCanonicalTags knownCanonical.txt:</h4>

<blockquote>
  <p>Supply a list of canonical transcripts, add tags that indicate canonical-transcript-only variant info. (String)</p>
</blockquote>

<h4>--txToGeneFile txToGene.txt:</h4>

<blockquote>
  <p>File containing the mapping of transcript names to gene symbols. This file must have 2 columns: the txID and the geneID. No header line. (String)</p>
</blockquote>

<h3>SnpEff Annotation Processing:</h3>

<h4>--annTag ANN:</h4>

<blockquote>
  <p>SnpEff ANN tag for info extract (String)</p>
</blockquote>

<h4>--snpEffTagPrefix ANNEX_:</h4>

<blockquote>
  <p>Prefix for SnpEff extracted info tags (String)</p>
</blockquote>

<h4>--snpEffBiotypeKeepList ANN:</h4>

<blockquote>
  <p>todo desc (CommaDelimitedListOfStrings)</p>
</blockquote>

<h4>--snpEffEffectKeepList ANN:</h4>

<blockquote>
  <p>todo desc (CommaDelimitedListOfStrings)</p>
</blockquote>

<h4>--snpEffKeepIdx 0,1,2,...:</h4>

<blockquote>
  <p>todo desc (CommaDelimitedListOfStrings)</p>
</blockquote>

<h4>--snpEffBiotypeIdx 7:</h4>

<blockquote>
  <p>The index of the field in the annotation column that contains the biotype. (Int)</p>
</blockquote>

<h4>--snpEffWarnIdx 7:</h4>

<blockquote>
  <p>The index of the field in the annotation column that contains warnings or flags. (Int)</p>
</blockquote>

<h4>--snpEffFieldLen 16:</h4>

<blockquote>
  <p>The the length of an annotation entry. (Int)</p>
</blockquote>

<h4>--snpEffFields Allele,Consequence,...:</h4>

<blockquote>
  <p>The names of the fields in the annotation entries. (CommaDelimitedListOfStrings)</p>
</blockquote>

<h4>--snpEffGeneListTagInfix myGeneListAbbrev:</h4>

<blockquote>
  <p>A short abbreviation for your selected snpeff gene list, for use in the INFO tag IDs. (String)</p>
</blockquote>

<h3>Filtering, Genotype-Level:</h3>

<h4>--genoFilter :</h4>

<blockquote>
  <p>A genotype filter expression. See the help section on genotype filtering expressions, below. (String)</p>
</blockquote>

<h4>--filterTag :</h4>

<blockquote>
  <p>This sets the field ID for a new FORMAT field that will be 0 when the --genoFilter PASSES and 1 otherwise. (String)</p>
</blockquote>

<h4>--filterInputGtTag :</h4>

<blockquote>
  <p>Requires that --genoFilter be set. This parameter indicates which FORMAT (genotype) field should be used as the raw genotype for the purposes of genotype filtering via --genoFilter. By default the genotype filter will take the GT field and copy it to GT_PREFILT and then replace GT with the post-filtering version. (String)</p>
</blockquote>

<h4>--filterOutputGtTag :</h4>

<blockquote>
  <p>Requires that --genoFilter be set. This parameter indicates which FORMAT field should be used to store the post-filtered genotypes. Note that genotypes that fail the --genoFilter filters will be set to missing. By default the GT field will be overwritten with post-filtered genotypes. (String)</p>
</blockquote>

<h4>--unfilteredGtTag :</h4>

<blockquote>
  <p>This parameter indicates where the raw genotypes should be copied before filtering the genotypes with the --genoFilter expression. (String)</p>
</blockquote>

<h3>Filtering, Variant-Level:</h3>

<h4>--keepVariantsExpression vcfLineFilterExpression:</h4>

<blockquote>
  <p>If this parameter is set, then VCF lines will be dropped if and only if they FAIL the provided vcf line filter expression. See the section on VCF line filtering below.  (String)</p>
</blockquote>

<h4>--keepVariantsExpressionPrefilter vcfLineFilterExpression:</h4>

<blockquote>
  <p>If this parameter is set, then VCF lines will be parsed in if and only if they pass the given line filter expression. Note that this will be performed BEFORE other processing, so all referenced tags must be in the input VCF.See the section on VCF line filtering below.  (String)</p>
</blockquote>

<h3>Merge Multicaller VCFs:</h3>

<h4>--concordanceCaller:</h4>

<blockquote>
  <p>This parameter is used to run the ConcordanceCaller utility, which is designed to merge the variant calls from multiple variant callers on the same sample set. If this parameter is raised, then the input VCF should instead be formatted as a comma delimited list of N VCF files. Each of the N files will be run through an initial subset of the final VCF walkers including any of the following that are indicated by the other options: addVariantIdx,nonVariantFilter,chromosome converter,inputTag filters,addVariantPosInfo,splitMultiAllelics,leftAlignAndTrim, and convertROtoAD The variant data output stream from these walkers will be merged and final GT, AD, and GQ fields will be added if the requisite information is available. Final genotypes will be assigned by plurality rule if any genotype has a simple plurality of all nonmissing caller calls, and if no genotype has a plurality then the genotype will be chosen from the highest priority caller, chosen in the order they are named in the  (flag)</p>
</blockquote>

<h4>--concordanceCallerNames vcfName1,vcfName2,...:</h4>

<blockquote>
  <p>This parameter should be a comma delimited list of names, with the same length as --singleCallerVcfs. These names will be used in the folder-over VCF tags. (CommaDelimitedListOfStrings)</p>
</blockquote>

<h4>--concordanceCallerPriority vcfName1,vcfName2,...:</h4>

<blockquote>
  <p>This parameter should be a comma delimited list composed of the VCF names from the --singleCallerVcfNames parameter (or a subset of that list). Single callers can be left off this list and their calls will not be used to determine genotype, allele depth, and genotype quality information, although their info fields will still be merged in, and they will still appear in the callerSet field. By default: genotype calls are assigned using the most common call across all callers. Ties are broken using the priority list above, in order of highest priority (most trusted) to lowest priority (least trusted). This behavior can be altered using the --ensembleGenotypeDecision parameter. (CommaDelimitedListOfStrings)</p>
</blockquote>

<h4>--concordanceCallerIgnoreSampleIds:</h4>

<blockquote>
  <p>This option is only used by the ConcordanceCaller variant caller merge utility. If this parameter is raised, then the sample ID's listed in the last header line will be ignored. Samples MUST be in the same order in each input VCF file! Without this option, this utility will halt with an error message if the sample IDs do not match. Note that if the sample IDs are NOT in the same order, but you want to link them up by name, then instead use the --ccAllowSampleOrderDiff option. (flag)</p>
</blockquote>

<h4>--concordanceCallerIgnoreSampleOrder:</h4>

<blockquote>
  <p>This option is only used by the ConcordanceCaller variant caller merge utility. If this parameter is raised, then the caller will match up the samples by sample ID, rather than requiring that the samples all be in the same order in all of the input single-caller VCFs. Without this option, this utility will halt with an error message if the sample IDs do not match and are not in the same order. Note that this will STILL crash if all the files do not have the same set of samples. If the VCFs do not all have the same samples, you can have the utility ignore the non-overlapping samples by providing the intersection sample set in the --inputKeepSamples parameter. (flag)</p>
</blockquote>

<h4>--concordanceCallerGtMethod priority:</h4>

<blockquote>
  <p>The merge rule for calculating ensemble-merged GT and AD tags. Valid options are priority, prioritySkipMissing, and majority_priorityOnTies. Default is simple priority. (String)</p>
</blockquote>

<h3>Postprocessing:</h3>

<h4>--alphebetizeHeader:</h4>

<blockquote>
  <p>Alphebetizes the INFO and FORMAT header lines. (flag)</p>
</blockquote>

<h4>--convertToStandardVcf:</h4>

<blockquote>
  <p>Final output file will be a standard VCF that does not use the asterisk to indicate multiallelic variants. Some utilities do not implement the full VCF standard and may have trouble with asterisk alleles. (flag)</p>
</blockquote>

<h4>--dropGenotypeData:</h4>

<blockquote>
  <p>If this flag is included, then ALL sample-level columns will be stripped from the output VCF. This greatly reduces the file size, and can be useful for making portable variant set VCFs. (flag)</p>
</blockquote>

<h4>--addDummyGenotypeColumn:</h4>

<blockquote>
  <p>If this flag is included, then the genotype data will be stripped and replaced with a dummy column with 1 sample and 1 het genotype on every line. (flag)</p>
</blockquote>

<h4>--outputKeepInfoTags tag1,tag2,...:</h4>

<blockquote>
  <p>List of tags to include in the final output (repeatable CommaDelimitedListOfStrings)</p>
</blockquote>

<h4>--outputDropInfoTags tag1,tag2,...:</h4>

<blockquote>
  <p>List of tags to drop from the final output (repeatable CommaDelimitedListOfStrings)</p>
</blockquote>

<h4>--outputKeepGenoTags tag1,tag2,...:</h4>

<blockquote>
  <p>List of tags to include in the final output (repeatable CommaDelimitedListOfStrings)</p>
</blockquote>

<h4>--outputDropGenoTags tag1,tag2,...:</h4>

<blockquote>
  <p>List of tags to drop from the final output (repeatable CommaDelimitedListOfStrings)</p>
</blockquote>

<h4>--outputKeepSamples samp1,samp2,...:</h4>

<blockquote>
  <p>List of samples to include in the final output (repeatable CommaDelimitedListOfStrings)</p>
</blockquote>

<h3>Output Parameters:</h3>

<h4>--splitOutputByChrom:</h4>

<blockquote>
  <p>If this option is set, the output will be split up into parts by chromosome. NOTE: The outfile parameter must be either a file prefix (rather than a full filename), or must be a file prefix and file suffix separated by a bar character. In other worse, rather than being 'outputFile.vcf.gz', it should be either just 'outputFile' or 'outputFile.|.vcf.gz'.  (flag)</p>
</blockquote>

<h3>OTHER OPTIONS:</h3>

<h4>--snpEffWarningDropList ANN:</h4>

<blockquote>
  <p>todo desc (CommaDelimitedListOfStrings)</p>
</blockquote>

<h4>--verbose:</h4>

<blockquote>
  <p>Flag to indicate that debugging information and extra progress information should be sent to stderr. (flag)</p>
</blockquote>

<h4>--quiet:</h4>

<blockquote>
  <p>Flag to indicate that only errors and warnings should be sent to stderr. (flag)</p>
</blockquote>

<h4>--paramFile paramFile.txt:</h4>

<blockquote>
  <p>A file containing additional parameters and options. Each parameter must begin with a dash. Leading whitespace will be ignored, and newlines preceded by a backslash are similarly ignored. Lines that begin with a pound sign will be skipped. Trailing parameters (infile, outfile, etc) CANNOT be defined using a parameter file. (paramFile)</p>
</blockquote>

<h4>--debugMode:</h4>

<blockquote>
  <p>Flag to indicate that much more debugging information should be sent to stderr. (flag)</p>
</blockquote>

<h4>--createRunningFile filename.txt:</h4>

<blockquote>
  <p>A file to create when this utility starts, to be deleted on a clean exit. The file WILL be deleted even if errors are caught. It will only remain if uncaught errors are thrown or if the process is killed externally. (String)</p>
</blockquote>

<h4>--successfulCompletionFile filename.txt:</h4>

<blockquote>
  <p>A file to create if and when this utility successfully completes without fatal errors. (String)</p>
</blockquote>

<h1>VARIANT OPERATIONS</h1>

<pre><code>Variant Operations or Variant Map Functions are a set of 
sub\-utilities that perform operations on a variant set one 
variant at a time\. When more than one function is specified in 
a run, these functions are performed in the order that they 
appear in the command line, after all other operations have 
been carried out \(excluding output ops\)\.
Basic Syntax:
    \-\-FCN functionName|ID|param1=p1|param2=p2|\.\.\.
</code></pre>

</section> <h2>Available Functions:</h2> <section>

<h3>snpEffExtract</h3>

<pre><code>mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
annTag: A valid SnpSift command\(String, default=ANN\)
bioTypeKeepList: \(String\)
effectKeepList: \(String\)
warningDropList: \(String\)
geneListName: \(String\)
geneList: \(String\)
severityList: Must be a list of severity levels, listed as some 
combination of effectseverity types delimited with slashes\. 
Legal types are: HIGH, MODERATE, LOW, and MODIFIER, which are 
standard SnpEFF effect types, and also: NS \(HIGH and 
MODERATE\), NonNS \(LOW and MODIFIER\), and ANY \(any 
type\)\.\(String, default=HIGH/MODERATE/LOW\)
extractFields: This is a complex multi\-part field that allows 
flexible extraction of information from SnpEff ANN tags\. This 
field must be in the colon\-delimited format 
tagInfix:ANN\_idx:description:severityList\[:noCollapse\]\. 
severityList must be in the same format as the severityList 
parameter above, but can override the default if desired\. 
ANN\_idx must be a slash\-delimited list of field indices 
counting from zero in the ANN tag\. The standard ANN field 
indices are: 0:allele,1:effect,2:impact,3:geneName,4:geneID,5:t-
xType,6:txID,7:txBiotype,8:rank,9:HGVS\.c,10:HGVS\.p,11:cDNApos-
ition,12:cdsPosition,13:proteinPosition,14:distToFeature,15:war-
nings,16:errors If multiple fields are selected then the output 
fields will have the format first:second:third:etc\. For 
example, to create two new fields containing a list of all 
genes for which the current variant has HIGH and MODERATE 
impact respectively, use the format: myNewField:4:my 
description:HIGH/MODERATE\. This will generate two new fields: 
myNewField\_HIGH and myNewField\_MODERATE\. Note that if this 
function as a whole has a mapID set, then both field names will 
be prefixed by that overall ID\.\(String\)
geneNameIdx: \(String, default=4\)
biotypeIdx: \(String, default=7\)
warnIdx: \(String, default=15\)
</code></pre>

<h3>convertSampleNames</h3>

<pre><code>\.\.\.\.
mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
file: A tab delimited file with the from/to chromosome 
names\.\(String, required\)
columnNames: The column titles for the old chrom names and the 
new chrom names, in that order\. If this parameter is used, the 
decoder file must have a title line\.\(String\)
columnIdx: The column number of the current chromosome names 
then the new chromosome names, in that order\. Column indices 
start counting from 0\. If you use this parameter to set the 
columns, and if the file has a title line, then you should use 
skipFirstRow or else it will be read in as if it were a 
chromosome\.\(Integer\)
skipFirstRow: \(Flag\)
</code></pre>

<h3>tagBedFile</h3>

<pre><code>\.\.\.\.
mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
file: \(String, required\)
desc: \(String, default=No desc provided\)
buffer: \(Integer, default=0\)
style: \(String, default=\+\)
</code></pre>

<h3>checkReferenceMatch</h3>

<pre><code>mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
genomeFA: \(String, required\)
</code></pre>

<h3>keepVariants</h3>

<pre><code>This function drops variants based on a given true/false 
expression\.
mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
expr: \(String\)
</code></pre>

<h3>depthStats</h3>

<pre><code>This function calculates various statistics on total read depth 
and hetAB\.
mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
inputGT: The input genotype FORMAT field\.\(String\)
inputAD: \(String\)
inputDP: \(String\)
restrictToGroup: \(String\)
groupFile: A tab\-delimited file containing sample ID's and a 
list of group IDs for each sample\. See the \-\-groupFile 
parameter of walkVcf\.\(String\)
superGroupList: See the \-\-superGroupList parameter of 
walkVcf\.\(String\)
</code></pre>

<h3>snpSiftDbnsfp</h3>

<pre><code>This function runs the SnpSift dbnsfp command
mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
cmd: A valid SnpSift command\(String\)
</code></pre>

<h3>calcBurdenMatrix</h3>

<pre><code>\.\.\.\.
mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
geneTag: \(String, required\)
expr: \(String\)
sampleSet: \(String\)
group: \(String\)
inputGT: \(String\)
geneList: \(String\)
geneListFile: \(String\)
printFullGeneList: \(flag\)
pathwayList: \(String\)
groupFile: A tab\-delimited file containing sample ID's and a 
list of group IDs for each sample\. See the \-\-groupFile 
parameter of walkVcf\.\(String\)
superGroupList: See the \-\-superGroupList parameter of 
walkVcf\.\(String\)
outfile: The output matrix file path\.\(String, required\)
</code></pre>

<h3>filterTags</h3>

<pre><code>This function can be used to remove unwanted INFO or FORMAT 
fields, or remove unwanted samples\. This can substantially 
reduce file sizes\.
mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
FORMAT\.keep: \(String\)
FORMAT\.drop: \(String\)
INFO\.keep: \(String\)
INFO\.drop: \(String\)
SAMPLES\.keep: \(String\)
SAMPLES\.drop: \(String\)
</code></pre>

<h3>gcContext</h3>

<pre><code>mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
windowSize: The number of bases to include in the context 
window for determining local gc content\.\(String, required\)
digits: Number of digits to round to\.\(String, default=4\)
genomeFA: \(String, required\)
</code></pre>

<h3>addInfoTag</h3>

<pre><code>This is a set of functions that all take one or more input 
parameters and outputs one new INFO field\.
mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
func: \(String, required\)
desc: \(String, default=No desc provided\)
digits: \(Integer\)
params: \(String\)
</code></pre>

<h3>tagVariantsExpression</h3>

<pre><code>This function takes a variant expression and creates a new INFO 
field that is 1 if and only if that expression returns TRUE, 
and 0 otherwise\.
mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
expr: The variant expression, which is a true/false expression 
using the variant expression syntax\.\(String, required\)
desc: A description, to go in the info field 
description\.\(String, default=No desc provided\)
</code></pre>

<h3>sanitize</h3>

<pre><code>mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
</code></pre>

<h3>snpEff</h3>

<pre><code>This function runs SnpEff
mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
cmd: A valid SnpSift command\(String\)
</code></pre>

<h3>tagVariantsFunction</h3>

<pre><code>This is a set of functions that all take one or more input 
parameters and outputs one new INFO field\.
mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
func: \(String, required\)
desc: \(String, default=No desc provided\)
digits: \(Integer\)
params: \(String\)
</code></pre>

<h3>snpEffExtractField</h3>

<pre><code>mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
tagPrefix: \(String, required\)
outputTagPrefix: \(String\)
columns: \(String\)
desc: \(String\)
collapseUniques: \(Flag\)
tagSet: \(String\)
</code></pre>

<h3>snpSiftAnno</h3>

<pre><code>This function runs a SnpSift anno command
mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
cmd: A valid SnpSift command\(String\)
</code></pre>

<h3>unPhaseAndSortGenotypes</h3>

<pre><code>This function removes phasing and sorts genotypes\.
mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
inputGT: The input/output genotype FORMAT field\.\(String\)
groupFile: A tab\-delimited file containing sample ID's and a 
list of group IDs for each sample\. See the \-\-groupFile 
parameter of walkVcf\.\(String\)
superGroupList: See the \-\-superGroupList parameter of 
walkVcf\.\(String\)
</code></pre>

<h3>calcStats</h3>

<pre><code>This function combines the functions sampleCounts, sampleLists, 
and depthStats, performing all three\.
mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
groupFile: A tab\-delimited file containing sample ID's and a 
list of group IDs for each sample\. See the \-\-groupFile 
parameter of walkVcf\.\(String\)
superGroupList: See the \-\-superGroupList parameter of 
walkVcf\.\(String\)
inputGT: The input genotype FORMAT field\.\(String\)
inputAD: \(String\)
inputDP: \(\)
noCountsCalc: \(Flag\)
noFreqCalc: \(Flag\)
noMissCalc: \(Flag\)
noAlleCalc: \(Flag\)
noHetHomCalc: \(Flag\)
noMultiHetCalc: \(Flag\)
samplePrintLimit: \(String\)
noDepthStats: \(Flag\)
noSampleLists: \(Flag\)
noSampleCounts: \(Flag\)
expr: The variant expression, which is a true/false expression 
using the variant expression syntax\.\(String\)
</code></pre>

<h3>calcBurdenCounts</h3>

<pre><code>mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
geneTag: \(String, required\)
snpEffAnnField: NOT IMPLEMENTED\(String\)
snpEffGeneField: NOT IMPLEMENTED\(String\)
snpEffVariantTypes: NOT IMPLEMENTED\(String\)
expr: \(String\)
sampleSet: \(String\)
group: \(String\)
inputGT: \(String\)
groupFile: A tab\-delimited file containing sample ID's and a 
list of group IDs for each sample\. See the \-\-groupFile 
parameter of walkVcf\.\(String\)
superGroupList: See the \-\-superGroupList parameter of 
walkVcf\.\(String\)
countFileID: If multiple output count files are desired, you 
can specify which functions output to which count file using 
this parameter\. Note that each file must be created using a 
\-\-burdenCountsFile parameter, with the form 
fileID:/path/to/file\.txt\(String\)
</code></pre>

<h3>homopolymerRunStats</h3>

<pre><code>mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
runSize: The number of repeated bases required to count as a 
homopolymer run\(String, required\)
genomeFA: \(String, required\)
</code></pre>

<h3>addContextBases</h3>

<pre><code>mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
windowSize: The number of bases to include in the context 
window\(String, required\)
genomeFA: \(String, required\)
</code></pre>

<h3>convertChromNames</h3>

<pre><code>\.\.\.\.
mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
file: A tab delimited file with the from/to chromosome 
names\.\(String, required\)
columnNames: The column titles for the old chrom names and the 
new chrom names, in that order\. If this parameter is used, the 
decoder file must have a title line\.\(String\)
columnIdx: The column number of the current chromosome names 
then the new chromosome names, in that order\. Column indices 
start counting from 0\. If you use this parameter to set the 
columns, and if the file has a title line, then you should use 
skipFirstRow or else it will be read in as if it were a 
chromosome\.\(Integer\)
skipFirstRow: \(Flag\)
</code></pre>

<h3>addVariantIdx</h3>

<pre><code>mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
windowSize: The number of bases to include in the context 
window for determining local gc content\.\(String, required\)
genomeFA: \(String, required\)
</code></pre>

<h3>sampleLists</h3>

<pre><code>This function generates sample list fields which contain 
comma\-delimited lists of samples that are het or hom\-alt\.
mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
inputGT: The input genotype FORMAT field\.\(String\)
samplePrintLimit: \(String\)
groupFile: A tab\-delimited file containing sample ID's and a 
list of group IDs for each sample\. See the \-\-groupFile 
parameter of walkVcf\.\(String\)
superGroupList: See the \-\-superGroupList parameter of 
walkVcf\.\(String\)
expr: The variant expression, which is a true/false expression 
using the variant expression syntax\.\(String\)
</code></pre>

<h3>calcBurdenCountsByGroups</h3>

<pre><code>mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
geneTag: \(String, required\)
groups: \(String, required\)
snpEffAnnField: NOT IMPLEMENTED\(String\)
snpEffGeneField: NOT IMPLEMENTED\(String\)
snpEffVariantTypes: NOT IMPLEMENTED\(String\)
expr: \(String\)
sampleSet: \(String\)
inputGT: \(String\)
groupFile: A tab\-delimited file containing sample ID's and a 
list of group IDs for each sample\. See the \-\-groupFile 
parameter of walkVcf\.\(String\)
superGroupList: See the \-\-superGroupList parameter of 
walkVcf\.\(String\)
countFileID: If multiple output count files are desired, you 
can specify which functions output to which count file using 
this parameter\. Note that each file must be created using a 
\-\-burdenCountsFile parameter, with the form 
fileID:/path/to/file\.txt\(String\)
</code></pre>

<h3>sampleCounts</h3>

<pre><code>This function generates counts and frequencies for alt alleles, 
alt genotypes, missing genotypes, ref genotypes, and so on\. 
Note that there are several calc\- flags\. If none of these are 
included, then this function does nothing\.
mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
groupFile: A tab\-delimited file containing sample ID's and a 
list of group IDs for each sample\. See the \-\-groupFile 
parameter of walkVcf\.\(String\)
superGroupList: See the \-\-superGroupList parameter of 
walkVcf\.\(String\)
inputGT: The input genotype FORMAT field\.\(String\)
noCountsCalc: \(Flag\)
noFreqCalc: \(Flag\)
noMissCalc: \(Flag\)
noAlleCalc: \(Flag\)
noHetHomCalc: \(Flag\)
noMultiHetCalc: \(Flag\)
</code></pre>

<h3>genotypeFilter</h3>

<pre><code>This function filters a genotype field based on a given 
genotype expression\. The new filtered genotype can replace the 
GT field or can be set to a different field, so multiple 
filtering strategies can be included in a single VCF\.
mapType: The function to run\.\(String, required\)
mapID: The ID to use for this operation\. This ID will also be 
used in the output tag IDs generated by this 
operation\.\(String, required\)
expr: A Genotype Expression, using the genotype expression 
syntax\.\(String, required\)
desc: A description, to go in the new FORMAT fields\.\(String\)
filterTag: The name of a new FORMAT field, which will be a flag 
equal to 1 if and only if the genotype passes the 
filter\.\(String\)
outputGT: The output genotype FORMAT field\. If this is the 
same as the input genotype field then the genotype field will 
be overwritten\.\(String\)
inputGT: The input genotype FORMAT field\.\(String\)
inputGtNewName: If this parameter is set, the input genotype 
field will be copied to a new tag with this name before 
filtering\. This can be useful if overwriting the input 
genotype field\.\(\)
groupFile: A tab\-delimited file containing sample ID's and a 
list of group IDs for each sample\. See the \-\-groupFile 
parameter of walkVcf\.\(String\)
superGroupList: See the \-\-superGroupList parameter of 
walkVcf\.\(String\)## VCF Line Filter Expressions
</code></pre>

<h3>BASIC SYNTAX:</h3>

<p>Filtering expressions are parsed as a series of logical filters 
connected with AND, OR, NOT, and parentheses. All expressions must 
be separated with whitespace, though it does not matter how much 
whitespace or what kind. Alternatively, expressions can be read 
directly from file by setting the expression to 
EXPRESSIONFILE:filepath.</p>

<p>Logical filters are all of the format 
FILTERNAME:PARAM1:PARAM2:etc. Some filters have no parameters, 
other filters can accept a variable number of parameters. All 
filters return TRUE or FALSE. Filters can be inverted using the 
NOT operator before the filter (with whitespace in between). 
Unless indicated otherwise, elements are dropped when the full 
expression returns FALSE.</p>

<h3>Filter Functions:</h3>

<h4>ALT.eq:k</h4>

<blockquote>
  <p>PASS iff the first ALT allele equals k.</p>
</blockquote>

<h4>ALT.isOneOf:k1:k2:...</h4>

<blockquote>
  <p>PASS iff the first ALT allele is one of k1,k2,...</p>
</blockquote>

<h4>ALT.len.eq:k</h4>

<blockquote>
  <p>PASS iff the first ALT allele is of length k.</p>
</blockquote>

<h4>ALT.len.gt:k</h4>

<blockquote>
  <p>PASS iff the first ALT allele is of length gt k.</p>
</blockquote>

<h4>AnyGtNonRef:gtTag</h4>

<blockquote>
  
</blockquote>

<h4>AnyGtPass:simpleGtFiltExpression:k1:...</h4>

<blockquote>
  <p>PASS iff any one of the samples pass the supplied GT filter.</p>
</blockquote>

<h4>CHROM.inAnyOf:chrX:...</h4>

<blockquote>
  <p>True iff the variant is one one of the given chromosomes</p>
</blockquote>

<h4>FALSE:</h4>

<blockquote>
  <p>Never pass</p>
</blockquote>

<h4>FILTER.eq:k</h4>

<blockquote>
  <p>PASS iff the FILTER column is equal to k.</p>
</blockquote>

<h4>FILTER.ne:k</h4>

<blockquote>
  <p>PASS iff the FILTER column is not equal to k.</p>
</blockquote>

<h4>GENO.MAFgt:t:k</h4>

<blockquote>
  <p>PASS iff the genotype-field tag t is a genotype-style-formatted field and the minor allele frequency is greater than k.</p>
</blockquote>

<h4>GENO.MAFlt:t:k</h4>

<blockquote>
  <p>PASS iff the genotype-field tag t is a genotype-style-formatted field and the minor allele frequency is less than k.</p>
</blockquote>

<h4>GENO.hasTagPairGtStyleMismatch:t1:t2</h4>

<blockquote>
  <p>PASS iff the genotype-field t1 and t2 are both found on a given line and have at least 1 sample where both tags are not set to missing but they do not have the same value.</p>
</blockquote>

<h4>GENO.hasTagPairMismatch:t1:t2</h4>

<blockquote>
  <p>PASS iff the genotype-field t1 and t2 are both found on a given line but are not always equal for all samples.</p>
</blockquote>

<h4>GTAG.any.gt:gtTag:k</h4>

<blockquote>
  <p>PASS iff any one of the samples have a value for their genotype-tag entry greater than k.</p>
</blockquote>

<h4>INFO.any.gt:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is nonmissing and less than or equal to k.</p>
</blockquote>

<h4>INFO.any.lt:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is nonmissing and less than or equal to k.</p>
</blockquote>

<h4>INFO.eq:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is nonmissing and equal to k.</p>
</blockquote>

<h4>INFO.ge:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is nonmissing and greater than or equal to k.</p>
</blockquote>

<h4>INFO.gem:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is missing or greater than or equal to k.</p>
</blockquote>

<h4>INFO.gt:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is nonmissing and greater than k.</p>
</blockquote>

<h4>INFO.gtm:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is missing or greater than k.</p>
</blockquote>

<h4>INFO.in:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is a comma delimited list that contains string k.</p>
</blockquote>

<h4>INFO.inAny:t:k</h4>

<blockquote>
  <p>PASS if INFO field t is a list delimited with commas and bars, and contains string k.</p>
</blockquote>

<h4>INFO.inAnyOf:t:k1:k2:...</h4>

<blockquote>
  <p>PASS iff INFO field t is a list delimited with commas and bars, and contains any of the parameters k1,k2,...</p>
</blockquote>

<h4>INFO.inAnyOfN:t:k1:k2:...</h4>

<blockquote>
  <p>PASS iff INFO field t is a list delimited with commas, bars, slashes, OR COLONS, and contains any of the parameters k1,k2,...</p>
</blockquote>

<h4>INFO.inAnyOfND:t:k1:k2:...</h4>

<blockquote>
  <p>PASS iff INFO field t is a list delimited with commas, bars, slashes, colons, or dashes, and contains any of the parameters k1,k2,...</p>
</blockquote>

<h4>INFO.le:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is nonmissing and less than or equal to k.</p>
</blockquote>

<h4>INFO.lem:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is missing or less than or equal to k</p>
</blockquote>

<h4>INFO.len.eq:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is nonmissing and has length equal to k.</p>
</blockquote>

<h4>INFO.len.gt:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is nonmissing and has length greater than k.</p>
</blockquote>

<h4>INFO.len.lt:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is nonmissing and has length less than k.</p>
</blockquote>

<h4>INFO.lt:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is nonmissing and less than k.</p>
</blockquote>

<h4>INFO.ltm:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is missing or less than k.</p>
</blockquote>

<h4>INFO.m:t</h4>

<blockquote>
  <p>PASS iff INFO field t is missing.</p>
</blockquote>

<h4>INFO.mempty:t</h4>

<blockquote>
  <p>PASS iff INFO field t is missing or less than or equal to k</p>
</blockquote>

<h4>INFO.ne:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is either missing or not equal to k.</p>
</blockquote>

<h4>INFO.nm:t</h4>

<blockquote>
  <p>PASS iff INFO field t is nonmissing.</p>
</blockquote>

<h4>INFO.notIn:t:k</h4>

<blockquote>
  <p>PASS iff INFO field t is missing or is a comma delimited list that does NOT contain string k.</p>
</blockquote>

<h4>INFO.notInAny:t:k</h4>

<blockquote>
  <p>PASS if INFO field t is a list delimited with commas and bars, and does not contain string k.</p>
</blockquote>

<h4>INFO.subsetOf:t:k1:k2:...</h4>

<blockquote>
  <p>PASS iff INFO field t is a comma delimited list and is a subset of k1,k2,etc</p>
</blockquote>

<h4>INFO.subsetOfFileList:t:f</h4>

<blockquote>
  <p>PASS iff INFO field t is a comma delimited list and is a subset of the list contained in file f</p>
</blockquote>

<h4>INFO.tagsDiff:t1:t2</h4>

<blockquote>
  <p>PASS iff the INFO-field t1 and t2 are different, including when one is missing and the other is not.</p>
</blockquote>

<h4>INFO.tagsMismatch:t1:t2</h4>

<blockquote>
  <p>PASS iff the INFO-field t1 and t2 are both found on a given line but are not equal.</p>
</blockquote>

<h4>LOCUS.eq:chrom:pos</h4>

<blockquote>
  <p>True if the variant is at the given chromosome and position</p>
</blockquote>

<h4>LOCUS.range:chrom:from:to</h4>

<blockquote>
  <p>True if the variant is at the given chromosome and between the given positions (0-based)</p>
</blockquote>

<h4>POS.gt:pos</h4>

<blockquote>
  <p>True iff the variant is at a position greater than the given position</p>
</blockquote>

<h4>POS.inAnyOf:pos1:...</h4>

<blockquote>
  <p>True iff the variant is at one of the given positions</p>
</blockquote>

<h4>QUAL.gt:k</h4>

<blockquote>
  <p>PASS iff the QUAL column is greater than k.</p>
</blockquote>

<h4>QUAL.gtm:k</h4>

<blockquote>
  <p>PASS iff the QUAL column is greater than k, OR qual is missing.</p>
</blockquote>

<h4>REF.eq:k</h4>

<blockquote>
  <p>PASS iff the REF allele equals k.</p>
</blockquote>

<h4>REF.isOneOf:k1:k2:...</h4>

<blockquote>
  <p>PASS iff the REF allele is one of k1,k2,...</p>
</blockquote>

<h4>REF.len.eq:k</h4>

<blockquote>
  <p>PASS iff the REF allele is of length k.</p>
</blockquote>

<h4>REF.len.gt:k</h4>

<blockquote>
  <p>PASS iff the REF allele is of length gt k.</p>
</blockquote>

<h4>TRUE:</h4>

<blockquote>
  <p>Always pass</p>
</blockquote>

<h4>isSNV:</h4>

<blockquote>
  <p>PASS iff the variant is an SNV.</p>
</blockquote>

<h4>simpleSNV:</h4>

<blockquote>
  <p>PASS iff the variant is a biallelic SNV.</p>
</blockquote>

</section> <h2>Genotype Filter Expressions</h2> <section>

<h3>BASIC SYNTAX:</h3>

<p>Filtering expressions are parsed as a series of logical filters 
connected with AND, OR, NOT, and parentheses. All expressions must 
be separated with whitespace, though it does not matter how much 
whitespace or what kind. Alternatively, expressions can be read 
directly from file by setting the expression to 
EXPRESSIONFILE:filepath.</p>

<p>Logical filters are all of the format 
FILTERNAME:PARAM1:PARAM2:etc. Some filters have no parameters, 
other filters can accept a variable number of parameters. All 
filters return TRUE or FALSE. Filters can be inverted using the 
NOT operator before the filter (with whitespace in between). 
Unless indicated otherwise, elements are dropped when the full 
expression returns FALSE.</p>

<h3>Filter Functions:</h3>

<h4>FALSE:</h4>

<blockquote>
  <p>Never pass</p>
</blockquote>

<h4>GTAG.SC.altDepth.gt:splitIdxTag:t:v</h4>

<blockquote>
  <p>PASS iff the tag t, which must be a single-caller-AD-style-formatted field, has an observed alt-allele-frequency greater than k.</p>
</blockquote>

<h4>GTAG.SC.altDepth.lt:splitIdxTag:t:v</h4>

<blockquote>
  <p>PASS iff the tag t, which must be a single-caller-AD-style-formatted field, has an observed alt-allele-frequency greater than k.</p>
</blockquote>

<h4>GTAG.SC.altProportion.gt:splitIdxTag:t:v</h4>

<blockquote>
  <p>PASS iff the tag t, which must be a single-caller-AD-style-formatted field, has an observed alt-allele-frequency greater than k.</p>
</blockquote>

<h4>GTAG.SC.altProportion.lt:splitIdxTag:t:v</h4>

<blockquote>
  <p>PASS iff the tag t, which must be a single-caller-AD-style-formatted field, has an observed alt-allele-frequency greater than k.</p>
</blockquote>

<h4>GTAG.altDepthForAlle.gt:gt:ad:v</h4>

<blockquote>
  <p>PASS iff for AD-style tag ad and GT-style tag gt, the sample is called as having an allele K while having less than v reads covering said allele.</p>
</blockquote>

<h4>GTAG.altProportion.gt:t:k</h4>

<blockquote>
  <p>PASS iff the tag t, which must be a AD-style-formatted field, has an observed alt-allele-frequency greater than k.</p>
</blockquote>

<h4>GTAG.altProportion.lt:t:k</h4>

<blockquote>
  <p>PASS iff the tag t, which must be a AD-style-formatted field, has an observed alt-allele-frequency less than k.</p>
</blockquote>

<h4>GTAG.eq:t:s</h4>

<blockquote>
  <p>PASS iff GT field t equals the string s. DROP if tag t is not present or set to missing.</p>
</blockquote>

<h4>GTAG.ge:t:k</h4>

<blockquote>
  <p>PASS iff tag t is present and not set to missing, and is a number greater than or equal to k.</p>
</blockquote>

<h4>GTAG.gem:t:k</h4>

<blockquote>
  <p>PASS iff tag t is either not present, set to missing, or a number greater than or equal to k.</p>
</blockquote>

<h4>GTAG.gt:t:k</h4>

<blockquote>
  <p>PASS iff tag t is present and not set to missing, and is a number greater than k.</p>
</blockquote>

<h4>GTAG.gtm:t:k</h4>

<blockquote>
  <p>PASS iff tag t is either not present, set to missing, or a number greater than k.</p>
</blockquote>

<h4>GTAG.isAnyAlt:t</h4>

<blockquote>
  <p>PASS iff the tag t, which must be a genotype-style-formatted field, is present and not set to missing and contains the alt allele.</p>
</blockquote>

<h4>GTAG.isCleanHet:t</h4>

<blockquote>
  <p>PASS iff the tag t, which must be a genotype-style-formatted field, is present and not set to missing and is heterozygous between the alt and reference allele.</p>
</blockquote>

<h4>GTAG.isHet:t</h4>

<blockquote>
  <p>PASS iff the tag t, which must be a genotype-style-formatted field, is present and not set to missing and is heterozygous.</p>
</blockquote>

<h4>GTAG.isHomAlt:t</h4>

<blockquote>
  <p>PASS iff the tag t, which must be a genotype-style-formatted field, is present and not set to missing and is homozygous-alt.</p>
</blockquote>

<h4>GTAG.isHomRef:t</h4>

<blockquote>
  <p>PASS iff the tag t, which must be a genotype-style-formatted field, is present and not set to missing and is homozygous-reference.</p>
</blockquote>

<h4>GTAG.le:t:k</h4>

<blockquote>
  <p>PASS iff tag t is present and not set to missing, and is a number less than or equal to k.</p>
</blockquote>

<h4>GTAG.lem:t:k</h4>

<blockquote>
  <p>PASS iff tag t is either not present, set to missing, or a number less than or equal to k.</p>
</blockquote>

<h4>GTAG.lt:t:k</h4>

<blockquote>
  <p>PASS iff tag t is present and not set to missing, and is a number less than k.</p>
</blockquote>

<h4>GTAG.ltm:t:k</h4>

<blockquote>
  <p>PASS iff tag t is either not present, set to missing, or a number less than k.</p>
</blockquote>

<h4>GTAG.m:t:k</h4>

<blockquote>
  <p>PASS iff the GT field t is is not present or set to missing.</p>
</blockquote>

<h4>GTAG.ne:t:k</h4>

<blockquote>
  <p>PASS iff GT field t does not equal the string s. DROP if tag t is not present or set to missing.</p>
</blockquote>

<h4>GTAG.nm:t</h4>

<blockquote>
  <p>PASS iff the GT field t is present and not set to missing.</p>
</blockquote>

<h4>GTAGARRAY.gt:t:i:k</h4>

<blockquote>
  <p>PASS iff the tag t is present and not set to missing, and is a list with at least i elements, and the i-th element of which is greater than k.</p>
</blockquote>

<h4>GTAGARRAYSUM.gt:t:k</h4>

<blockquote>
  <p>PASS iff the tag t is present and not set to missing, and is a list of numbers the sum of which is greater than k.</p>
</blockquote>

<h4>SAMPGRP.in:g</h4>

<blockquote>
  <p>PASS iff the sample is a member of group g.</p>
</blockquote>

<h4>TAGPAIR.match:t1:t2</h4>

<blockquote>
  <p>PASS iff the two tags t1 and t2 are both present and not set to missing, and are equal to one another.</p>
</blockquote>

<h4>TRUE:</h4>

<blockquote>
  <p>Always pass</p>
</blockquote>

<pre><code>    ## Secondary Commands:
    In addition to the standard command which parses a VCF or 
    variant table, vArmyKnife includes a few ancillary tools 
    which perform other tasks.
    These tools can be invoked with the command:
        varmyknife --CMD commandName [options]
    For more information see the [secondary command 
    page](secondaryCommands.html), or use the command:
        varmyknife --help CMD
    For a listing of all secondary commands, use the command: 
        varmyknife --help secondaryCommands## AUTHORS:
</code></pre>

<p>Stephen W. Hartley, Ph.D. stephen.hartley (at nih dot gov)</p>

</section> <h2>LEGAL:</h2> <section>

<p>Written 2017-2019 by Stephen Hartley, PhD  National Cancer Institute (NCI), Division of Cancer Epidemiology and Genetics (DCEG), Human Genetics Program As a work of the United States Government, this software package and all related documentation and information is in the public domain within the United States. Additionally, the National Institutes of Health and the National Cancer Institute waives copyright and related rights in the work worldwide through the CC0 1.0 Universal Public Domain Dedication (which can be found at https://creativecommons.org/publicdomain/zero/1.0/). Although all reasonable efforts have been taken to ensure the accuracy and reliability of the software and data, the National Human Genome Research Institute (NHGRI), the National Cancer Institute (NCI) and the U.S. Government does not and cannot warrant the performance or results that may be obtained by using this software or data. NHGRI, NCI and the U.S. Government disclaims all warranties as to performance, merchantability or fitness for any particular purpose. In work or products derived from this material, proper attribution of the authors as the source of the software or data may be made using "NCI Division of Cancer Epidemiology and Genetics, Human Genetics Program" as the citation. This package uses (but is not derived from) several externally-developed, open-source libraries which have been distributed under various open-source licenses. vArmyKnife is distributed with compiled versions of these packages. Additional License information can be accessed using the command:     vArmyKnife --help LICENSES And can also found in the distributed source code in:     src/main/resources/library.LICENSES.txt</p>

</div></body></html>
