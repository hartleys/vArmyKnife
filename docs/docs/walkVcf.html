<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
		<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="chrome=1">
		<title>vArmyKnife: Variant Army Knife Toolkit</title>

		<link rel="stylesheet" href="stylesheets/styles.2.css">
		<link rel="stylesheet" href="stylesheets/pygment_trac.css">
		<script src="javascripts/scale.fix.js"></script>
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

		<!--[if lt IE 9]>
		<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
</head>

<body>
<div class="wrapper">


<header>
			</section> <h1><a href="index.html">vArmyKnife</a></h1> <section>
			<p>Variant Army Knife</p>
</header>


<section>
</section> <h1>vArmyKnife</h1> <section>

<blockquote>
  <p>Version 3.3.27 (Updated Tue Dec 20 15:23:25 EST 2022)</p>

<p>(<a href="../index.html">back to main</a>) (<a href="index.html">back to java-utility help</a>)</p>
</blockquote>

</section> <h2>Help for vArmyKnife command "walkVcf"</h2> <section>

</section> <h2>USAGE:</h2> <section>

<p>GENERAL SYNTAX:</p>

<pre><code>The main method is walkVcf:
    varmyknife [java_options] walkVcf [options] infile outfile
which can also output to STDOUT: 
    varmyknife [java_options] walkVcf [options] infile - &gt; outfile
To use other secondary tools:
    varmyknife [java_options] otherCommandName [options]
</code></pre>

</section> <h2>DESCRIPTION:</h2> <section>

<p>This utility performs a series of transformations on an input VCF file and adds an array of informative tags.</p>

</section> <h2>REQUIRED ARGUMENTS:</h2> <section>

<h4>infile.vcf.gz:</h4>

<blockquote>
  <p>input VCF file. Can be gzipped or in plaintext. Can use dash - to read from STDIN. Note that multifile processing will obviously not be available in this mode. (String)</p>
</blockquote>

<h4>outfile.vcf.gz:</h4>

<blockquote>
  <p>The output file. Can be gzipped or in plaintext. Can use dash - to write to STDOUT Note that multifile processing will obviously not be available in this mode. (String)</p>
</blockquote>

</section> <h2>OPTIONAL ARGUMENTS:</h2> <section>

<h3>Edit VCF:</h3>

<h4>--FCN fcnName|ID|param1=p1|param2=p2|...:</h4>

<blockquote>
  <p>This parameter tells vArmyKnife what to do to your VCF. You can specify multiple functions in a single vArmyKnife run, and the functions will be executed sequentially in order. (repeatable String)</p>
</blockquote>

<h3>Input Parameters:</h3>

<h4>--chromList chr1,chr2,...:</h4>

<blockquote>
  <p>List of chromosomes. If supplied, then all analysis will be restricted to these chromosomes. All other chromosomes will be ignored. For a VCF that contains only one chromosome this option will improve runtime, since the utility will not have to load and process annotation data for the other chromosomes. (CommaDelimitedListOfStrings)</p>
</blockquote>

<h4>--infileList:</h4>

<blockquote>
  <p>If this option is set, then the infile parameter is a text file containing a list of input VCF files (one per line), rather than a simple path to a single VCF file. Multiple VCF files will be concatenated and used as input. Note that only the first file's headers will be used, and if any of the subsequent files have tags or fields that are not present in the first VCF file then errors may occur. Also note that if the VCF file includes sample genotypes then the samples MUST be in the same order. (flag)</p>
</blockquote>

<h4>--infileListInfix infileList.txt:</h4>

<blockquote>
  <p>If this command is included, then all input files are treated very differently. The input VCF file path (or multiple VCFs, if you are running a VCF merge of some sort) must contain a BAR character. The file path string will be split at the bar character and the string infixes from the supplied infileList.txt infix file will be inserted into the break point. This can be very useful for merging multiple chromosomes or genomic-region-split VCFs. (String)</p>
</blockquote>

<h4>--listInfix infix1,infix2,...:</h4>

<blockquote>
  <p>If this command is included, then all input files are treated very differently. The input VCF file path (or multiple VCFs, if you are running a VCF merge of some sort) must contain a BAR character. The file path string will be split at the bar character and the string infixes from the supplied list will be inserted into the break point. This can be very useful for merging multiple chromosomes or genomic-region-split VCFs. (String)</p>
</blockquote>

<h4>--numLinesRead N:</h4>

<blockquote>
  <p>If this parameter is set, then the utility will stop after reading in N variant lines. Intended for testing purposes. (Int)</p>
</blockquote>

<h3>Output Parameters:</h3>

<h4>--splitOutputByChrom:</h4>

<blockquote>
  <p>If this option is set, the output will be split up into parts by chromosome. NOTE: The outfile parameter must be either a file prefix (rather than a full filename), or must be a file prefix and file suffix separated by a bar character. In other worse, rather than being 'outputFile.vcf.gz', it should be either just 'outputFile' or 'outputFile.|.vcf.gz'.  (flag)</p>
</blockquote>

<h4>--splitOutputByBed intervalBedFile.bed:</h4>

<blockquote>
  <p>If this option is set, the output will be split up into multiple VCF files based on the supplied BED file. An output VCF will be created for each line in the BED file. If the BED file has the 4th (optional) column, and if this 'name' column contains a unique name with no special characters then this name column will be used as the infix for all the output VCF filenames. If the BED file name column is missing, non-unique, or contains illegal characters then the files will simply be numbered. NOTE: If this option is used, then the 'outfile' parameter must be either a file prefix (rather than a full filename), or must be a file prefix and file suffix separated by a bar character. In other worse, rather than being 'outputFile.vcf.gz', it should be either just 'outputFile' or 'outputFile.|.vcf.gz'.  (String)</p>
</blockquote>

<h3>Other Inputs:</h3>

<h4>--genomeFA genome.fa.gz:</h4>

<blockquote>
  <p>The genome fasta file. Can be gzipped or in plaintext. (String)</p>
</blockquote>

<h4>--groupFile groups.txt:</h4>

<blockquote>
  <p>File containing a group decoder. This is a simple tab-delimited file. The first column on each line is the sample ID. All subsequent tab-delimited entries on that line will be processed as a sample group ID to which the sample belongs. WARNING: make sure ALL columns in the file are categorical. If you include numeric columns then you will get a huge number of groups and may have runtime issues. (String)</p>
</blockquote>

<h4>--paramFile paramFile.txt:</h4>

<blockquote>
  <p>A file containing additional parameters and options. Each parameter must begin with a dash. Leading whitespace will be ignored, and newlines preceded by a backslash are similarly ignored. Lines that begin with a pound sign will be skipped. Trailing parameters (infile, outfile, etc) CANNOT be defined using a parameter file. (paramFile)</p>
</blockquote>

<h3>Annotation:</h3>

<h4>--tallyFile file.txt:</h4>

<blockquote>
  <p>Write a file with a table containing counts for all tallies, warnings and notices reported during the run. (String)</p>
</blockquote>

<h3>Preprocessing:</h3>

<h4>--universalTagPrefix VAK_:</h4>

<blockquote>
  <p>Set the universal tag prefix for all vArmyKnife INFO and FORMAT tags. By default it is VAK_. Warning: if you change this at any point, then all subsequent vArmyKnife commands may need to be changed to match, as vArmyKnife sometimes expects its own tag formatting. (String)</p>
</blockquote>

<h3>OTHER OPTIONS:</h3>

<h4>--verbose:</h4>

<blockquote>
  <p>Flag to indicate that debugging information and extra progress information should be sent to stderr. (flag)</p>
</blockquote>

<h4>--quiet:</h4>

<blockquote>
  <p>Flag to indicate that only errors and warnings should be sent to stderr. (flag)</p>
</blockquote>

<h4>--debugMode:</h4>

<blockquote>
  <p>Flag to indicate that much more debugging information should be sent to stderr. (flag)</p>
</blockquote>

<h4>--createRunningFile filename.txt:</h4>

<blockquote>
  <p>A file to create when this utility starts, to be deleted on a clean exit. The file WILL be deleted even if errors are caught. It will only remain if uncaught errors are thrown or if the process is killed externally. (String)</p>
</blockquote>

<h4>--successfulCompletionFile filename.txt:</h4>

<blockquote>
  <p>A file to create if and when this utility successfully completes without fatal errors. (String)</p>
</blockquote>

</section> <h1>VARIANT OPERATIONS</h1> <section>

<pre><code>Variant Operations or Variant Map Functions are a set of sub-utilities that perform operations on 
    a variant set one variant at a time. When more than one function is specified in a run, these 
    functions are performed in the order that they appear in the command line, after all other 
    operations have been carried out (excluding output ops).
Basic Syntax:
    --FCN functionName|ID|param1=p1|param2=p2|...

functionName: one of the functions listed below.
ID: The ID for this particular operation run. This will be used in warning/error messages and in 
    the header metadata. It is recommended that this ID be unique. In some functions this ID is 
    used to determine the INFO field names.
param1,param2,...: Most functions take one or more parameters. Parameters are specified with the 
    format: param=value, where param is the parameter ID listed in the documentation below.
</code></pre>

</section> <h2>Available Operations</h2> <section>

<h5>General-Purpose Tools</h5>

<h3>addInfo</h3>

<blockquote>
  <p>This is a set of functions that all take one or more input parameters and outputs one new INFO field. The syntax is: --fcn "addInfo|newTagName|fcn(param1,param2,...)". Optionally you can add "|desc=tag description". There are numerous addInfo functions. See the section in the help doc titled INFO TAG FUNCTIONS, or use the help command: varmyknife help addInfo</p>
</blockquote>

<pre><code>func: (String, required)
desc: The description in the header line for the new INFO field.(String, default=No desc 
    provided)
</code></pre>

<h6>Example 1:</h6>

<pre><code>Make a new INFO field which is the maximum from several allele frequencies (which are already in 
    the file) Then make a 0/1 INFO field that is 1 if the max AF is less than 0.01. Note the 
    CONST:0 term, which allows you to include constant values in these functions. In this case it 
    makes it so that if the AF is missing in all three populations, the maxAF will be 0 rather 
    than missing.
varmyknife walkVcf \
--fcn "addInfo|maxAF|MAX(CEU_AF,AFR_AF,JPT_AF,CONST:0)|\
desc=The max allele frequency from CEU_AF, AFR_AF, or JPT_AF (or zero if all are missing)."\
--fcn "addInfo|isRare|EXPR(INFO.lt:maxAF:0.01)"\
infile.vcf.gz outfile.vcf.gz
</code></pre>

<h6>End Example</h6>

<h6>Example 2:</h6>

<pre><code>varmyknife walkVcf \
--fcn "addInfo|CarryCt|SUM(hetCount,homAltCount)|\
desc=The sum of the info tags: hetCount and homAltCount."\
infile.vcf.gz outfile.vcf.gz
</code></pre>

<h6>End Example</h6>

<h3>addFormat</h3>

<blockquote>
  <p>This is a set of functions that all take one or more input parameters and outputs one new FORMAT field. The syntax is: --fcn "addInfo|newTagName|fcn(param1,param2,...)". Optionally you can add "|desc=tag description". There are numerous addInfo functions. For more information, go to the section on addFormat Functions below, or use the help command: varmyknife help addFormat</p>
</blockquote>

<pre><code>func: (String, required)
desc: The description in the header line for the new INFO field.(String, default=No desc 
    provided)
</code></pre>

<h6>Example 1:</h6>

<pre><code>This example makes a new FORMAT field which is the ratio between the coverage on the first ALT 
    allele and the total coverage across all alleles.
varmyknife walkVcf \
--fcn "addFormat|AlleleDepth_ALTALLE|extractIDX(AD,1)|\
desc=The observed allele depth for the first alt allele."\
--fcn "addFormat|AlleleDepth_TOTAL|SUM(AD)|\
desc=The observed allele depth for the first alt allele."\
infile.vcf.gz outfile.vcf.gz
</code></pre>

<h6>End Example</h6>

<h6>Example 2:</h6>

<pre><code>varmyknife walkVcf \
--fcn "addInfo|CarryCt|SUM(hetCount,homAltCount)|\
desc=The sum of the info tags: hetCount and homAltCount."\
infile.vcf.gz outfile.vcf.gz
</code></pre>

<h6>End Example</h6>

<h3>sampleCounts</h3>

<blockquote>
  <p>This function generates counts and frequencies for alt alleles, alt genotypes, missing genotypes, ref genotypes, and so on. Note that there are several calc- flags. If none of these are included, then this function does nothing.</p>
</blockquote>

<pre><code>groupFile: A tab-delimited file containing sample ID's and a list of group IDs for each sample. 
    See the --groupFile parameter of walkVcf.(String)
inputGT: The input genotype FORMAT field.(String)
noCountsCalc: If this is set, then no Ct fields will be generated.(Flag)
noFreqCalc: If this is set, then no Freq fields will be generated.(Flag)
noMissCalc: If this is set, then Ct and Freq fields will not be generated to count the number or 
    rate of missing genotypes.(Flag)
noAlleCalc: If this is set, then Ct and Freq fields will not be generated to count allele counts 
    and frequencies.(Flag)
noHetHomCalc: If this is set, then Ct and Freq fields will not be generated to count the number 
    of HomAlt and Het genotypes.(Flag)
noMultiHetCalc: If this is set, then the number of multiallelic heterozygotes will not be 
    counted.(Flag)
addOtherCountsCalc: If this is set, additional optional counts will be added.(Flag)
expr: The variant expression, which is a true/false expression using the variant expression 
    syntax.(String)
</code></pre>

<h3>sampleLists</h3>

<blockquote>
  <p>This function generates sample list fields which contain comma-delimited lists of samples that are het or hom-alt.</p>
</blockquote>

<pre><code>inputGT: The input genotype FORMAT field.(String)
samplePrintLimit: (String)
groupFile: A tab-delimited file containing sample ID's and a list of group IDs for each sample. 
    See the --groupFile parameter of walkVcf.(String)
expr: The variant expression, which is a true/false expression using the variant expression 
    syntax.(String)
</code></pre>

<h3>depthStats</h3>

<blockquote>
  <p>This function calculates various statistics on total read depth and hetAB.</p>
</blockquote>

<pre><code>inputGT: The input genotype FORMAT field.(String)
inputAD: The input allele depth or AD field.(String)
inputDP: The input total depth or DP field.(String)
restrictToGroup: If this variable is set, then all stats will be restricted to the given sample 
    subgroup. Note that sample group information must be supplied either for this function or 
    globally using the --groupFile parameter.(String)
groupFile: A tab-delimited file containing sample ID's and a list of group IDs for each sample. 
    See the --groupFile parameter of walkVcf.(String)
</code></pre>

<h3>calcStats</h3>

<blockquote>
  <p>This function combines the functions sampleCounts, sampleLists, and depthStats, performing all three.</p>
</blockquote>

<pre><code>groupFile: A tab-delimited file containing sample ID's and a list of group IDs for each sample. 
    See the --groupFile parameter of walkVcf.(String)
inputGT: The input genotype FORMAT field.(String)
inputAD: The input allele depth or AD field.(String)
inputDP: The input total depth or DP field.(String)
noCountsCalc: If this is set, then no Ct fields will be generated.(Flag)
noFreqCalc: If this is set, then no Freq fields will be generated.(Flag)
noMissCalc: If this is set, then Ct and Freq fields will not be generated to count the number or 
    rate of missing genotypes.(Flag)
noAlleCalc: If this is set, then Ct and Freq fields will not be generated to count allele counts 
    and frequencies.(Flag)
noHetHomCalc: If this is set, then Ct and Freq fields will not be generated to count the number 
    of HomAlt and Het genotypes.(Flag)
noMultiHetCalc: If this is set, then the number of multiallelic heterozygotes will not be 
    counted.(Flag)
addOtherCountsCalc: If this is set, additional optional counts will be added.(Flag)
samplePrintLimit: This limits the number of samples that will be listed in the SAMPLIST fields. 
    This can be useful to reduce file sizes and prevent problems when importing into excel due to 
    overly long fields.(String)
noDepthStats: If this is set, depth statistic fields (including total depth, depth quantiles, and 
    hetAB stats) will not be created.(Flag)
noSampleLists: If this is set, then SAMPLIST fields will not be generated.(Flag)
noSampleCounts: If this is set, then sample count and frequency fields will not be 
    generated.(Flag)
expr: The variant expression, which is a true/false expression using the variant expression 
    syntax.(String)
</code></pre>

<h3>addVariantIdx</h3>

<blockquote>
  <p>This function adds a new INFO column with a unique numeric value for each line. Optionally, you can add a prefix to each ID.</p>
</blockquote>

<pre><code>prefix: Prefix to prepend to the index field.(String)
</code></pre>

<h3>addVariantPosInfo</h3>

<blockquote>
  <p>This function adds a new INFO field in the form: CHROM:START:REF>ALT. This can be useful for checking the effects of functions that alter the variant columns. For example, you can run this function before and after leftAlignAndTrim to see how a variant changes.</p>
</blockquote>

<pre><code>(This function takes no parameters)
</code></pre>

<h3>markDup</h3>

<blockquote>
  <p>This map function will detect duplicate variant lines and add two new INFO fields: mapID_CT and mapID_IDX. The CT will indicate how many duplicates were found matching the current variant, and the IDX will number each duplicate with a unique identifier, counting from 0. All nonduplicates will be marked with CT=1 and IDX=0. VCF FILE MUST BE SORTED!</p>
</blockquote>

<pre><code>(This function takes no parameters)
</code></pre>

<h3>mergeDup</h3>

<blockquote>
  <p>Merges duplicated lines. NOTE: REQUIRES THE VCF TO BE SORTED. NOTE: DOES NOT WORK ON GENOTYPES.NOTE: Splitting multiallelics and left-align-and-trim are also require for it to work properly with multiallelics and indels respectively.</p>
</blockquote>

<pre><code>(This function takes no parameters)
</code></pre>

<h5>Variant Formatting/Conversion</h5>

<h3>fixFirstBaseMismatch</h3>

<blockquote>
  <p>This utility will extend indels in which the first base is not a matching base. Certain variant processing tools may use blanks to mark indels or may not begin combination insertion-deletion variants with a matching base (this latter case is technically legal VCF, but some tools may throw errors). </p>
</blockquote>

<pre><code>windowSize: Sets the size of the sliding window used. Problems may occur if you have variants 
    longer than this window size. Default is 200bp.(Int)
genomeFA: The genome fasta file containing the reference genome. This will be used by various 
    functions that require genomic information. Note that some functions that call the GATK 
    library will also require that the fasta be indexed. Note: Chromosome names must 
    match.(String, required)
</code></pre>

<h3>leftAlignAndTrim</h3>

<blockquote>
  <p>This utility performs the exact same operations as GATK leftAlignAndTrim. It trims excess bases and shifts ambiguously-positioned indels to their leftmost possible position. This can assist in ensuring that variants are consistantly represented which is critical in matching indels between files. IMPORTANT: if there are multiallelic variants then they MUST be split apart before this step. You can use the splitMultiAllelics function to do this.</p>
</blockquote>

<pre><code>windowSize: Sets the size of the sliding window used. Problems may occur if you have variants 
    longer than this window size. Default is 200bp.(Int)
genomeFA: The genome fasta file containing the reference genome. This will be used by various 
    functions that require genomic information. Note that some functions that call the GATK 
    library will also require that the fasta be indexed. Note: Chromosome names must 
    match.(String, required)
</code></pre>

<h3>fixSwappedRefAlt</h3>

<blockquote>
  <p>This utility searches for cases where the REF and ALT bases are swapped.</p>
</blockquote>

<pre><code>genomeFA: The genome fasta file containing the reference genome. This will be used by various 
    functions that require genomic information. Note that some functions that call the GATK 
    library will also require that the fasta be indexed. Note: Chromosome names must 
    match.(String, required)
</code></pre>

<h3>splitMultiAllelics</h3>

<blockquote>
  <p>This utility takes any multiallelic variables and splits them apart so that each line contains only one ALT allele. There are two options for how this will be carried out. The default creates several new FORMAT fields. TODO explain more! ...Thus after the split the multiallelics will have an ALT field of the form A,* and the GT field and AD field will use this coding. Thus if a sample has one of the other alt alleles then </p>
</blockquote>

<pre><code>useStarAlle: If this flag is used, the asterisk allele will be used as a placeholder for all 
    other alleles. See the explanation above.(Flag)
treatOtherAsRef:  (Flag)
</code></pre>

<h3>fixDotAltIndels</h3>

<blockquote>
  <p>...</p>
</blockquote>

<pre><code>genomeFA: The genome fasta file containing the reference genome. This will be used by various 
    functions that require genomic information. Note that some functions that call the GATK 
    library will also require that the fasta be indexed. Note: Chromosome names must 
    match.(String, required)
</code></pre>

<h3>addAltSequence</h3>

<blockquote>
  
</blockquote>

<pre><code>windowSize: The number of flanking bases to include on each side of the alt sequence.(String, 
    default=10)
genomeFA: The genome fasta file containing the reference genome. This will be used by various 
    functions that require genomic information. Note that some functions that call the GATK 
    library will also require that the fasta be indexed. Note: Chromosome names must 
    match.(String, required)
</code></pre>

<h5>File/Database Annotation</h5>

<h3>tagBedFile</h3>

<blockquote>
  <p>This function takes a BED file (which can be gzipped if desired) and creates a new INFO field based on whether the variant locus overlaps with a genomic region in the BED file. The new field can be either an integer that is equal to 1 if there is overlap and 0 otherwise (which is the default behavior) Or, alternatively, it can copy in the title field from the bed file. NOTE: this function only uses the first 3 to 5 fields of the BED file, it does not implement the optional fields 10-12 which can specify intron/exon blocks.</p>
</blockquote>

<pre><code>file: (String, required)
desc: The description for the new INFO line.(String, default=No desc provided)
buffer: The additional buffer to add around each BED element.(Integer, default=0)
style: This determines the type of INFO tag. For +, the new tag will be a dichotomous 0/1 numeric 
    variable that will equal 1 if and only if the variant intersects with one or more BED lines 
    (including buffer, noted above). For - the opposite is true. For LABEL, the new tag will be a 
    String variable with the title of the element(s) that intersect with the variant, comma 
    delimited. Note that for LABEL style the BED file must have a 4th column.(String, default=+)
</code></pre>

<h3>snpSiftAnno</h3>

<blockquote>
  <p>This function runs a SnpSift anno command. SnpSift's java library has been packaged internally within vArmyKnife and is called directly, producing results identical to a separate snpSift command.</p>
</blockquote>

<pre><code>cmd: A valid SnpSift command. In general you should specify the -info and -name options followed 
    by a VCF file to annotate with. (String)
</code></pre>

<h6>Example 1:</h6>

<pre><code>This example annotates the current VCF file with the AC and AN fields from another VCF file. Note 
    that the annotation VCF file must be sorted and indexed using tabix.
varmyknife walkVcf \
--fcn "snpSiftAnno|gnomad|cmd=-info AC,AN -name GNOM_ /path/to/anno/file/gnomad.vcf.gz "\
infile.vcf.gz outfile.vcf.gz
</code></pre>

<h6>End Example</h6>

<h3>snpSiftAnnoMulti</h3>

<blockquote>
  <p>This function runs several snpSiftAnno commands one after another. See the help for the snpSiftAnno function above. This will be faster than several separate snpSiftAnno function calls. It uses SnpEff/Sift version 4.3t.</p>
</blockquote>

<pre><code>cmds: A semicolon delimited list of valid snpSift commands.(String)
</code></pre>

<h3>snpSiftDbnsfp</h3>

<blockquote>
  <p>This function runs the SnpSift dbnsfp command. SnpSift's java library has been packaged internally within vArmyKnife and is called directly, producing results identical to a separate snpSift command. It uses SnpEff/Sift version 4.3t.</p>
</blockquote>

<pre><code>cmd: A valid SnpSift command(String)
</code></pre>

<h6>Example 1:</h6>

<pre><code>This example annotates the current VCF file with a DBNSFP database that has been downloaded and 
    prepared by SNPSIFT.
varmyknife walkVcf \
--fcn "snpSiftDbnsfp|dbnsfp|cmd=-f genename,cds_strand,refcodon -db 
    /path/to/db/dbNSFP/v3.5a/dbNSFP3.5a_hg19_sorted.txt.gz "\
infile.vcf.gz outfile.vcf.gz
</code></pre>

<h6>End Example</h6>

<h3>snpEff</h3>

<blockquote>
  <p>This function runs SnpEff by calling the SnpEff library internally. It uses SnpEff version 4.3t.</p>
</blockquote>

<pre><code>cmd: A valid SnpSift command.(String)
</code></pre>

<h6>Example 1:</h6>

<pre><code>varmyknife walkVcf
--fcn "snpEff|mySnpEffRun_1|cmd=GRCh37.75 -noout -c snpEff.config -v -noStats -lof -motif 
    -nextprot"
infile.vcf.gz outfile.vcf.gz
</code></pre>

<h6>End Example</h6>

<h3>snpEffExtract</h3>

<blockquote>
  <p>This utility is designed to extract information from ANN fields generated by either SNPEFF or VEP. While the ANN field contains a large amount of information, the structure and organization of this field is often difficult to parse and operate on. ANN fields are structured as a series of entries each specifying a gene, transcript, and effect. For example, if a variant causes a missense change in transcript A and causes a splicing change in transcript B then there would be two entries, one for each effect. This function can extract whatever specific information desired from the ANN-formatted field and filters, collates, and reorganizes it in a way that is easier to use. The various keep and drop lists allow you to extract or ignore ANN entries based on biotype, effect, or warnings. The geneList function allows you to specify a gene list, any entries that do not pertain to a gene on that list will be ignored. This can allow you to (for example) create a new field that lists the effects only for the desired gene(s). This can avoid certain common errors. For example: where one extracts a gene list and then extracts all Loss-of-Function variants and ends up with a number of variants that have synonymous effect or simply nearby a gene of interest but are also loss-of-function for some other gene which is NOT a gene of interest.</p>
</blockquote>

<pre><code>annTag: A valid ANN formatted field, usually generated by SNPeff.(String, default=ANN)
bioTypeKeepList: A comma delimited list of the transcript biotypes that you want to keep. All 
    other biotypes will be ignored.(String)
effectKeepList: A comma delimited list of the effect types that you want to keep. All other 
    EFFECT values will be ignored.(String)
warningDropList: A comma delimited list of warnings. Any entries that include a listed warning 
    will be ignored.(String)
geneList: If this variant is set, then all operations will be restricted to only the ANN entries 
    that correspond to any gene in the supplied list of genes. This can be useful for extracting 
    only the effect on specific genes of interest.(String)
geneListName: The name you want to give to the given gene list. Should only be used in 
    conjunction with the geneList option.(String)
severityList: Must be a list of severity levels, listed as some combination of effectseverity 
    types delimited with slashes. Legal types are: HIGH, MODERATE, LOW, and MODIFIER, which are 
    standard SnpEFF effect types, and also: NS (HIGH and MODERATE), NonNS (LOW and MODIFIER), and 
    ANY (any type).(String, default=HIGH/MODERATE/LOW)
extractFields: This is a complex multi-part field that allows flexible extraction of information 
    from SnpEff ANN tags. This field must be in the colon-delimited format 
    tagInfix:ANN_idx:description:severityList[:noCollapse]. severityList must be in the same 
    format as the severityList parameter above, but can override the default if desired. ANN_idx 
    must be a slash-delimited list of field indices counting from zero in the ANN tag. The 
    standard ANN field indices are: 0:allele,1:effect,2:impact,3:geneName,4:geneID,5:txType,6:txI-
    D,7:txBiotype,8:rank,9:HGVS.c,10:HGVS.p,11:cDNAposition,12:cdsPosition,13:proteinPosition,14:-
    distToFeature,15:warnings,16:errors If multiple fields are selected then the output fields 
    will have the format first:second:third:etc. For example, to create two new fields containing 
    a list of all genes for which the current variant has HIGH and MODERATE impact respectively, 
    use the format: myNewField:4:my description:HIGH/MODERATE. This will generate two new fields: 
    myNewField_HIGH and myNewField_MODERATE. Note that if this function as a whole has a mapID 
    set, then both field names will be prefixed by that overall ID.(String)
geneNameIdx: This sets the index of the geneName to be used for collating information by gene. By 
    default this is set to 4 which as per the ANN field specification is the "geneID" (usually 
    the ensembl ID). If desired this can be set to 3 which is the "common gene name" (usually the 
    gene symbol), or even 6 which is the transcriptID (which will cause this tool to perform all 
    operations on the transcript level rather than the gene level. This variable can also be 
    useful if you have a nonstandard ANN-style input.(String, default=4)
biotypeIdx: This sets the ANN field index for the warning field. As per the specification of the 
    ANN field this should always be set to the default (7), but for certain older versions it may 
    be different.(String, default=7)
warnIdx: This sets the ANN field index for the warning field. As per the specification of the ANN 
    field this should always be set to the default (15), but for certain older versions it may be 
    different.(String, default=15)
</code></pre>

<h6>Example 1:</h6>

<pre><code>The following command will extract various useful information from the ANN field. Entries that do 
    not refer to protein coding transcripts will be ignored. Entries that refer to effects that 
    are not included in the provided effectKeepList will be ignored. Any entries with the listed 
    warnings will be ignored. Several types of output fields will be generated for various effect 
    severities.
GENEEFFECT: This will be a list of geneName:Effect pairs that pass the above filters.
ENSGID: This will be a list of ensemble gene ID's from any entries that pass the above filters.
ENSTID: This will be a list of ensemble transcript ID's from any entries that pass the above 
    filters.
TXCHANGE: These will be a list of TXID:HGVSc transcript change pairs that pass the above filters.
FIRSTEFFECT: Like the GENEEFFECT fields, this will be a list of geneName:Effect pairs that pass 
    the above filters, but if multiple effects are listed it will only list the first effect.

New fields will be created for each of the above and each of the listed effect severities. For 
    example:
ANNEX_GENEEFFECT_HIGH: This will list only gene:effect pairs that pass the above filters and have 
    severity HIGH.
ANNEX_GENEEFFECT_MODERATE: This will list only gene:effect pairs that pass the above filters and 
    have severity MODERATE.
ANNEX_GENEEFFECT_NS: This will list only gene:effect pairs that pass the above filters and have 
    severity HIGH or MODERATE.
and so on...

varmyknife walkVcf
--fcn "snpEffExtract|ANNEX|annTag=ANN|\
bioTypeKeepList=protein_coding\
effectKeepList=\
coding_sequence_variant,inframe_insertion,disruptive_inframe_insertion,\
conservative_inframe_insertion,inframe_deletion,disruptive_inframe_deletion,\
conservative_inframe_insertion,exon_variant,exon_loss_variant,duplication,\
inversion,frameshift_variant,missense_variant,start_retained_variant,\
stop_retained_variant,initiator_codon_variant,rare_amino_acid_variant,\
splice_acceptor_variant,splice_donor_variant,stop_lost,start_lost,stop_gained,\
synonymous_variant,start_retained,splice_region_variant,\\n 
    5_prime_UTR_premature,start_codon_gain_variant,\
3_prime_UTR_truncation,5_prime_UTR_truncation,\
3_prime_UTR_variant,5_prime_UTR_variant,\
intron_variant,conserved_intron_variant\
warningDropList=WARNING_TRANSCRIPT_INCOMPLETE,WARNING_TRANSCRIPT_MULTIPLE_STOP_CODONS,\
WARNING_TRANSCRIPT_NO_START_CODON,WARNING_TRANSCRIPT_NO_STOP_CODON\
extractFields=GENEEFFECT:3/FIRSTEFFECT:set of gene-effect pairs:HIGH/MODERATE/NS:.,\
ENSGID:4:Gene ensemble ID:HIGH/NS:.,\
ENSTID:6:Affected Transcript ID:HIGH/NS:.,\
TXCHANGE:6/9:TranscriptID and HGVSc change:HIGH/NS:.,\
FIRSTEFFECT:FIRSTEFFECT:Extracted First Effect:HIGH/MODERATE/LOW/NS/ANY:.|\
geneNameIdx=3\
severityList=HIGH/MODERATE/NS/LOW"\
infile.vcf.gz outfile.vcf.gz
</code></pre>

<h6>End Example</h6>

<h3>getLocusDepthFromWig</h3>

<blockquote>
  <p>This utility takes a .wig file (aka a wiggle file) and annotates each variant with the depth indicated in the wiggle file for the variant site.</p>
</blockquote>

<pre><code>wigFile: The input wiggle file.(String)
desc: The description for the new INFO field, to be included in the INFO line.(String)
</code></pre>

<h3>addDistToFeature</h3>

<blockquote>
  <p>This utility takes a simple 2-column text file. the first column must be the chrom ID and the second column must be position. A new integer info field will be added that is equal to the distance to the nearest position in the file. If there is no listed position on the given chromosome then the info field will be missing.</p>
</blockquote>

<pre><code>file: The input text file. Must have 2 columns, chrom and pos(String)
desc: The description for the new INFO field, to be included in the INFO line.(String)
</code></pre>

<h5>Genotype Processing</h5>

<h3>unPhaseAndSortGenotypes</h3>

<blockquote>
  <p>This function removes phasing and sorts genotypes (so that heterozygotes are always listed as 0/1 and never 1/0).</p>
</blockquote>

<pre><code>inputGT: The input/output genotype FORMAT field.(String)
groupFile: A tab-delimited file containing sample ID's and a list of group IDs for each sample. 
    See the --groupFile parameter of walkVcf.(String)
</code></pre>

<h3>genotypeFilter</h3>

<blockquote>
  <p>This function filters a genotype field based on a given genotype expression. The new filtered genotype can replace the GT field or can be set to a different field, so multiple filtering strategies can be included in a single VCF.</p>
</blockquote>

<pre><code>expr: A Genotype Expression, using the genotype expression syntax.(String, required)
desc: A description, to go in the new FORMAT fields.(String)
filterTag: The name of a new FORMAT field, which will be a flag equal to 1 if and only if the 
    genotype passes the filter.(String)
outputGT: The output genotype FORMAT field. If this is the same as the input genotype field then 
    the genotype field will be overwritten.(String)
inputGT: The input genotype FORMAT field.(String)
inputGtNewName: If this parameter is set, the input genotype field will be copied to a new tag 
    with this name before filtering. This can be useful if overwriting the input genotype field.()
groupFile: A tab-delimited file containing sample ID's and a list of group IDs for each sample. 
    See the --groupFile parameter of walkVcf.(String)
</code></pre>

<h3>genotypeSelect</h3>

<blockquote>
  <p>This function selects between two different a genotype fields based on a given genotype expression. The new composite genotype can replace either GT field or can be set to a different field, so multiple filtering strategies can be included in a single VCF.</p>
</blockquote>

<pre><code>expr: A Genotype Expression, using the genotype expression syntax.(String, required)
desc: A description, to go in the new FORMAT fields.(String)
outputGT: The output genotype FORMAT field. If this is the same as the input genotype field then 
    the genotype field will be overwritten.(String)
inputGTifTRUE: The input genotype FORMAT field to be used if the expression returns TRUE.(String, 
    required)
inputGTifFALSE: The input genotype FORMAT field to be used if the expression returns 
    FALSE.(String, required)
missingString: The string to use when setting the variable to missing.(String)
groupFile: A tab-delimited file containing sample ID's and a list of group IDs for each sample. 
    See the --groupFile parameter of walkVcf.(String)
</code></pre>

<h5>Concordance Caller</h5>

<h3>concordanceCaller</h3>

<blockquote>
  <p>....</p>
</blockquote>

<pre><code>callerNames: Comma delimited list of caller IDs, used in the callerSet INFO fields and the names 
    of the output GT fields. By default, callers will simply be named C1,C2,...(String)
priority: Comma delimited list of caller IDs. The list of caller IDs in order of descending 
    priority.(String)
gtDecisionMethod: The merge rule for calculating ensemble-merged GT and AD tags. Valid options 
    are priority, prioritySkipMissing, and majority_priorityOnTies. Default is simple 
    priority.(String)
ignoreSampleIds: If this flag is set, then sample IDs will be ignored and each VCF will be 
    assumed to have the exact same samples in the exact same order. Use at your own risk.(flag)
ignoreSampleOrder: If this flag is set, then the sample IDs will be used to match up the 
    different VCFs, and the samples may be in different orders in the different files.(flag)
</code></pre>

<h5>Filtering</h5>

<h3>keepVariants</h3>

<blockquote>
  <p>This function drops variants based on a given true/false expression.</p>
</blockquote>

<pre><code>expr: A variant-level expression. See the HELP section on Variant-Level Logical 
    Expressions.(String, required)
</code></pre>

<h3>extractRegion</h3>

<blockquote>
  <p>This function extracts a single region from the VCF. NOTE: the VCF MUST BE SORTED!</p>
</blockquote>

<pre><code>region: The genomic region to extract.(String, required)
windowSize: The size of the window around the genomic region to extract.(Int)
</code></pre>

<h3>dropNullVariants</h3>

<blockquote>
  <p>This drops variants if they appear beyond the endpoint of the genome builds chromosome. Certain tools will occasionally create variants like this and they will crash many other functions like left-align-and-trim or GC-content calculations, etc.</p>
</blockquote>

<pre><code>genomeFA: The genome fasta file containing the reference genome. This will be used by various 
    functions that require genomic information. Note that some functions that call the GATK 
    library will also require that the fasta be indexed. Note: Chromosome names must 
    match.(String, required)
</code></pre>

<h3>dropVariantsBeyondChromEnd</h3>

<blockquote>
  <p>This function drops all lines with no alt alleles ('.' in the ALT column), or lines where the ALT allele is identical to the REF. Note: you must split multiallelics first. See the 'splitMultiallelics' function.</p>
</blockquote>

<pre><code>(This function takes no parameters)
</code></pre>

<h3>dropSpanIndels</h3>

<blockquote>
  <p>This function drops Spanning indel lines ('*' alleles). Note: you must split multiallelics first!</p>
</blockquote>

<pre><code>(This function takes no parameters)
</code></pre>

<h3>rmDup</h3>

<blockquote>
  <p>This utility detects identical variant lines and deletes any excess beyond the first. NOTE: VCF FILE MUST BE SORTED!</p>
</blockquote>

<pre><code>(This function takes no parameters)
</code></pre>

<h3>dropSymbolicAlleles</h3>

<blockquote>
  <p>This utility strips all symbolic alleles. See the VCF v4.2 specification for more information on what those are and what they are used for. Many older tools will return errors if fed symbolic alleles.</p>
</blockquote>

<pre><code>(This function takes no parameters)
</code></pre>

<h3>dropVariantsWithNs</h3>

<blockquote>
  <p>This utility drops variants if they contain Ns in either the REF or ALT columns.</p>
</blockquote>

<pre><code>(This function takes no parameters)
</code></pre>

<h5>Genomic Locus Annotation</h5>

<h3>homopolymerRunStats</h3>

<blockquote>
  <p>This tool adds several new INFO tags that indicate whether the variant is near a homopolymer run, and if so, whether it extends or truncates that run.</p>
</blockquote>

<pre><code>runSize: The number of repeated bases required to count as a homopolymer run(String, required)
genomeFA: The genome fasta file containing the reference genome. This will be used by various 
    functions that require genomic information. Note that some functions that call the GATK 
    library will also require that the fasta be indexed. Note: Chromosome names must 
    match.(String, required)
</code></pre>

<h3>addContextBases</h3>

<blockquote>
  <p>This function adds several new INFO fields which list the base pairs flanking the variant.</p>
</blockquote>

<pre><code>windowSize: The number of bases to include in the context window(String, required)
genomeFA: The genome fasta file containing the reference genome. This will be used by various 
    functions that require genomic information. Note that some functions that call the GATK 
    library will also require that the fasta be indexed. Note: Chromosome names must 
    match.(String, required)
</code></pre>

<h3>addTrinucleotideComplexity</h3>

<blockquote>
  <p>This function adds a new INFO field containing the trinucleotide complexity for the given genomic window around the variant locus, defined as the sum of the squares of the proportions of each 3-bp combination.</p>
</blockquote>

<pre><code>windowSize: The number of bases to include in the context window(String, required)
genomeFA: The genome fasta file containing the reference genome. This will be used by various 
    functions that require genomic information. Note that some functions that call the GATK 
    library will also require that the fasta be indexed. Note: Chromosome names must 
    match.(String, required)
</code></pre>

<h3>gcContext</h3>

<blockquote>
  <p>This function calculates the fraction of bases within k bases from the variant locus that are G or C. This can be useful to identify high-GC areas where variant calling and sequencing may be less accurate.</p>
</blockquote>

<pre><code>windowSize: The number of bases to include in the context window for determining local gc 
    content.(String, required)
digits: Number of digits to round to.(String, default=4)
genomeFA: The genome fasta file containing the reference genome. This will be used by various 
    functions that require genomic information. Note that some functions that call the GATK 
    library will also require that the fasta be indexed. Note: Chromosome names must 
    match.(String, required)
</code></pre>

<h3>checkReferenceMatch</h3>

<blockquote>
  <p>This function compares the REF column to the genomic reference and makes sure that they actually match. If mismatches are found, a warning will be thrown. In addition, a new INFO field will be added to the VCF that will be a simple integer field that will equal 1 if and only if the REF matches the reference, and 0 otherwise.</p>
</blockquote>

<pre><code>genomeFA: The genome fasta file containing the reference genome. This will be used by various 
    functions that require genomic information. Note that some functions that call the GATK 
    library will also require that the fasta be indexed. Note: Chromosome names must 
    match.(String, required)
</code></pre>

<h5>Data/Table Extraction</h5>

<h3>tally</h3>

<blockquote>
  <p>This is a set of functions that takes various stats from each variant and sums them up across the whole VCF. These functions DO NOT change the VCF itself, they simply emit meta information about the VCF. See the help section on TALLY FUNCTIONS.</p>
</blockquote>

<pre><code>func: (String, required)
</code></pre>

<h3>calculateMatchMatrix</h3>

<blockquote>
  <p>....</p>
</blockquote>

<pre><code>file: (String, required)
gtTag: The genotype FORMAT field.(String, default=GT)
matchCutoff: matches below this threshold will not be written to file.(Float, default=0.5)
</code></pre>

<h3>extractFormatMatrix</h3>

<blockquote>
  <p>This utility will create a matrix file with information extracted from the FORMAT fields of the VCF. There are two optional formats: standard and longForm. Standard format will have each variant output a row, the first columns will be Chrom/pos/id/ref/alt (unless noVarInfo is used, in which case these will be ommitted), followed by the info fields listed in the infoFields param, followed by one cell for each sample in the VCF, containing a bar-delimited list of the genotype fields listed in the gtTag parameter. If the longForm option is used, instead each variant will print its own line for each sample. Note that this method is generally easier to manipulate for large sample sets, but will generally result in a much larger file since the variant data is repeated many times.</p>
</blockquote>

<pre><code>file: (String, required)
gtTag: A comma delimited list of the desired FORMAT fields. If more than one is specified then 
    all will be included in the matrix. If written in standard format, each matrix cell will 
    contain the given fields delimited with bars. If in longform format (see the longForm flag 
    below) then these fields will be tab delimited.(String, default=GT)
infoFields: Comma delimited list of info fields to include after the CHROM/POS/ID/REF/ALT in the 
    output matrix.(String, default=.)
longForm: If this flag is used, matrix will be printed in 'long form' in which each element in 
    the matrix gets its own entire line.(Flag)
noVarInfo: If this flag is used, the variant info CHROM/POS/ID/REF/ALT is omitted from each 
    line.(Flag)
</code></pre>

<h3>calcBurdenCounts</h3>

<blockquote>
  <p>This function generates the .</p>
</blockquote>

<pre><code>geneTag: This is the INFO tag that indicates the geneID. It can be a comma-delimited 
    list.(String, required)
expr: This is a true/false variant expression. Variants will only be counted towards a burden 
    test if they pass this expression. This can be used to generate several burden count tables 
    with different filtering strategies in a single run.(String)
sampleSet: This is a list of samples to include. Samples not on this list will be 
    ignored.(String)
group: This is a sample group to include. Samples that are not in this sample group will be 
    ignored. Note that this requires the groupFile variable to be set.(String)
inputGT: This is the FORMAT column to use as the genotype column.(String)
groupFile: A tab-delimited file containing sample ID's and a list of group IDs for each sample. 
    See the --groupFile parameter of walkVcf.(String)
countFileID: If multiple output count files are desired, you can specify which functions output 
    to which count file using this parameter. Note that each file must be created using a 
    --burdenCountsFile parameter, with the form fileID:/path/to/file.txt(String)
</code></pre>

<h3>calcBurdenCountsByGroups</h3>

<blockquote>
  
</blockquote>

<pre><code>geneTag: This is the INFO tag that indicates the geneID. It can be a comma-delimited 
    list.(String, required)
groups: This is a comma delimited list of sample groups, taken from the groupFile.(String, 
    required)
expr: This is a true/false variant expression. Variants will only be counted towards a burden 
    test if they pass this expression. This can be used to generate several burden count tables 
    with different filtering strategies in a single run.(String)
sampleSet: This is a list of samples to include. Samples not on this list will be 
    ignored.(String)
inputGT: This is the FORMAT column to use as the genotype column.(String)
groupFile: A tab-delimited file containing sample ID's and a list of group IDs for each sample. 
    See the --groupFile parameter of walkVcf.(String)
countFileID: If multiple output count files are desired, you can specify which functions output 
    to which count file using this parameter. Note that each file must be created using a 
    --burdenCountsFile parameter, with the form fileID:/path/to/file.txt(String)
</code></pre>

<h3>calcBurdenMatrix</h3>

<blockquote>
  <p>This utility creates a matrix file with </p>
</blockquote>

<pre><code>geneTag: (String, required)
expr: (String)
sampleSet: (String)
group: (String)
inputGT: (String)
geneList: (String)
geneListFile: (String)
printFullGeneList: (flag)
pathwayList: (String)
groupFile: A tab-delimited file containing sample ID's and a list of group IDs for each sample. 
    See the --groupFile parameter of walkVcf.(String)
outfile: The output matrix file path.(String, required)
</code></pre>

<h5>File Formatting/Conversion</h5>

<h3>convertSampleNames</h3>

<blockquote>
  <p>This function converts the sample IDs of the VCF file according to a decoder file that you supply. Your decoder should be a tab-delimited text file with at least 2 columns. One column should specify the FROM sample names as they currently appear in the VCF, and one should specify the new sample names you want them converted TO. You must specify which of these columns is which using either the columnNames or columnIdx parameters. </p>
</blockquote>

<pre><code>file: A tab delimited file with the from/to chromosome names.(String, required)
columnNames: The column titles for the old chrom names and the new chrom names, in that order. If 
    this parameter is used, the decoder file must have a title line.(String)
columnIdx: The column number of the current chromosome names then the new chromosome names, in 
    that order. Column indices start counting from 0. If you use this parameter to set the 
    columns, and if the file has a title line, then you should use skipFirstRow or else it will 
    be read in as if it were a chromosome.(Integer)
skipFirstRow: If this parameter is set, then this tool will skip the first line on the decoder 
    file. This is useful if you are specifying the columns using column numbers but the file also 
    has a title line.(Flag)
</code></pre>

<h3>convertChromNames</h3>

<blockquote>
  <p>This function takes a file and translates chromosome names into a different format. This is most often used to convert between the chr1,chr2,... format and the 1,2,... format.</p>
</blockquote>

<pre><code>file: A tab delimited file with the from/to chromosome names.(String, required)
columnNames: The column titles for the old chrom names and the new chrom names, in that order. If 
    this parameter is used, the decoder file must have a title line.(String)
columnIdx: The column number of the current chromosome names then the new chromosome names, in 
    that order. Column indices start counting from 0. If you use this parameter to set the 
    columns, and if the file has a title line, then you should use skipFirstRow or else it will 
    be read in as if it were a chromosome.(Integer)
skipFirstRow: If this parameter is set, then this tool will skip the first line on the decoder 
    file. This is useful if you are specifying the columns using column numbers but the file also 
    has a title line.(Flag)
</code></pre>

<h3>sampleReorder</h3>

<blockquote>
  <p>This function allows you to reorder the sample columns in your VCF. Set ONE of the parameters below to specify the desired ordering.</p>
</blockquote>

<pre><code>sampleOrdering: A simple list of all the samples, in the desired order.(String)
sampleOrderingFile: A file containing one sampleID per line. The samples will be reordered to 
    match the order found in the file.(String, required)
alphabetical: If this flag is set, then the samples will be reordered alphabetically.(Flag)
</code></pre>

<h3>filterTags</h3>

<blockquote>
  <p>This function can be used to remove unwanted INFO or FORMAT fields, or remove unwanted samples. This can substantially reduce file sizes.</p>
</blockquote>

<pre><code>FORMAT.keep: If this is set, then ALL format fields EXCEPT the ones listed here will be 
    dropped.(String)
FORMAT.drop: IF this is set, then the listed format fields will be dropped.(String)
INFO.keep: If this is set, then ALL info fields EXCEPT the ones listed here will be 
    dropped.(String)
INFO.drop: If this is set, then the listed info fields will be dropped.(String)
SAMPLES.keep: IF this is set, then ALL samples EXCEPT the ones listed here will be 
    dropped.(String)
SAMPLES.drop: If this is set, the listed samples will be dropped.(String)
INFO.rename: This is used to rename INFO fields. This should be set to a comma-delimited list of 
    FROM:TO pairs, with each pair separated with a colon.(String)
FORMAT.rename: This is used to rename FORMAT fields. This should be set to a comma-delimited list 
    of FROM:TO pairs, with each pair separated with a colon.(String)
</code></pre>

<h3>sanitize</h3>

<blockquote>
  <p>This function strips out additional optional fields in the INFO lines which are technically valid according to the VCF specification, but that will be rejected by certain applications including GATK.</p>
</blockquote>

<pre><code>(This function takes no parameters)
</code></pre>

<h3>convertToStdVcf</h3>

<blockquote>
  <p>Certain utilities (eg GATK) do not allow certain optional features of the VCFv4.2 format standard (For example: additional tag-pairs in the INFO or FORMAT header lines). This function strips out this additional metadata.</p>
</blockquote>

<pre><code>(This function takes no parameters)
</code></pre>

<h3>dropGenotypeData</h3>

<blockquote>
  <p>This utility drops the entire genotype table, including all columns from the FORMAT column on.</p>
</blockquote>

<pre><code>(This function takes no parameters)
</code></pre>

<h3>addDummyGenotypeColumn</h3>

<blockquote>
  <p>This utility adds a new genotype column and FORMAT column, containing a simple GT field that is always 0/1. Some utilities will refuse to process files without genotype data or will ignore VCF lines with no alt genotypes.</p>
</blockquote>

<pre><code>(This function takes no parameters)
</code></pre>

<h3>copyColumnToInfo</h3>

<blockquote>
  <p>This utility copies the contents of one of the VCF columns to a new INFO field. Note that some columns allow characters that are not allowed in INFO fields, such as equal signs. Any illegal characters will be automatically replaced with underscores.</p>
</blockquote>

<pre><code>columnID: (String, required)
</code></pre>

<h3>copyInfoToColumn</h3>

<blockquote>
  <p>This utility copies the contents of an INFO field to one of the the other VCF columns.</p>
</blockquote>

<pre><code>infoColumn: (String, required)
columnID: (String, required)
</code></pre>

<h3>copyInfoToGeno</h3>

<blockquote>
  <p>This utility copies the contents of one of the INFO fields into the genotype level.</p>
</blockquote>

<pre><code>info: (String, required)
</code></pre>

<h3>copyAllInfoToGeno</h3>

<blockquote>
  <p>This utility copies the contents of ALL info fields plus the FILTER column into the genotype FORMAT columns. This can be useful for preserving sample-level information stored in the INFO column of a single-sample VCF prior to merging across multiple samples.</p>
</blockquote>

<pre><code>(This function takes no parameters)
</code></pre>

<h3>fixInfoFieldMetadata</h3>

<blockquote>
  <p>This function swaps out fields from an INFO header line, allowing you to change the Number, desc, etc. This can be useful when a field has invalid metadata, or for adding descriptions and documentation to your fields.</p>
</blockquote>

<pre><code>field: (String, required)
Type: (String)
Number: (String)
desc: (String)
removeMeta: (Flag)
</code></pre>

<h3>fixFormatFieldMetadata</h3>

<blockquote>
  <p>This function swaps out fields from an INFO header line, allowing you to change the Number, desc, etc. This can be useful when a field has invalid metadata, or for adding descriptions and documentation to your fields.</p>
</blockquote>

<pre><code>field: (String, required)
Type: (String)
Number: (String)
desc: (String)
removeMeta: (Flag)
</code></pre>

<h3>mergeSamplesIntoSingleColumn</h3>

<blockquote>
  <p>This utility copies multiple samples into a single merged sample.</p>
</blockquote>

<pre><code>suffixes: Must be a comma delimited list with a short name for each sample column.(String, 
    required)
sampID: The name for the new sample column(String, required)
</code></pre>

</section> <h1>INFO TAG FUNCTIONS</h1> <section>

<pre><code>Info Tag Functions are simple modular functions that take one variant at a time and add a new 
    INFO field.
Basic Syntax:
    --FCN addInfoTag|newTagID|FCN( param1, param2, etc. )
</code></pre>

<h6>Example 1:</h6>

<pre><code>Make a new INFO field which is the maximum from several allele frequencies (which are already in 
    the file) Then make a 0/1 INFO field that is 1 if the max AF is less than 0.01. Note the 
    CONST:0 term, which allows you to include constant values in these functions. In this case it 
    makes it so that if the AF is missing in all three populations, the maxAF will be 0 rather 
    than missing.
varmyknife walkVcf \
--fcn "addInfo|maxAF|MAX(CEU_AF,AFR_AF,JPT_AF,CONST:0)|\
desc=The max allele frequency from CEU_AF, AFR_AF, or JPT_AF (or zero if all are missing)."\
--fcn "addInfo|isRare|EXPR(INFO.lt:maxAF:0.01)"\
infile.vcf.gz outfile.vcf.gz
</code></pre>

<h6>End Example</h6>

<h6>Example 2:</h6>

<pre><code>varmyknife walkVcf \
--fcn "addInfo|CarryCt|SUM(hetCount,homAltCount)|\
desc=The sum of the info tags: hetCount and homAltCount."\
infile.vcf.gz outfile.vcf.gz
</code></pre>

<h6>End Example</h6>

</section> <h2>Available Functions:</h2> <section>

<h3>LN(x)</h3>

<pre><code>Input should be a numeric INFO field. output will be the natural log of that field.
x (INFO:Int|INFO:Float|CONST:Int|CONST:Float)
</code></pre>

<h3>MULT(x,y)</h3>

<pre><code>Input should be a pair of info fields and/or numeric constants (which must be specified as 
    CONST:n). Output field will be the product of the two inputs. Missing INFO fields will be 
    treated as ZEROS unless all params are INFO fields and all are missing, in which case the 
    output will be missing. Output field type will be an integer if all inputs are integers and 
    otherwise a float.
x (INFO:Int|INFO:Float|CONST:Int|CONST:Float) 
y (INFO:Int|INFO:Float|CONST:Int|CONST:Float)
</code></pre>

<h3>TO.UPPER.CASE(x)</h3>

<pre><code>Input should be an INFO field. All alphabetic characters in the field will be converted to Upper 
    case.
x (INFO:String)
</code></pre>

<h3>DIFF(x,y)</h3>

<pre><code>Input should be a pair of info fields and/or numeric constants (which must be specified as 
    CONST:n). Output field will be the difference of the two inputs (ie x - y). Missing INFO 
    fields will be treated as ZEROS unless all params are INFO fields and all are missing, in 
    which case the output will be missing. Output field type will be an integer if all inputs are 
    integers and otherwise a float.
x (INFO:Int|INFO:Float|CONST:Int|CONST:Float) 
y (INFO:Int|INFO:Float|CONST:Int|CONST:Float)
</code></pre>

<h3>SUM(x...)</h3>

<pre><code>Input should be a set of info tags and/or numeric constants (which must be specified as CONST:n). 
    Output field will be the sum of the inputs. Missing INFO fields will be treated as zeros 
    unless all params are INFO fields and all are missing, in which case the output will be 
    missing. Output field type will be an integer if all inputs are integers and otherwise a 
    float.
x... (INFO:Int|INFO:Float|CONST:Int|CONST:Float)
</code></pre>

<h3>FLAGSET(x...)</h3>

<pre><code>Input should be a set of infoFields and optionally a name, with the format tagID:name or just 
    tagID. If names are omitted, then the name will be equal to the tagID. Output field will be 
    the set of names for which the respective info field is equal to 1. Any value other than 1, 
    including missing fields, will be treated as 0.
x... (INFO:Int)
</code></pre>

<h3>LEN(x)</h3>

<pre><code>The new field will be an integer field equal to the length of the input field. Will be missing if 
    the input field is missing.
x (INFO:String|INFO:Int|INFO:Float)
</code></pre>

<h3>RANDFLAG(x,seed)</h3>

<pre><code>x (FLOAT) 
seed (INT)
</code></pre>

<h3>SETS.KEEP.ELEMENTS.THAT.CONTAIN(info,str)</h3>

<pre><code>First parameter should be an INFO field, second parameter is a string. Any elements in the INFO 
    field that contain the string will be dropped. Does not do pattern matching, simple 
    replacement.
info (INFO:String) 
str (CONST:String)
</code></pre>

<h3>TO.LOWER.CASE(x)</h3>

<pre><code>Input should be an INFO field. All alphabetic characters in the field will be converted to Lower 
    case.
x (INFO:String)
</code></pre>

<h3>DIV(x,y)</h3>

<pre><code>Input should be a pair of info fields and/or numeric constants (which must be specified as 
    CONST:n). Output field will be the product of the two inputs. Missing INFO fields will be 
    treated as ZEROS unless all params are INFO fields and all are missing, in which case the 
    output will be missing. Output field type will be a float.
x (INFO:Int|INFO:Float|CONST:Int|CONST:Float) 
y (INFO:Int|INFO:Float|CONST:Int|CONST:Float)
</code></pre>

<h3>MIN(x...)</h3>

<pre><code>x... (INFO:Int|INFO:Float|CONST:Int|CONST:Float)
</code></pre>

<h3>SETS.DROP.ELEMENTS.THAT.CONTAIN(info,str)</h3>

<pre><code>First parameter should be an INFO field, second parameter is a string. Any elements in the INFO 
    field that contain the string will be dropped. Does not do pattern matching, simple 
    replacement.
info (INFO:String) 
str (CONST:String)
</code></pre>

<h3>CONVERT.TO.INT(x,defaultValue)</h3>

<pre><code>Input should be an INFO field, usually of type String. Converts field to a Integer. By default 
    failed conversions will simply be left out. if the defaultValue option is included, then 
    failed conversions will be set to the defaultValue.
x (INFO:String) 
defaultValue (Optional) (CONST:Int)
</code></pre>

<h3>CONVERT.TO.FLOAT(x,defaultValue)</h3>

<pre><code>Input should be an INFO field. Converts to a numeric float. If no defaultValue is supplied then 
    non-floats will be dropped. Note that NaN and Inf will be dropped / replaced with the default.
x (INFO:String) 
defaultValue (Optional) (CONST:Float)
</code></pre>

<h3>STRING.REPLACE(old,new,info)</h3>

<pre><code>Simple string replacement. First parameter should be the old string, second parameter the 
    replacement string, and the third parameter an INFO field. Any time the old string appears in 
    the INFO field it will be replaced by the new string. Does not do pattern matching, simple 
    replacement.
old (CONST:String) 
new (CONST:String) 
info (INFO:String)
</code></pre>

<h3>EXPR(expr)</h3>

<pre><code>The new field will be an integer field which will be equal to 1 if and only if the expression is 
    TRUE, and 0 otherwise. See the expression format definition for more information on how the 
    logical expression syntax works.
expr (STRING)
</code></pre>

<h3>DECODE(x,decoder)</h3>

<pre><code>Decodes an INFO field. Decoder must be a simple 2-column tab-delimited file with the old ID 
    first. Any time an element in the INFO field x matches an element in the first column of the 
    text file, it will be swapped with the corresponding entry in the second column of the text 
    file. Elements that do not match any element in the first column will be unchanged.
x (INFO:String) 
decoder (FILE:String)
</code></pre>

<h3>STRING.REPLACE.WITHCOMMA(old,info)</h3>

<pre><code>Simple string replacement. First parameter should be the old string, second parameter an INFO 
    field. Any time the old string appears in the INFO field it will be replaced by a comma. Does 
    not do pattern matching, simple replacement.
old (CONST:String) 
info (INFO:String)
</code></pre>

<h3>CONCAT(x...)</h3>

<pre><code>This simple function concatenates the values of the input parameters. Input parameters can be any 
    combination of INFO fields or constant strings.
x... (INFO:String|CONST:String)
</code></pre>

<h3>SUM.GENO(x)</h3>

<pre><code>Input should be a genotype field. Output field will be the sum of the given genotype field or 
    fields. If the field is missing across all samples, the INFO field will also be missing, 
    otherwise missing values will be treated as zeros. Output field type will be an integer if 
    the inputs is an integer field and otherwise a float.
x (GENO:Int|GENO:Float)
</code></pre>

<h3>LOG10(x)</h3>

<pre><code>Input should be a numeric INFO field. output will be the log10 of that field.
x (INFO:Int|INFO:Float|CONST:Int|CONST:Float)
</code></pre>

<h3>PRODUCT.ARRAY(x...)</h3>

<pre><code>Input should be a set of info fields and/or numeric constants (which must be specified as 
    CONST:n). Output field will be the product of the inputs. Missing INFO fields will be treated 
    as ones unless all params are INFO fields and all are missing, in which case the output will 
    be missing. Output field type will be an integer if all inputs are integers and otherwise a 
    float.
x... (INFO:Int|INFO:Float|CONST:Int|CONST:Float)
</code></pre>

<h3>SETS.DIFF(x,y)</h3>

<pre><code>Input should be a pair of sets that are either INFO fields specified as INFO:tagID, text files 
    specified as FILE:fileName, or a constant set delimited with colons.Output field will be a 
    comma delimited string containing the elements in the first set with the second set 
    subtracted out.
x (INFO:String|INFO:Int|INFO:Float|FILE:String|CONST:String|CONST:Int|CONST:Float) 
y (INFO:String|INFO:Int|INFO:Float|FILE:String|CONST:String|CONST:Int|CONST:Float)
</code></pre>

<h3>blanksToDots(info)</h3>

<pre><code>If a field is left blank, this will properly replace the blank with a period, which is the proper 
    missing value symbol
info (INFO:String)
</code></pre>

<h3>SWITCH.EXPR(expr,A,B)</h3>

<pre><code>Switches between two options depending on a logical expression. The 'expr' expression parameter 
    must be formatted like standard variant-level expressions. The A and B parameters can each be 
    either a constant or an INFO field. The output field will be equal to A if the logical 
    expression is TRUE, and otherwise will be B.
expr (STRING) 
A (INFO:Int|INFO:Float|INFO:String|CONST:Int|CONST:Float|CONST:String) 
B (Optional) (INFO:Int|INFO:Float|INFO:String|CONST:Int|CONST:Float|CONST:String)
</code></pre>

<h3>GT.EXPR(gtExpr,varExpr)</h3>

<pre><code>The new field will be an integer field which will be equal to the number of samples that satisfy 
    a given genotype-level expression. See the expression format definition for more information 
    on how the logical expression syntax works. You can also specify a variant-level expression 
    which, if false, will return missing.
gtExpr (Optional) (STRING) 
varExpr (Optional) (STRING)
</code></pre>

<h3>COLLATE(inputDelimName,outputDelimOuter,outputDelimInner,x...)</h3>

<pre><code>This takes multiple ordered info fields and collates them. The new output INFO field will be a 
    list of lists. The first list in the list of lists will be composed of The first element of 
    the first field, the first element of the second field, the first element of the third field, 
    and so on. The second list in the list of lists will be composed of the second element of the 
    first field, the second element of the second field, and so on. Delimiters in the input lists 
    as well as the two delimiters used in the output can have the following names: colon, comma, 
    bar, slash, period, or ampersand. Note that the input delim can be a slash-delimited list of 
    delimiter names.
inputDelimName (CONST:String) 
outputDelimOuter (CONST:String) 
outputDelimInner (CONST:String) 
x... (INFO:String)
</code></pre>

<h3>MAX(x...)</h3>

<pre><code>x... (INFO:Int|INFO:Float|CONST:Int|CONST:Float)
</code></pre>

<h3>PICK.RANDOM(seed,x,y...)</h3>

<pre><code>The first parameter must be either '.' or a supplied random seed for the random number generator. 
    You can then provide either a single additional parameter and the output field will be a 
    randomly picked element from that parameter. In this case the output will be chosen from this 
    one input parameter (which is assumed to be a list of some sort), which can be a string 
    constant list delimited with colons and beginning with CONST:, an INFO field, or a text file 
    specified as FILE:filename. Alternately: you can provide several additional parameters, in 
    which case it will select randomly from the set of parameters.
seed (String) 
x (INFO:String|FILE:String|CONST:String) 
y... (Optional) (INFO:String|CONST:String)
</code></pre>

<h3>SETS.UNION(x...)</h3>

<pre><code>The new field will be equal to the union of the inputs. Inputs can either be INFO fields 
    specified with 'INFO:tagName', can point to a text file with 'FILE:filename', or can be 
    constants (delimited with colons). The output will be the union of the given parameters, in 
    alphabetical order.
x... (String|INFO:String|FILE:String)
</code></pre>

<h3>COPY(oldField)</h3>

<pre><code>oldField (INFO:INT|INFO:Float|INFO:String)
</code></pre>

<h3>CONVERT.FLAG.TO.BOOLEAN(x)</h3>

<pre><code>Input should be a single INFO field of type Flag
x (CONST:String)
</code></pre>

<h3>SETS.INTERSECT(x...)</h3>

<pre><code>Input should be a pair of sets that are either INFO fields specified as INFO:tagID, text files 
    specified as FILE:fileName, or a constant set delimited with colons. Output field will be a 
    comma delimited string containing the intersect between the supplied sets.
x... (INFO:String|FILE:String|CONST:String)
</code></pre>

<h3>CONST(x)</h3>

<pre><code>Input should be a simple string of characters
x (CONST:String)
</code></pre>

</section> <h1>FORMAT TAG FUNCTIONS</h1> <section>

<pre><code>This is a set of functions that all take one or more input parameters and outputs one new FORMAT 
    field. The syntax is: --fcn "addInfo|newTagName|fcn(param1,param2,...)". Optionally you can 
    add "|desc=tag description". There are numerous addInfo functions. For more information, go 
    to the section on addFormat Functions below, or use the help command: varmyknife help 
    addFormat
Basic Syntax:
    --FCN addFormat|newTagID|FCN( param1, param2, etc. )
</code></pre>

<h6>Example 1:</h6>

<pre><code>This example makes a new FORMAT field which is the ratio between the coverage on the first ALT 
    allele and the total coverage across all alleles.
varmyknife walkVcf \
--fcn "addFormat|AlleleDepth_ALTALLE|extractIDX(AD,1)|\
desc=The observed allele depth for the first alt allele."\
--fcn "addFormat|AlleleDepth_TOTAL|SUM(AD)|\
desc=The observed allele depth for the first alt allele."\
infile.vcf.gz outfile.vcf.gz
</code></pre>

<h6>End Example</h6>

<h6>Example 2:</h6>

<pre><code>varmyknife walkVcf \
--fcn "addInfo|CarryCt|SUM(hetCount,homAltCount)|\
desc=The sum of the info tags: hetCount and homAltCount."\
infile.vcf.gz outfile.vcf.gz
</code></pre>

<h6>End Example</h6>

</section> <h2>Available Functions:</h2> <section>

<h3>convertBPtoGT(x,delim)</h3>

<pre><code> . 
x (GENO:String) 
delim (Optional) (CONST:String)
</code></pre>

<h3>SUM(x...)</h3>

<pre><code>Input should be a set of format tags and/or numeric constants (which must be specified as 
    CONST:n) or info tags (which must be specified as INFO:n). Output field will be the sum of 
    the inputs. Missing fields will be treated as zeros. Output field type will be an integer if 
    all inputs are integers and otherwise a float.
x... (GENO:Int|GENO:Float|INFO:Int|INFO:Float|CONST:Int|CONST:Float)
</code></pre>

<h3>DIV(x,y)</h3>

<pre><code>Input should be a set of format tags and/or numeric constants (which must be specified as 
    CONST:n) or info tags (which must be specified as INFO:n). Output field will be the sum of 
    the inputs. Any missing values result in a missing result.
x (GENO:Int|GENO:Float|INFO:Int|INFO:Float|CONST:Int|CONST:Float) 
y (GENO:Int|GENO:Float|INFO:Int|INFO:Float|CONST:Int|CONST:Float)
</code></pre>

<h3>extractIDX(x,i,delim)</h3>

<pre><code>This function takes a genotype field x which must be a list field and an index i. The newly 
    created FORMAT field will be equal to element i from the field x (counting from 0). If there 
    is no element i, it will be set to the missing value (.).
x (GENO:Int|GENO:Float|GENO:String) 
i (CONST:Int) 
delim (Optional) (CONST:String)
</code></pre>

<h3>EXPR(gtExpr,varExpr)</h3>

<pre><code>This function takes a genotype-level logical expressiong gtExpr and a variant-level logical 
    expression varExpr. The new FORMAT field will be equal to 1 if and only if both gtExpr and 
    varExpr return TRUE. Otherwise the field will equal 0.
gtExpr (CONST:String) 
varExpr (Optional) (CONST:String)
</code></pre>

<h3>IF.AB(gtExpr,A,B)</h3>

<pre><code>This function takes a genotype-level logical expression gtExpr and two additional variables A and 
    B. A and B can each be a FORMAT field, a INFO field (specified as INFO:x), or a string 
    constant (specified as CONST:x). If gtExpr returns TRUE, then the new FORMAT field will equal 
    the corresponding value of A. If the gtExpr returns FALSE, the new FORMAT field will equal 
    the corresponding value of B.
gtExpr (CONST:String) 
A (GENO:String|INFO:String|CONST:String) 
B (GENO:String|INFO:String|CONST:String)
</code></pre>

</section> <h1>TALLY FUNCTIONS</h1> <section>

<pre><code>This is a set of functions that takes various stats from each variant and sums them up across the 
    whole VCF. These functions DO NOT change the VCF itself, they simply emit meta information 
    about the VCF. See the help section on TALLY FUNCTIONS.

Basic Syntax:
    --FCN tally|x|FCN( param1, param2, etc. )
</code></pre>

</section> <h2>Available Functions:</h2> <section>

<h3>TALLY.SUM.IF(expr,x...)</h3>

<pre><code>Takes as input a variant expression expr and a constant or INFO field x. Output will be the sum 
    of all x where expr is TRUE. Set x to CONST:1 to simply count the number of variants.
expr (String) 
x... (INFO:Int|INFO:Float|CONST:Int|CONST:Float)
</code></pre>

<h3>GTCOUNT.BYSAMPLE(varExpr,gtExpr)</h3>

<pre><code>Takes as input a variant expression varExpr and a genotype level expression gtExpr. This function 
    will report a file-wide count of the number of genotypes where both varExpr is true at the 
    variant level AND gtExpr is true on the individual level.
varExpr (String) 
gtExpr (String)
</code></pre>

<h3>TALLY.SUM.IF.byGROUP(expr,group...,x...)</h3>

<pre><code>Takes a variant expression expr, an INFO field "group" and an INFO field x. Will output an entry 
    for each unique value of the group variable. For each distinct value of the group variable g, 
    will output the sum of all x in which the group variable equals g AND where expr is TRUE. 
    This is especially useful for generating counts for each gene.
expr (String) 
group... (INFO:String) 
x... (INFO:Int|INFO:Float|CONST:Int|CONST:Float)
</code></pre>

</section> <h1>VARIANT-LEVEL BOOLEAN EXPRESSIONS</h1> <section>

<p>Variant expressions are logical expressions that are performed at 
the variant level. They are used by several parts of vArmyKnife, 
usually when filtering or differentiating variants based on it's 
properties/stats. For any given variant, a variant expression will 
return either TRUE or FALSE. Variant expressions are parsed as a 
series of logical functions connected with AND, OR, NOT, and 
parentheses. All expressions MUST be separated with whitespace, 
though it does not matter how much whitespace or what kind. 
Alternatively, expressions can be read directly from file by 
setting the expression toEXPRESSIONFILE:filepath.</p>

<p>Variant Expression functions are all of the format 
FILTERNAME:PARAM1:PARAM2:etc. Some filters have no parameters; 
other filters can accept a variable number of parameters. All 
expression functions return TRUE or FALSE. Filters can be inverted 
using the NOT operator before the filter (with whitespace in 
between).</p>

<h3>True/False Functions:</h3>

<h4>ALT.eq:k</h4>

<blockquote>
  <p>TRUE iff the first ALT allele equals k.</p>
</blockquote>

<h4>ALT.isOneOf:k1:k2:...</h4>

<blockquote>
  <p>TRUE iff the first ALT allele is one of k1,k2,...</p>
</blockquote>

<h4>ALT.len.eq:k</h4>

<blockquote>
  <p>TRUE iff the first ALT allele is of length k.</p>
</blockquote>

<h4>ALT.len.gt:k</h4>

<blockquote>
  <p>TRUE iff the first ALT allele is of length gt k.</p>
</blockquote>

<h4>AnyGtNonRef:gtTag</h4>

<blockquote>
  <p>TRUE iff gtTag has an alt allele for any sample. gtTag must be a GT-formatted genotype field.</p>
</blockquote>

<h4>AnyGtPass:simpleGtFiltExpression:k1:...</h4>

<blockquote>
  <p>TRUE iff any one of the samples pass the supplied GT filter.</p>
</blockquote>

<h4>CHROM.inAnyOf:chrX:...</h4>

<blockquote>
  <p>TRUE iff the variant is one one of the given chromosomes</p>
</blockquote>

<h4>FALSE:</h4>

<blockquote>
  <p>Never TRUE</p>
</blockquote>

<h4>FILTER.eq:k</h4>

<blockquote>
  <p>TRUE iff the FILTER column is equal to k.</p>
</blockquote>

<h4>FILTER.ne:k</h4>

<blockquote>
  <p>TRUE iff the FILTER column is not equal to k.</p>
</blockquote>

<h4>GENO.MAFgt:t:k</h4>

<blockquote>
  <p>TRUE iff the genotype-field tag t is a genotype-style-formatted field and the minor allele frequency is greater than k.</p>
</blockquote>

<h4>GENO.MAFlt:t:k</h4>

<blockquote>
  <p>TRUE iff the genotype-field tag t is a genotype-style-formatted field and the minor allele frequency is less than k.</p>
</blockquote>

<h4>GENO.hasTagPairGtStyleMismatch:t1:t2</h4>

<blockquote>
  <p>TRUE iff the genotype-field t1 and t2 are both found on a given line and have at least 1 sample where both tags are not set to missing but they do not have the same value.</p>
</blockquote>

<h4>GENO.hasTagPairMismatch:t1:t2</h4>

<blockquote>
  <p>TRUE iff the genotype-field t1 and t2 are both found on a given line but are not always equal for all samples.</p>
</blockquote>

<h4>GTAG.any.gt:gtTag:k</h4>

<blockquote>
  <p>TRUE iff any one of the samples have a value for their genotype-tag entry greater than k.</p>
</blockquote>

<h4>INFO.any.gt:t:k</h4>

<blockquote>
  <p>TRUE iff INFO field t is nonmissing and less than or equal to k.</p>
</blockquote>

<h4>INFO.any.lt:t:k</h4>

<blockquote>
  <p>TRUE iff INFO field t is nonmissing and less than or equal to k.</p>
</blockquote>

<h4>INFO.eq:t:k</h4>

<blockquote>
  <p>TRUE iff INFO field t is nonmissing and equal to k.</p>
</blockquote>

<h4>INFO.ge:t:k</h4>

<blockquote>
  <p>TRUE iff INFO field t is nonmissing and greater than or equal to k.</p>
</blockquote>

<h4>INFO.gem:t:k</h4>

<blockquote>
  <p>TRUE iff INFO field t is missing or greater than or equal to k.</p>
</blockquote>

<h4>INFO.gt:t:k</h4>

<blockquote>
  <p>TRUE iff INFO field t is nonmissing and greater than k.</p>
</blockquote>

<h4>INFO.gtm:t:k</h4>

<blockquote>
  <p>TRUE iff INFO field t is missing or greater than k.</p>
</blockquote>

<h4>INFO.in:t:k</h4>

<blockquote>
  <p>TRUE iff INFO field t is a comma delimited list that contains string k.</p>
</blockquote>

<h4>INFO.inAny:t:k</h4>

<blockquote>
  <p>TRUE if INFO field t is a list delimited with commas and bars, and contains string k.</p>
</blockquote>

<h4>INFO.inAnyOf:t:k1:k2:...</h4>

<blockquote>
  <p>TRUE iff INFO field t is a list delimited with commas and bars, and contains any of the parameters k1,k2,...</p>
</blockquote>

<h4>INFO.inAnyOfN:t:k1:k2:...</h4>

<blockquote>
  <p>TRUE iff INFO field t is a list delimited with commas, bars, slashes, OR COLONS, and contains any of the parameters k1,k2,...</p>
</blockquote>

<h4>INFO.inAnyOfND:t:k1:k2:...</h4>

<blockquote>
  <p>TRUE iff INFO field t is a list delimited with commas, bars, slashes, colons, or dashes, and contains any of the parameters k1,k2,...</p>
</blockquote>

<h4>INFO.le:t:k</h4>

<blockquote>
  <p>TRUE iff INFO field t is nonmissing and less than or equal to k.</p>
</blockquote>

<h4>INFO.lem:t:k</h4>

<blockquote>
  <p>TRUE iff INFO field t is missing or less than or equal to k</p>
</blockquote>

<h4>INFO.len.eq:t:k</h4>

<blockquote>
  <p>TRUE iff INFO field t is nonmissing and has length equal to k.</p>
</blockquote>

<h4>INFO.len.gt:t:k</h4>

<blockquote>
  <p>TRUE iff INFO field t is nonmissing and has length greater than k.</p>
</blockquote>

<h4>INFO.len.lt:t:k</h4>

<blockquote>
  <p>TRUE iff INFO field t is nonmissing and has length less than k.</p>
</blockquote>

<h4>INFO.lt:t:k</h4>

<blockquote>
  <p>TRUE iff INFO field t is nonmissing and less than k.</p>
</blockquote>

<h4>INFO.ltm:t:k</h4>

<blockquote>
  <p>TRUE iff INFO field t is missing or less than k.</p>
</blockquote>

<h4>INFO.m:t</h4>

<blockquote>
  <p>TRUE iff INFO field t is missing.</p>
</blockquote>

<h4>INFO.mempty:t</h4>

<blockquote>
  <p>TRUE iff INFO field t is missing or less than or equal to k</p>
</blockquote>

<h4>INFO.ne:t:k</h4>

<blockquote>
  <p>TRUE iff INFO field t is either missing or not equal to k.</p>
</blockquote>

<h4>INFO.nm:t</h4>

<blockquote>
  <p>TRUE iff INFO field t is nonmissing.</p>
</blockquote>

<h4>INFO.notIn:t:k</h4>

<blockquote>
  <p>TRUE iff INFO field t is missing or is a comma delimited list that does NOT contain string k.</p>
</blockquote>

<h4>INFO.notInAny:t:k</h4>

<blockquote>
  <p>TRUE if INFO field t is a list delimited with commas and bars, and does not contain string k.</p>
</blockquote>

<h4>INFO.subsetOf:t:k1:k2:...</h4>

<blockquote>
  <p>TRUE iff INFO field t is a comma delimited list and is a subset of k1,k2,etc</p>
</blockquote>

<h4>INFO.subsetOfFileList:t:f</h4>

<blockquote>
  <p>TRUE iff INFO field t is a comma delimited list and is a subset of the list contained in file f</p>
</blockquote>

<h4>INFO.tagsDiff:t1:t2</h4>

<blockquote>
  <p>TRUE iff the INFO-field t1 and t2 are different, including when one is missing and the other is not.</p>
</blockquote>

<h4>INFO.tagsMismatch:t1:t2</h4>

<blockquote>
  <p>TRUE iff the INFO-field t1 and t2 are both found on a given line but are not equal.</p>
</blockquote>

<h4>LOCUS.eq:chrom:pos</h4>

<blockquote>
  <p>TRUE if the variant is at the given chromosome and position</p>
</blockquote>

<h4>LOCUS.near:k:chrom:pos</h4>

<blockquote>
  <p>TRUE if the variant is within k bases from the given chromosome and position</p>
</blockquote>

<h4>LOCUS.range:chrom:from:to</h4>

<blockquote>
  <p>TRUE if the variant is at the given chromosome and between the given positions (0-based)</p>
</blockquote>

<h4>POS.gt:pos</h4>

<blockquote>
  <p>TRUE iff the variant is at a position greater than the given position</p>
</blockquote>

<h4>POS.inAnyOf:pos1:...</h4>

<blockquote>
  <p>TRUE iff the variant is at one of the given positions</p>
</blockquote>

<h4>QUAL.gt:k</h4>

<blockquote>
  <p>TRUE iff the QUAL column is greater than k.</p>
</blockquote>

<h4>QUAL.gtm:k</h4>

<blockquote>
  <p>TRUE iff the QUAL column is greater than k, OR qual is missing.</p>
</blockquote>

<h4>REF.eq:k</h4>

<blockquote>
  <p>TRUE iff the REF allele equals k.</p>
</blockquote>

<h4>REF.isOneOf:k1:k2:...</h4>

<blockquote>
  <p>TRUE iff the REF allele is one of k1,k2,...</p>
</blockquote>

<h4>REF.len.eq:k</h4>

<blockquote>
  <p>TRUE iff the REF allele is of length k.</p>
</blockquote>

<h4>REF.len.gt:k</h4>

<blockquote>
  <p>TRUE iff the REF allele is of length gt k.</p>
</blockquote>

<h4>TRUE:</h4>

<blockquote>
  <p>Always TRUE</p>
</blockquote>

<h4>allelesHaveNoNs:</h4>

<blockquote>
  <p>FALSE iff the variant has unknown bases, ie N, in the ALT or REF alleles.</p>
</blockquote>

<h4>isSNV:</h4>

<blockquote>
  <p>TRUE iff the variant is an SNV.</p>
</blockquote>

<h4>isVariant:</h4>

<blockquote>
  <p>FALSE iff the variant has no alt alleles, or if the only alt allele is exactly equal to the ref allele.</p>
</blockquote>

<h4>simpleSNV:</h4>

<blockquote>
  <p>TRUE iff the variant is a biallelic SNV.</p>
</blockquote>

</section> <h1>GENOTYPE-LEVEL BOOLEAN EXPRESSIONS</h1> <section>

<p>Genotype-level expressions are logical expressions that are 
performed at the GENOTYPE level. In other words, for each sample 
in each variant line. They are used by several parts of 
vArmyKnife, usually when filtering or differentiating genotypes 
based on their properties/stats. For any given variant, a genotype 
expression will return either TRUE or FALSE for each sample. 
Genotype expressions are parsed as a series of logical functions 
connected with AND, OR, NOT, and parentheses. All expressions MUST 
be separated with whitespace, though it does not matter how much 
whitespace or what kind. Alternatively, expressions can be read 
directly from file by setting the expression to 
EXPRESSIONFILE:filepath.</p>

<p>Genotype Expression functions are all of the format 
FILTERNAME:PARAM1:PARAM2:etc. Some filters have no parameters; 
other filters can accept a variable number of parameters. All 
expression functions return TRUE or FALSE. Filters can be inverted 
using the NOT operator before the filter (with whitespace in 
between).</p>

<h3>True/False Functions:</h3>

<h4>FALSE:</h4>

<blockquote>
  <p>Never pass</p>
</blockquote>

<h4>GTAG.SC.altDepth.gt:splitIdxTag:t:v</h4>

<blockquote>
  <p>TRUE iff the tag t, which must be a single-caller-AD-style-formatted field, has an observed alt-allele-frequency greater than k.</p>
</blockquote>

<h4>GTAG.SC.altDepth.lt:splitIdxTag:t:v</h4>

<blockquote>
  <p>TRUE iff the tag t, which must be a single-caller-AD-style-formatted field, has an observed alt-allele-frequency greater than k.</p>
</blockquote>

<h4>GTAG.SC.altProportion.gt:splitIdxTag:t:v</h4>

<blockquote>
  <p>TRUE iff the tag t, which must be a single-caller-AD-style-formatted field, has an observed alt-allele-frequency greater than k.</p>
</blockquote>

<h4>GTAG.SC.altProportion.lt:splitIdxTag:t:v</h4>

<blockquote>
  <p>TRUE iff the tag t, which must be a single-caller-AD-style-formatted field, has an observed alt-allele-frequency greater than k.</p>
</blockquote>

<h4>GTAG.altDepthForAlle.gt:gt:ad:v</h4>

<blockquote>
  <p>TRUE iff for AD-style tag ad and GT-style tag gt, the sample is called as having an allele K while having less than v reads covering said allele.</p>
</blockquote>

<h4>GTAG.altProportion.gt:t:k</h4>

<blockquote>
  <p>TRUE iff the tag t, which must be a AD-style-formatted field, has an observed alt-allele-frequency greater than k.</p>
</blockquote>

<h4>GTAG.altProportion.lt:t:k</h4>

<blockquote>
  <p>TRUE iff the tag t, which must be a AD-style-formatted field, has an observed alt-allele-frequency less than k.</p>
</blockquote>

<h4>GTAG.eq:t:s</h4>

<blockquote>
  <p>TRUE iff GT field t equals the string s. DROP if tag t is not present or set to missing.</p>
</blockquote>

<h4>GTAG.ge:t:k</h4>

<blockquote>
  <p>TRUE iff tag t is present and not set to missing, and is a number greater than or equal to k.</p>
</blockquote>

<h4>GTAG.gem:t:k</h4>

<blockquote>
  <p>TRUE iff tag t is either not present, set to missing, or a number greater than or equal to k.</p>
</blockquote>

<h4>GTAG.gt:t:k</h4>

<blockquote>
  <p>TRUE iff tag t is present and not set to missing, and is a number greater than k.</p>
</blockquote>

<h4>GTAG.gtm:t:k</h4>

<blockquote>
  <p>TRUE iff tag t is either not present, set to missing, or a number greater than k.</p>
</blockquote>

<h4>GTAG.inAnyOf:t:k</h4>

<blockquote>
  <p>TRUE iff the first parameter, a FORMAT field, is equal to any of the following parameters or is a list containing any of the following parameters, using commas, bars, or slashes as delimiters.</p>
</blockquote>

<h4>GTAG.isAnyAlt:t</h4>

<blockquote>
  <p>TRUE iff the tag t, which must be a genotype-style-formatted field, is present and not set to missing and contains the alt allele.</p>
</blockquote>

<h4>GTAG.isCleanHet:t</h4>

<blockquote>
  <p>TRUE iff the tag t, which must be a genotype-style-formatted field, is present and not set to missing and is heterozygous between the alt and reference allele.</p>
</blockquote>

<h4>GTAG.isHet:t</h4>

<blockquote>
  <p>TRUE iff the tag t, which must be a genotype-style-formatted field, is present and not set to missing and is heterozygous.</p>
</blockquote>

<h4>GTAG.isHomAlt:t</h4>

<blockquote>
  <p>TRUE iff the tag t, which must be a genotype-style-formatted field, is present and not set to missing and is homozygous-alt.</p>
</blockquote>

<h4>GTAG.isHomRef:t</h4>

<blockquote>
  <p>TRUE iff the tag t, which must be a genotype-style-formatted field, is present and not set to missing and is homozygous-reference.</p>
</blockquote>

<h4>GTAG.le:t:k</h4>

<blockquote>
  <p>TRUE iff tag t is present and not set to missing, and is a number less than or equal to k.</p>
</blockquote>

<h4>GTAG.lem:t:k</h4>

<blockquote>
  <p>TRUE iff tag t is either not present, set to missing, or a number less than or equal to k.</p>
</blockquote>

<h4>GTAG.lt:t:k</h4>

<blockquote>
  <p>TRUE iff tag t is present and not set to missing, and is a number less than k.</p>
</blockquote>

<h4>GTAG.ltm:t:k</h4>

<blockquote>
  <p>TRUE iff tag t is either not present, set to missing, or a number less than k.</p>
</blockquote>

<h4>GTAG.m:t:k</h4>

<blockquote>
  <p>TRUE iff the GT field t is is not present or set to missing.</p>
</blockquote>

<h4>GTAG.mg:t</h4>

<blockquote>
  <p>TRUE iff the GT field t is not present or is missing or is set to a missing genotype (./.).</p>
</blockquote>

<h4>GTAG.ne:t:k</h4>

<blockquote>
  <p>TRUE iff GT field t does not equal the string s. DROP if tag t is not present or set to missing.</p>
</blockquote>

<h4>GTAG.nm:t</h4>

<blockquote>
  <p>TRUE iff the GT field t is present and not set to missing.</p>
</blockquote>

<h4>GTAG.nmg:t</h4>

<blockquote>
  <p>TRUE iff the GT field t is present and not set to missing and is not set to a missing genotype (./.).</p>
</blockquote>

<h4>GTAGARRAY.gt:t:i:k</h4>

<blockquote>
  <p>TRUE iff the tag t is present and not set to missing, and is a list with at least i elements, and the i-th element of which is greater than k.</p>
</blockquote>

<h4>GTAGARRAY.lt:t:i:k</h4>

<blockquote>
  <p>TRUE iff the tag t is present and not set to missing, and is a list with at least i elements, and the i-th element of which is less than k.</p>
</blockquote>

<h4>GTAGARRAYSUM.gt:t:k</h4>

<blockquote>
  <p>TRUE iff the tag t is present and not set to missing, and is a list of numbers the sum of which is greater than k.</p>
</blockquote>

<h4>GTAGARRAYSUM.lt:t:k</h4>

<blockquote>
  <p>TRUE iff the tag t is present and not set to missing, and is a list of numbers the sum of which is greater than k.</p>
</blockquote>

<h4>SAMPGRP.in:g</h4>

<blockquote>
  <p>TRUE iff the sample is a member of group g.</p>
</blockquote>

<h4>TAGPAIR.match:t1:t2</h4>

<blockquote>
  <p>TRUE iff the two tags t1 and t2 are both present and not set to missing, and are equal to one another.</p>
</blockquote>

<h4>TRUE:</h4>

<blockquote>
  <p>Always pass</p>
</blockquote>

<h4>VAREXPR:fcn:params</h4>

<blockquote>
  <p>Variant passes variant-level logical function. Note that you cannot include AND/OR/NOT inside this logical function, it must be a single variant-level logical function.</p>
</blockquote>

<h4>VARIANT:fcn:params</h4>

<blockquote>
  <p>Equivalent to VAREXPR.</p>
</blockquote>

</section> <h1>SECONDARY COMMANDS</h1> <section>

<p>In addition to the standard command which parses a VCF or variant table, vArmyKnife includes a few 
ancillary tools which perform other tasks.
These tools can be invoked with the command:
    varmyknife --CMD commandName [options]
For more information see the <a href="docs/secondaryCommands.html">secondary command page</a>, or use the 
command:
    varmyknife --help CMD
For a listing of all secondary commands, use the command: 
    varmyknife --help secondaryCommands</p>

</section> <h2>AUTHORS:</h2> <section>

<p>Stephen W. Hartley, Ph.D. stephen.hartley (at nih dot gov)</p>

</section> <h2>LEGAL:</h2> <section>

<p>Written 2017-2019 by Stephen Hartley, PhD  National Cancer Institute (NCI), Division of Cancer Epidemiology and Genetics (DCEG), Human Genetics Program As a work of the United States Government, this software package and all related documentation and information is in the public domain within the United States. Additionally, the National Institutes of Health and the National Cancer Institute waives copyright and related rights in the work worldwide through the CC0 1.0 Universal Public Domain Dedication (which can be found at https://creativecommons.org/publicdomain/zero/1.0/). Although all reasonable efforts have been taken to ensure the accuracy and reliability of the software and data, the National Human Genome Research Institute (NHGRI), the National Cancer Institute (NCI) and the U.S. Government does not and cannot warrant the performance or results that may be obtained by using this software or data. NHGRI, NCI and the U.S. Government disclaims all warranties as to performance, merchantability or fitness for any particular purpose. In work or products derived from this material, proper attribution of the authors as the source of the software or data may be made using "NCI Division of Cancer Epidemiology and Genetics, Human Genetics Program" as the citation. This package uses (but is not derived from) several externally-developed, open-source libraries which have been distributed under various open-source licenses. vArmyKnife is distributed with compiled versions of these packages. Additional License information can be accessed using the command:     vArmyKnife --help LICENSES And can also found in the distributed source code in:     src/main/resources/library.LICENSES.txt</p>

</div></body></html>
